<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>yym&#39;s blog</title>
    <link>http://yoursite.com/</link>
    
    <atom:link href="/rss2.html" rel="self" type="application/rss+xml"/>
    
    <description>hello world</description>
    <pubDate>Tue, 16 Jun 2020 03:03:27 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>1+X知识点总结</title>
      <link>http://yoursite.com/undefined/1+X%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</link>
      <guid>http://yoursite.com/undefined/1+X%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</guid>
      <pubDate>Tue, 16 Jun 2020 00:09:06 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;1-X知识点总结&quot;&gt;&lt;a href=&quot;#1-X知识点总结&quot; class=&quot;headerlink&quot; title=&quot;1+X知识点总结&quot;&gt;&lt;/a&gt;1+X知识点总结&lt;/h1&gt;&lt;h2 id=&quot;一：工程项目文档编写&quot;&gt;&lt;a href=&quot;#一：工程项目文档编写&quot; class=&quot;
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="1-X知识点总结"><a href="#1-X知识点总结" class="headerlink" title="1+X知识点总结"></a>1+X知识点总结</h1><h2 id="一：工程项目文档编写"><a href="#一：工程项目文档编写" class="headerlink" title="一：工程项目文档编写"></a>一：工程项目文档编写</h2><h3 id="项目流程概述"><a href="#项目流程概述" class="headerlink" title="项目流程概述"></a>项目流程概述</h3><p>项目立项-&gt;项目计划-&gt;需求阶段-&gt;设计阶段-&gt;开发阶段-&gt;测试阶段-&gt;试运行上线-&gt;项目总结</p><h3 id="项目角色介绍"><a href="#项目角色介绍" class="headerlink" title="项目角色介绍"></a>项目角色介绍</h3><p>项目角色可以分为项目经理，产品经理，开发经理，测试经理。</p><ul><li>项目经理为整个项目的核心，推动项目的整个进行，保证项目的交付。</li><li>产品经理主要负责设计项目需求，需求必须符合客户的需要。</li><li>开发经理主要进行软件设计以及代码实现，顺利的实现项目的要求。</li><li>测试经理主要负责对项目的质量进行审查，确保项目质量达到预期目标。</li></ul><h2 id="二：企业私有网络构建运维"><a href="#二：企业私有网络构建运维" class="headerlink" title="二：企业私有网络构建运维"></a>二：企业私有网络构建运维</h2><h3 id="局域网络技术"><a href="#局域网络技术" class="headerlink" title="局域网络技术"></a>局域网络技术</h3><h4 id="TCP-IP参考模型"><a href="#TCP-IP参考模型" class="headerlink" title="TCP/IP参考模型"></a>TCP/IP参考模型</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/undefined/1+X%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Misc-隐写术总结</title>
      <link>http://yoursite.com/undefined/Misc%E9%9A%90%E5%86%99%E6%9C%AF%E6%80%BB%E7%BB%93/</link>
      <guid>http://yoursite.com/undefined/Misc%E9%9A%90%E5%86%99%E6%9C%AF%E6%80%BB%E7%BB%93/</guid>
      <pubDate>Sun, 14 Jun 2020 07:37:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;Misc-隐写术总结&quot;&gt;&lt;a href=&quot;#Misc-隐写术总结&quot; class=&quot;headerlink&quot; title=&quot;Misc-隐写术总结&quot;&gt;&lt;/a&gt;Misc-隐写术总结&lt;/h1&gt;&lt;h2 id=&quot;背景介绍&quot;&gt;&lt;a href=&quot;#背景介绍&quot; class=&quot;head
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="Misc-隐写术总结"><a href="#Misc-隐写术总结" class="headerlink" title="Misc-隐写术总结"></a>Misc-隐写术总结</h1><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>隐写术是关于信息隐藏，即不让计划的接收者之外的任何人知道信息的传递事件（而不只是信息的内容）的一门技巧与科学,英文写作Steganography。而密码编码是关于信息加密，即设想到信息可能会被接受者之外的第三方获取而采取的一种措施，通过通信双方预先设定的规则对信息进行加密，使第三方即使获取到信息也无法理解其含义。所以隐写术重点在于信息的隐藏，密码编码重点在于信息的加密，这两者属于完全不同的概念。</p><p>[TOC]</p><h3 id="图片隐写术"><a href="#图片隐写术" class="headerlink" title="图片隐写术"></a>图片隐写术</h3><p>图片隐写术大致分为下列六类</p><ul><li><p>一、附加式的图片隐写</p></li><li><p>二、基于文件结构的图片隐写</p></li><li><p>三、基于LSB原理的图片隐写</p></li><li><p>四、基于DCT域的JPG图片隐写</p></li><li><p>五、数字水印的隐写</p></li><li><p>六、图片容差的隐写</p></li><li><p>其他</p></li></ul><hr><h4 id="一、附加式的图片隐写"><a href="#一、附加式的图片隐写" class="headerlink" title="一、附加式的图片隐写"></a>一、附加式的图片隐写</h4><h5 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h5><p>附加式的图片隐写通常是我们用某种程序或者方法在图片文件上直接附加被隐写的目标。</p><p>程序识别图片的过程是，从文件标识头开始，以文件标识头声明的文件格式所定义的编码格式对数据流进行读取，一直到图片的结束符，当图片处理程序识别到图片的结束符后，不再继续向下识别，所以我们就可以通过在图片结束符后添加数据达到隐写的目的。</p><p><strong>附加式图片隐写分类：</strong></p><ul><li>A丶附加字符串</li><li>B丶图种</li></ul><h5 id="A丶附加字符串"><a href="#A丶附加字符串" class="headerlink" title="A丶附加字符串"></a>A丶附加字符串</h5><p>利用工具将隐藏信息直接写入到图片结束符之后</p><p><strong>解法：</strong></p><p>strings工具扫描/将图片后缀改为<code>.txt</code>文件，打开查看末尾添加的字符串</p><p><strong>实验：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 双击打开图片，我们先确认一下图片内容并没有什么异常</span><br><span class="line">- 正如前文所说，我们这个实验部分讲的是附加字符串的隐写方式，所以我们用Strings检查一下图片</span><br><span class="line">- 在Strings工具的搜索下，就能得到隐藏在图片末尾的字符串</span><br><span class="line">&#x2F;&#x2F;也有可能是经过编码或者加密过后的字符串</span><br></pre></td></tr></table></figure><p><strong>strings使用方法</strong></p><p>strings命令在对象文件或二进制文件中查找可打印的字符串。字符串是4个或更多可打印字符的任意序列，以换行符或空字符结束。 strings命令对识别随机对象文件很有用。</p><p>选项：</p><ul><li>-a –all：扫描整个文件而不是只扫描目标文件初始化和装载段</li></ul><ul><li>-f –print-file-name：在显示字符串前先显示文件名</li><li>-t –radix={o,d,x} ：输出字符的位置，基于八进制，十进制或者十六进制</li><li>-e –encoding={s,S,b,l,B,L} ：选择字符大小和排列顺序:s = 7-bit, S = 8-bit, {b,l} = 16-bit, {B,L} = 32-bit</li></ul><p><strong>Tips  我们使用strings + 文件名字的命令即可</strong></p><p><strong>具体步骤如下：</strong></p><p>在kali中输入命令+文件名</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strings &#x2F;root&#x2F;桌面&#x2F;11111.jpg</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/11/x4yP9XTFCOzRnkG.png" alt="image-20200611150413169"></p><p>有必要提到的是，为什么字符串要附加在文件的后面呢?那是因为，如果图片附加在中间，有可能破坏了图片的信息，如果字符串附加在图片的头部位置，又破坏了文件头，可能导致图片无法识别。关于文件格式的具体内容，我们下一个部分的隐写还会提到。</p><h5 id="B丶图种"><a href="#B丶图种" class="headerlink" title="B丶图种"></a>B丶图种</h5><p>一种采用特殊方式将图片文件（如jpg格式）与rar文件结合起来的文件。该文件一般保存为jpg格式，可以正常显示图片；</p><p><strong>解法：</strong></p><ul><li>可以修改文件的后缀名，将图片改为rar压缩文件，并得到其中的数据。</li><li>binwalk / foremost分离</li></ul><p><strong>实验：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 双击打开图片，我们先确认一下图片内容并没有什么异常</span><br><span class="line">- 对图片进行检测，确认是不是图种</span><br><span class="line">- 使用binwalk&#x2F;formost分离图片，得到一个压缩包</span><br><span class="line">- 打开压缩包得到flag。</span><br></pre></td></tr></table></figure><p>简单的检测方式:</p><p>打开工具中的binwalk。使用如下命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">binwalk cqzb.jpg</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/11/ksW5dyzS9hJjntE.png" alt="image-20200611162616711"></p><p>我们可以发现，binwalk自动识别出来了zip文件，而且偏移也告诉我们了,当然我们这里可以使用</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">binwalk -e &#x2F;root&#x2F;桌面&#x2F;cqzb.jpg</span><br></pre></td></tr></table></figure><p>这个命令可以提取出binwalk检测出来的文件</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/11/jIsvnfW5R3oiltL.png" alt="image-20200611162954920"></p><p> 但是这里也可以通过另一种方式去提取压缩包，从原理上去提取。这里介绍一个工具<code>winhex16进制编辑器</code>，当然也可以使用其他的16进制编辑器。</p><p><strong>使用winhex16进制编辑器提取ZIP文件</strong></p><p>首先需要了解一下什么是文件头</p><p>文件头就是位于文件开头的一段标识文件类型的数据块</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/11/UQPuHLDokX84Sth.png" alt="image-20200611213803814"></p><p>如上图的FF D8 FF就是JPG图片的文件头，一般当我们看到文件开头是如此的格式，我们就能认为这是一个JPG图片了。</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/11/fH3NKpulMb2Aaqy.png" alt="image-20200611214620664"></p><p>一般JPG的文件尾以FFD9结尾</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/11/3FryjsmvewA4Zfx.png" alt="image-20200611214339008"></p><p>上图 50 4B 03 04就是ZIP文件的文件头，一般以PK表示。</p><p>上文我们讲述了，JPG图片的结束标识是FF D9,ZIP文件的文件头是50 4B 03 04，我们只需要在winhex中找到ZIP文件的文件头即可，滑动滚条到最底下。上文讲了一般附加的位置是在原本文件的后面，所以我们果断滑动滚动条到最后。</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/11/rvZlJpfQgFzG7VH.png" alt="image-20200611214741860"></p><p>明显此图不是以FF D9结尾，而且在上面发现了ZIP文件的文件头50 4B 03 04，所以不使用binwalk也能判断这是个图种文件。然后接下来我们就需要分离ZIP文件了。</p><p><strong>分离ZIP文件</strong></p><p>选取从文件头开始到文件尾的所有数据，以16进制数复制到新建的文件中。</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/11/enzkJP9V8q7K3i5.png" alt="image-20200611215154084"></p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/11/18LJvrK2Psy9Wpt.png" alt="image-20200611215317247"></p><p>然后保存就能得到zip文件。</p><hr><h4 id="二、基于文件结构的图片隐写"><a href="#二、基于文件结构的图片隐写" class="headerlink" title="二、基于文件结构的图片隐写"></a>二、基于文件结构的图片隐写</h4><h5 id="背景知识："><a href="#背景知识：" class="headerlink" title="背景知识："></a>背景知识：</h5><p>这里的文件结构特指的是图片文件的文件结构。我们这里主要讲的也是PNG图片的文件结构。CTF比赛中也是以PNG图片的隐写为主。</p><p>PNG文件结构很简单，主要由数据块组成，最少包含4个数据块。</p><p>PNG数据块PNG图片有两种数据块的，一种是关键数据块，另一种是辅助数据块。</p><p>正常的关键数据块，定义了4种标准数据块，分别是<font color=red>长度，数据块类型码，数据块数据，循环冗余检测(CRC )</font>font&gt;，每个PNG文件都必须包含它们。</p><table><thead><tr><th>PNG标识符</th><th>PNG文件头数据块（IHDR）</th><th>PNG数据块</th><th>…</th><th align="left">PNG结尾数据块(IEND)</th></tr></thead><tbody><tr><td>89504E470D0A1A0A</td><td>IHDR中，包括了图片的宽，高，图像深度，颜色类型，压缩方法等等。</td><td>IDAT 数据块、辅助数据块</td><td></td><td align="left">000000004945 4E44AE426082</td></tr></tbody></table><ul><li>PNG标识符<code>89504E470D0A1A0A</code>总是在文件头部，用于标识这是一个PNG图片。</li><li>PNG文件头数据块IHDR，它包含有PNG文件中存储的图像数据的基本信息，并要作为第一个数据块出现在PNG数据流中，而且一个PNG数据流中只能有一个文件头数据块。</li><li>PNG数据块IDAT，它存储实际的数据，在数据流中可包含多个连续顺序的图像数据块。</li><li>PNG结束数据块IEND：它用来标记PNG文件或者数据流已经结束，并且必须要放在文件的尾部。</li></ul><p><strong>IHDR数据块构成：</strong></p><table><thead><tr><th><strong>域的名称</strong></th><th><strong>字节数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>Width</td><td>4 bytes</td><td>图像宽度，以像素为单位</td></tr><tr><td>Height</td><td>4 bytes</td><td>图像高度，以像素为单位</td></tr><tr><td>Bit depth</td><td>1 byte</td><td>图像深度：  索引彩色图像：1，2，4或8  灰度图像：1，2，4，8或16  真彩色图像：8或16</td></tr><tr><td>ColorType</td><td>1 byte</td><td>颜色类型： 0：灰度图像, 1，2，4，8或16  2：真彩色图像，8或16  3：索引彩色图像，1，2，4或8  4：带α通道数据的灰度图像，8或16  6：带α通道数据的真彩色图像，8或16</td></tr><tr><td>Compression method</td><td>1 byte</td><td>压缩方法(LZ77派生算法)</td></tr><tr><td>Filter method</td><td>1 byte</td><td>滤波器方法</td></tr><tr><td>Interlace method</td><td>1 byte</td><td>隔行扫描方法： 0：非隔行扫描  1： Adam7(由Adam M. Costello开发的7遍隔行扫描方法)</td></tr></tbody></table><p>这里我们需要重点关注的是宽和高的数据</p><p><strong>首先举个例子：</strong></p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/11/f2m5RXLUjCukob7.png" alt="image-20200611223017816"></p><p><strong>PNG标识符：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">89504E470D0A1A0A</span><br></pre></td></tr></table></figure><p>表示这是一个PNG文件</p><p><strong>接下来是IHDR数据块</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00 00 00 0D</span><br><span class="line">&#x2F;&#x2F;表示IHDR头快长度为13(16进制编辑器，D表示13)</span><br><span class="line">49 48 44 52</span><br><span class="line">&#x2F;&#x2F;IHDR标识，表示这是一个IHDR数据块</span><br><span class="line">00 00 03 E8 </span><br><span class="line">&#x2F;&#x2F;表示PNG图像的宽，16^2*3+16^1*14+16^0*8&#x3D;1000像素</span><br><span class="line">00 00 02 32 </span><br><span class="line">&#x2F;&#x2F;表示PNG图像的高，16^2*2+16^1*3+16^0*2&#x3D;562像素</span><br><span class="line">08 </span><br><span class="line">&#x2F;&#x2F;表示图像深度，这里是2^8&#x3D;256，即这是一个256色的图像</span><br><span class="line">06 </span><br><span class="line">&#x2F;&#x2F;颜色类型，查表可知这是带α通道数据的真彩色图像</span><br><span class="line">00</span><br><span class="line">&#x2F;&#x2F;压缩方法</span><br><span class="line">00 </span><br><span class="line">&#x2F;&#x2F;PNG Spec规定此处总为0（非0值为将来使用更好的压缩方法预留），表示使压缩方法（LZ77派生 算法）</span><br><span class="line">00</span><br><span class="line">&#x2F;&#x2F;滤波器方法</span><br><span class="line">58 71 E0 19</span><br><span class="line">&#x2F;&#x2F;CRC校验</span><br></pre></td></tr></table></figure><p>接下来的是不重要的数据块，我们只需要知道知道再之后就会有IDAT数据块</p><p><strong>IDAT数据块</strong></p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/11/szkZJOCmnRvrhfH.png" alt="image-20200611230506506"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00 00 00 8A</span><br><span class="line">&#x2F;&#x2F;表示IDAT数据块的长度为8A&#x3D;16^1*8+16^0*10&#x3D;138字节</span><br><span class="line">49 44 41 54</span><br><span class="line">&#x2F;&#x2F;IDAT数据块标识符,表示这是一个IDAT数据块</span><br><span class="line">接下去的数据是真正的数据</span><br><span class="line">D9 CF A5 A8 </span><br><span class="line">&#x2F;&#x2F;CRC校验码</span><br></pre></td></tr></table></figure><h5 id="常用工具："><a href="#常用工具：" class="headerlink" title="常用工具："></a>常用工具：</h5><ul><li>winhex</li><li>010Editor</li><li>pngcheck</li><li>binwalk</li></ul><p><strong>基于文件结构的图片隐写分类：</strong></p><ul><li>高度被修改引起的隐写</li><li>隐写信息以IDAT块加入图片</li></ul><h5 id="A-高度被修改引起的隐写"><a href="#A-高度被修改引起的隐写" class="headerlink" title="A.高度被修改引起的隐写"></a>A.高度被修改引起的隐写</h5><p>背景知识中，我们了解到，图片的高度，宽度的值存放于PNG图片的IHDR数据块，那么我们就是可以通过修改PNG图片的高度值，来对部分信息进行隐藏的。</p><p><strong>解法：</strong></p><p>使用winhex或010Editor等16进制编辑器修改图片高度，调大一点</p><p><strong>技巧：</strong></p><p>一般的高度修改的图片不会修改IHDR的CRC校验码，在windows下，不会检查CRC校验码，图片能正常显示，但在Linux下，图片查看器会检查图片的CRC校验码，所以可以将图片拖入到Linux中去查看校验</p><p>当然可能会把CRC校验码也重新计算过，就不能用这种方法了。</p><p>这里介绍一款工具，能计算CRC校验码：</p><p><strong>CRC Calculator</strong></p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/12/ANukZKTzxjcHeYX.png" alt="image-20200612133558161"></p><p><strong>实验：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 双击打开图片，我们先确认一下图片内容并没有什么异常</span><br><span class="line">- 正如前文所说，我们这个实验部分讲的是图片高度值被修改引起的的隐写方式，所以我们winhex</span><br><span class="line">- 在winhex运行PNG图片，这样方便于我们修改PNG图片的高度值</span><br><span class="line">- 找到PNG图片高度值对应的地方，然后修改为一个较大的值，并保存文件</span><br><span class="line">- 打开保存后的图片，发现底部看到了之前被隐写的信息</span><br></pre></td></tr></table></figure><p>原图：<img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200612132510439.png" alt="image-20200612132510439"></p><p>修改高度</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200612132547621.png" alt="image-20200612132547621"></p><p>修改为</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00 00 02 FF</span><br></pre></td></tr></table></figure><p>得到flag：</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200612132759250.png" alt="image-20200612132759250"></p><p><strong>思考：</strong></p><ol><li>如果修改的是宽度该怎么修复呢？                  ————————–通过爆破未被修改的CRC校验码得到原始宽度</li><li>JPG图片是否也有这样的隐写形式呢？</li><li>了解JPG以及GIF等图片文件的格式。</li></ol><h5 id="B-隐写信息以IDAT块加入图片"><a href="#B-隐写信息以IDAT块加入图片" class="headerlink" title="B.隐写信息以IDAT块加入图片"></a>B.隐写信息以IDAT块加入图片</h5><p>在背景知识中，我们提到了一个重要的概念就是图片的IDAT块是可以存在多个的，这导致了我们可以将隐写信息以IDAT块的形式加入图片。</p><p>这里再次提一下IDAT数据块的格式：</p><table><thead><tr><th align="left">IDAT数据块长度</th><th align="left">IDAT数据块标识</th><th align="left">IDAT数据</th><th align="left">CRC校验码</th></tr></thead><tbody><tr><td align="left">00 00 00 B3</td><td align="left">49 44 41 54</td><td align="left">50 4B …….00 00</td><td align="left">24 9B 7C 31</td></tr></tbody></table><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200612135623777.png" alt="image-20200612135623777"></p><p><strong>解法：</strong></p><p>首先可以通过<code>pngcheck</code>检测是否有异常的数据块，一般的IDAT数据块都是连续的数据块。</p><p>然后查看偏移量找到数据块的位置，提取IDAT数据块进行分析</p><p><strong>实验：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 双击打开图片，我们先确认一下图片内容并没有什么异常</span><br><span class="line">- 使用pngcheck先对图片检测</span><br><span class="line">- 在pngcheck的检测下，我们会发现异常信息，我们对异常的块进行提取</span><br><span class="line">- 查看数据块偏移量，找到IDAT数据块</span><br><span class="line">- 提取数据块</span><br><span class="line">- 分析数据块</span><br></pre></td></tr></table></figure><p><strong>前景知识</strong><br>pngcheck可以验证PNG图片的完整性（通过检查内部CRC-32校验和&bra;比特&ket;)和解压缩图像数据；它能够转储几乎所有任选的块级别信息在该图像中的可读数据。<br>我们使用<code>pngcheck -v xxx.png</code>如此的命令对图片进行检测</p><p><strong>使用pngcheck对图片进行检测</strong></p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/12/3HJW2Zj9ScwreLn.png" alt="image-20200612141052876"></p><p>可以发现原本连续的数据块都是32768的大小，然后15871，然后后面还有一个179大小的数据块，说明这个数据块有异常。</p><p><strong>提取数据块</strong></p><p>将数据块内容复制粘贴到新的文件中</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/12/GJOfTlxgCrLqt6V.png" alt="image-20200612141345571"></p><p><strong>分析数据块：</strong></p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/12/A5eu2Hsc7n3NwEg.png" alt="image-20200612141439513"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">50 4B 03 04</span><br></pre></td></tr></table></figure><p>说明这是一个ZIP压缩包，改后缀名得到zip文件</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/12/ZEBcTWJiazyG9qV.png" alt="image-20200612141914384"></p><p>发现提示需要密码，由于题目没有更多信息提示，所以先检查ZIP文件格式，查看压缩包是否是伪加密</p><p>提示：伪加密的压缩包可以用360压缩打开，也可以修复压缩包的方法打开或者修改数据；</p><p>伪加密是通过将第二个14后面的00 00 修改为14 00 09实现，只要将09修改成00就能破解，具体原理可以搜索zip伪加密实现</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200612143639110.png" alt="image-20200612143639110"></p><p><em>思考</em></p><ol><li>我们是否可以将一张二维码以IDAT块的形式写入图片呢？</li><li>试着自己将信息以IDAT块的形式写入图片—————–需要添加长度和CRC校验</li></ol><hr><h4 id="三、基于LSB原理的图片隐写"><a href="#三、基于LSB原理的图片隐写" class="headerlink" title="三、基于LSB原理的图片隐写"></a>三、基于LSB原理的图片隐写</h4><h5 id="背景知识-1"><a href="#背景知识-1" class="headerlink" title="背景知识"></a>背景知识</h5><p>网络上有很多博文抄来抄去也写的不清楚，然后我也找了很久才搞懂。</p><p>LSB，最低有效位。我们知道图像像素一般是由RGB三原色（即红绿蓝）组成的，每一种颜色占用8位，0x00~0xFF，即一共有256种颜色，一共包含了256的3次方的颜色，颜色太多，而人的肉眼能区分的只有其中一小部分，这导致了当我们修改RGB颜色分量中最低的二进制位的时候，我们的肉眼是区分不出来的</p><p>三原色，每种颜色占8位</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 0   0   0   0   |   0   0   0   0</span><br><span class="line">2^7      ...........        2^1 2^0</span><br><span class="line">&#x2F;&#x2F;一原色就一共有2^8&#x3D;256种颜色，三原色就是256^3种颜色</span><br><span class="line">当我们修改每种颜色的最低位二进制位2^0时，我们的肉眼区分不出来，所以就可以通过修改最低位达到隐写数据的目的</span><br></pre></td></tr></table></figure><p><strong>出题思路：</strong></p><ul><li>可以通过对某一颜色的某一个二进制位进行存储0或1 ，存储成这一通道(即二进制位)的黑白图片</li><li>可以在三个颜色通道的最低有效位存储0或1数据，存入图片数据或者其他数据</li></ul><h5 id="常用工具：-1"><a href="#常用工具：-1" class="headerlink" title="常用工具："></a>常用工具：</h5><ul><li>Stegosolve</li></ul><p><strong>Stegosolve介绍</strong><br>CTF中，最常用来检测LSB隐写痕迹的工具是Stegsolve，这是一款可以对图片进行多种操作的工具，包括对图片进行xor,sub等操作，对图片不同通道进行查看等功能。</p><p><strong>基于LSB原理的图片隐写</strong></p><ul><li>简单的LSB隐写</li><li>有一点难度的LSB隐写</li></ul><h5 id="A-简单的LSB隐写"><a href="#A-简单的LSB隐写" class="headerlink" title="A.简单的LSB隐写"></a>A.简单的LSB隐写</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 双击打开图片，我们先确认一下图片内容并没有什么异常</span><br><span class="line">- 使用Stegsolve打开图片，在不同的通道查看图片</span><br><span class="line">- 在通道切换的过程中，我们看到了flag</span><br><span class="line">- 最后的flag是flag:key&#123;forensics_is_fun&#125;</span><br></pre></td></tr></table></figure><p>用Stegsolve打开图片，并在不同的通道中切换</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200612150014122.png" alt="image-20200612150014122"></p><p>最后在发现Red的2^0位上隐写了数据</p><p>flag是flag:key{forensics_is_fun}</p><p><strong>思考</strong></p><ol><li>我们如何实现这种LSB隐写的？是否可以通过photoshop这样的工具实现？</li><li>查阅更多关于LSB隐写的资料。</li></ol><h5 id="B-有一点难度的LSB隐写"><a href="#B-有一点难度的LSB隐写" class="headerlink" title="B.有一点难度的LSB隐写"></a>B.有一点难度的LSB隐写</h5><p>我们从第一个部分可以知道，最简单的隐写我们只需要通过工具Stegsolve切换到不同通道，我们就可以直接看到隐写内容了，那么更复杂一点就不是这么直接了，而是只能用工具来查看LSB的隐写痕迹，再通过工具或者脚本的方式提取隐写信息。</p><p>可以通过Stegsolve来查看最低有效位数据：</p><p>也可以进行导出</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Analyse中的Data Extract模块</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/12/k9tZ23uTpOe8Qma.png" alt="image-20200612154608945"></p><p><strong>python脚本实现最低有效位隐藏算法：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line">from PIL import Image</span><br><span class="line">def plus(str):</span><br><span class="line">      #Python zfill() 方法返回指定长度的字符串，原字符串右对齐，前面填充0。</span><br><span class="line">    return str.zfill(8) </span><br><span class="line">def get_key(strr):</span><br><span class="line">      #获取要隐藏的文件内容</span><br><span class="line">    tmp &#x3D; strr</span><br><span class="line">    f &#x3D; file(tmp,&quot;rb&quot;)</span><br><span class="line">    str &#x3D; &quot;&quot;</span><br><span class="line">    s &#x3D; f.read()</span><br><span class="line">    for i in range(len(s)):</span><br><span class="line">         #逐个字节将要隐藏的文件内容转换为二进制，并拼接起来</span><br><span class="line">         #1.先用ord()函数将s的内容逐个转换为ascii码</span><br><span class="line">         #2.使用bin()函数将十进制的ascii码转换为二进制</span><br><span class="line">         #3.由于bin()函数转换二进制后，二进制字符串的前面会有&quot;0b&quot;来表示这个字符串是二进制形式，所以用replace()替换为空</span><br><span class="line">         #4.又由于ascii码转换二进制后是七位，而正常情况下每个字符由8位二进制组成，所以使用自定义函数plus将其填充为8位</span><br><span class="line">        str &#x3D; str+plus(bin(ord(s[i])).replace(&#39;0b&#39;,&#39;&#39;))</span><br><span class="line">        #print str</span><br><span class="line">    f.closed</span><br><span class="line">    return str</span><br><span class="line">def mod(x,y):</span><br><span class="line">    return x%y;</span><br><span class="line">#str1为载体图片路径，str2为隐写文件，str3为加密图片保存的路径</span><br><span class="line">def func(str1,str2,str3):  </span><br><span class="line">    im &#x3D; Image.open(str1)</span><br><span class="line">    #获取图片的宽和高</span><br><span class="line">    width &#x3D; im.size[0]</span><br><span class="line">    print &quot;width:&quot;+str(width)+&quot;\n&quot;</span><br><span class="line">    height &#x3D; im.size[1]</span><br><span class="line">    print &quot;height:&quot;+str(height)+&quot;\n&quot;</span><br><span class="line">    count &#x3D; 0</span><br><span class="line">    #获取需要隐藏的信息</span><br><span class="line">    key &#x3D; get_key(str2)</span><br><span class="line">    keylen &#x3D; len(key)</span><br><span class="line">    for h in range(0,height):</span><br><span class="line">        for w in range(0,width):</span><br><span class="line">            pixel &#x3D; im.getpixel((w,h))</span><br><span class="line">            a&#x3D;pixel[0]</span><br><span class="line">            b&#x3D;pixel[1]</span><br><span class="line">            c&#x3D;pixel[2]</span><br><span class="line">            if count &#x3D;&#x3D; keylen:</span><br><span class="line">                break</span><br><span class="line">            #下面的操作是将信息隐藏进去</span><br><span class="line">            #分别将每个像素点的RGB值余2，这样可以去掉最低位的值</span><br><span class="line">            #再从需要隐藏的信息中取出一位，转换为整型</span><br><span class="line">            #两值相加，就把信息隐藏起来了</span><br><span class="line">            a&#x3D; a-mod(a,2)+int(key[count])</span><br><span class="line">            count+&#x3D;1</span><br><span class="line">            if count &#x3D;&#x3D; keylen:</span><br><span class="line">                im.putpixel((w,h),(a,b,c))</span><br><span class="line">                break</span><br><span class="line">            b &#x3D;b-mod(b,2)+int(key[count])</span><br><span class="line">            count+&#x3D;1</span><br><span class="line">            if count &#x3D;&#x3D; keylen:</span><br><span class="line">                im.putpixel((w,h),(a,b,c))</span><br><span class="line">                break</span><br><span class="line">            c&#x3D; c-mod(c,2)+int(key[count])</span><br><span class="line">            count+&#x3D;1</span><br><span class="line">            if count &#x3D;&#x3D; keylen:</span><br><span class="line">                im.putpixel((w,h),(a,b,c))</span><br><span class="line">                break</span><br><span class="line">            if count % 3 &#x3D;&#x3D; 0:</span><br><span class="line">                im.putpixel((w,h),(a,b,c))</span><br><span class="line">    im.save(str3)</span><br><span class="line">#原图</span><br><span class="line">old &#x3D; &quot;C:\Users\yiming\Desktop\heetian.png&quot;</span><br><span class="line">#处理后输出的图片路径</span><br><span class="line">new &#x3D; &quot;C:\Users\yiming\Desktop\heetian_LSB.png&quot;</span><br><span class="line">#需要隐藏的信息</span><br><span class="line">enc &#x3D; &quot;C:\Users\yiming\Desktop\flag.txt&quot;</span><br><span class="line">func(old,enc,new)</span><br></pre></td></tr></table></figure><p><strong>python最低有效位提取脚本</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding:UTF-8 -*-</span><br><span class="line">from PIL import Image</span><br><span class="line">def mod(x,y):</span><br><span class="line">    return x%y;</span><br><span class="line">def toasc(strr):</span><br><span class="line">    return int(strr, 2)</span><br><span class="line">#le为所要提取的信息的长度，str1为加密载体图片的路径，str2为提取文件的保存路径</span><br><span class="line">def func(le,str1,str2):</span><br><span class="line">    a&#x3D;&quot;&quot;</span><br><span class="line">    b&#x3D;&quot;&quot;</span><br><span class="line">    im &#x3D; Image.open(str1)</span><br><span class="line">    lenth &#x3D; le*8</span><br><span class="line">    width &#x3D; im.size[0]</span><br><span class="line">    height &#x3D; im.size[1]</span><br><span class="line">    count &#x3D; 0</span><br><span class="line">    for h in range(0, height):</span><br><span class="line">        for w in range(0, width):</span><br><span class="line">             #获得(w,h)点像素的值</span><br><span class="line">            pixel &#x3D; im.getpixel((w, h))</span><br><span class="line">            #此处余3，依次从R、G、B三个颜色通道获得最低位的隐藏信息</span><br><span class="line">            if count%3&#x3D;&#x3D;0:</span><br><span class="line">                count+&#x3D;1</span><br><span class="line">                b&#x3D;b+str((mod(int(pixel[0]),2)))</span><br><span class="line">                if count &#x3D;&#x3D;lenth:</span><br><span class="line">                    break</span><br><span class="line">            if count%3&#x3D;&#x3D;1:</span><br><span class="line">                count+&#x3D;1</span><br><span class="line">                b&#x3D;b+str((mod(int(pixel[1]),2)))</span><br><span class="line">                if count &#x3D;&#x3D;lenth:</span><br><span class="line">                    break</span><br><span class="line">            if count%3&#x3D;&#x3D;2:</span><br><span class="line">                count+&#x3D;1</span><br><span class="line">                b&#x3D;b+str((mod(int(pixel[2]),2)))</span><br><span class="line">                if count &#x3D;&#x3D;lenth:</span><br><span class="line">                    break</span><br><span class="line">        if count &#x3D;&#x3D; lenth:</span><br><span class="line">            break</span><br><span class="line">    with open(str2,&quot;wb&quot;) as f:</span><br><span class="line">        for i in range(0,len(b),8):</span><br><span class="line">             #以每8位为一组二进制，转换为十进制</span><br><span class="line">            stra &#x3D; toasc(b[i:i+8])</span><br><span class="line">            #将转换后的十进制数视为ascii码，再转换为字符串写入到文件中</span><br><span class="line">            f.write(chr(stra))</span><br><span class="line">            stra &#x3D;&quot;&quot;</span><br><span class="line">    f.closed</span><br><span class="line">#文件长度</span><br><span class="line">le &#x3D; 30</span><br><span class="line">#含有隐藏信息的图片</span><br><span class="line">new &#x3D; &quot;C:\Users\lenovo\Desktop\LSB\demo2\heetian_LSB.png&quot;</span><br><span class="line">#信息提取出后所存放的文件</span><br><span class="line">tiqu &#x3D; &quot;C:\Users\lenovo\Desktop\LSB\demo2\get_flag.txt&quot;</span><br><span class="line">func(le,new,tiqu)</span><br></pre></td></tr></table></figure><p>可以在图片中隐藏字符串，也可以在图片中隐藏图片</p><p><strong>实验：</strong></p><p><strong>思考</strong></p><ol><li>我们这里用的LSB隐均对R,G,B，三种颜色都加以修改是否可以只修改一个颜色？</li><li>参考2016 HCTF的官方Writeup学习如何实现将一个文件以LSB的形式加以隐写。</li></ol><hr><h4 id="四、基于DCT域的JPG图片隐写"><a href="#四、基于DCT域的JPG图片隐写" class="headerlink" title="四、基于DCT域的JPG图片隐写"></a>四、基于DCT域的JPG图片隐写</h4><p>这个基于DCT域的JPG图片隐写原理太难，没必要搞懂原理，知道有哪几个类型的题目和解法就行。</p><h5 id="背景知识-2"><a href="#背景知识-2" class="headerlink" title="背景知识"></a>背景知识</h5><p>JPEG图像格式使用离散余弦变换（Discrete Cosine Transform，DCT）函数来压缩图像，而这个图像压缩方法的核心是：通过识别每个8×8像素块中相邻像素中的重复像素来减少显示图像所需的位数，并使用近似估算法降低其冗余度。因此，我们可以把DCT看作一个用于执行压缩的近似计算方法。因为丢失了部分数据，所以DCT是一种有损压缩（Loss Compression）技术，但一般不会影响图像的视觉效果。</p><p><strong>基于DCT域的JPG图片隐写分类：</strong></p><ul><li>JPHide</li><li>JSteg</li><li>Outguess</li><li>F5等</li></ul><h5 id="常用工具：-2"><a href="#常用工具：-2" class="headerlink" title="常用工具："></a>常用工具：</h5><ul><li>Stegdetect</li><li>JPHS</li><li>Jsteg</li><li>Outguess</li></ul><h5 id="A-JPhide隐写—jpg隐写"><a href="#A-JPhide隐写—jpg隐写" class="headerlink" title="A.JPhide隐写—jpg隐写"></a>A.JPhide隐写—jpg隐写</h5><p><strong>隐写原理</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Jphide是基于最低有效位LSB的JPEG格式图像隐写算法，使用JPEG图像作为载体是因为相比其他图像格式更不容易发现隐藏信息，因为JPEG图像在DCT变换域上进行隐藏比空间域隐藏更难检测，并且鲁棒性更强，同时Blowfish算法有较强的抗统计检测能力。</span><br><span class="line">由于JPEG图像格式使用离散余弦变换（Discrete Cosine Transform，DCT）函数来压缩图像，而这个图像压缩方法的核心是：通过识别每个8×8像素块中相邻像素中的重复像素来减少显示图像所需的位数，并使用近似估算法降低其冗余度。因此，我们可以把DCT看作一个用于执行压缩的近似计算方法。因为丢失了部分数据，所以DCT是一种有损压缩（Loss Compression）技术，但一般不会影响图像的视觉效果。</span><br></pre></td></tr></table></figure><p><strong>隐写过程</strong></p><p>JPhide隐写过程大致为：</p><ul><li>先解压压缩JPEG图像，得到DCT系数；</li><li>然后对隐藏信息用户给定的密码进行Blowfish加密；</li><li>再利用Blowfish算法生成伪随机序列，并据此找到需要改变的DCT系数，将其末位变为需要隐藏的信息的值。最后把DCT系数重新压回成JPEG图片；</li></ul><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/12/c8BWkE1KjvA76Pu.png" alt="img"></p><p><strong>隐写实现</strong></p><p>1.Stegdetect<br>实现JPEG图像JPhide隐写算法工具有多个，比如由Neils Provos开发通过统计分析技术评估JPEG文件的DCT频率系数的隐写工具 Stegdetect，它可以检测到通过<font color=red>JSteg、JPHide、OutGuess、Invisible Secrets、F5、appendX和Camouflage</font>等这些隐写工具隐藏的信息，并且还具有基于字典暴力破解密码方法提取通过JPhide、outguess和jsteg-shell方式嵌入的隐藏信息。<br>2.JPHS<br>另一款JPEG图像的信息隐藏软件JPHS，它是由Allan Latham开发设计实现在Windows和Linux系统平台针对有损压缩JPEG文件进行信息加密隐藏和探测提取的工具。软件里面主要包含了两个程序JPHIDE和JPSEEK， JPHIDE程序主要是实现将信息文件加密隐藏到JPEG图像功能，而JPSEEK程序主要实现从用JPHIDE程序加密隐藏得到的JPEG图像探测提取信息文件，Windows版本的JPHS里的JPHSWIN程序具有图形化操作界面且具备JPHIDE和JPSEEK的功能。</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/12/HDcyNhuowI7dSJF.png" alt="img"></p><p>2.分别准备一个JPEG格式的图片（example.jpg）和一个文本文件（flag.txt）。</p><p>由于JPEG文件使用的数据存储方式有多种不能一一演示，这里用最常用的JPEG格式-JPEG文件交换格式（JPEG File Interchange Format，JFIF）作为示例。<br>这里简单介绍JPEG文件交换格式的JPEG图片的图像开始标记SOI（Start of Image）和应用程序保留标记APP0（Application 0），JPEG文件交换格式的JPEG图片开始前2个字节是图像开始标记为0xFFD8，之后2个字节接着便是应用程序保留标记为0xFFE0，应用程序保留标记APP0包含9个具体字段，这里介绍前三个字段，第一个字段是数据长度占2个字节，表示包括本字段但不包括标记代码的总长度，这里为10个字节，第二个字段是标识符占5个字节0x4A46494600表示“JFIF0”字符串，第三个字段是版本号占2个字节，这里是0X0101，表示JFIF的版本号为1.1，但也可能为其它数值，从而代表了其它版本号。</p><p>分别准备一个JPEG格式的图片（111.jpg）和一个文本文件（flag.txt）。</p><p>由于JPEG文件使用的数据存储方式有多种不能一一演示，这里用最常用的JPEG格式-JPEG文件交换格式（JPEG File Interchange Format，JFIF）作为示例。</p><p>由于JPEG文件使用的数据存储方式有多种不能一一演示，这里用最常用的JPEG格式-JPEG文件交换格式（JPEG File Interchange Format，JFIF）作为示例。</p><p>JPEG是一种压缩标准，有很多种采用不同文件交换格式的JPG图片。</p><p>这里简单介绍JPEG文件交换格式的JPEG图片的图像开始标记SOI（Start of Image）和应用程序保留标记APP0（Application 0）</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/12/kHMz9CrNKIw4TQ7.png" alt="image-20200612192533248"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FF D8</span><br><span class="line">&#x2F;&#x2F;JPEG文件交换格式的JPEG图片开始前2个字节是图像开始标记 FF D8</span><br><span class="line">FF E0 </span><br><span class="line">&#x2F;&#x2F;之后2个字节是应用程序保留标记 FF E0</span><br><span class="line">00 10</span><br><span class="line">&#x2F;&#x2F;应用程序保留标记APP0包含9个具体字段，这里介绍前三个字段，第一个字段是数据长度占2个字节 00 10,表示包括本字段但不包括标记代码的总长度</span><br><span class="line">4A 46 49 46 00</span><br><span class="line">&#x2F;&#x2F;第二个字段是标识符占5个字节0x4A46494600表示“JFIF0”字符串</span><br><span class="line">01 01</span><br><span class="line">&#x2F;&#x2F;第三个字段是版本号占2个字节，这里是01 01,表示JFIF的版本号为1.1,但也可能为其它数值，从而代表了其它版本号。</span><br></pre></td></tr></table></figure><p>1、Windows版本可以使用具有图形化操作界面的Jphswin，选择“Open jpeg”打开示例JPEG格式图片111.jpg</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/12/m7lZu4LbnGwiIyh.png" alt="image-20200612192920524"></p><p>如果你选择的不是JPEG格式的图片程序会自动退出，你可以16进制编辑器如Winhex查看图片的图像开始标记SOI和应用程序保留标记APP0，当载入JPEG格式图片会显示一些图片的属性。</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/12/WOxzBF587jDyETb.png" alt="image-20200612192943561"></p><p>2、选择“Hide”选项之后在两次文本框输入相同的密码，这里以输入flag作为密码为例，然后输入要包含隐藏信息的文本。</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/12/q2N3cvbLlBWPXSC.png" alt="image-20200612193040489"></p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/12/2M61E7UwXqFeyza.png" alt="image-20200612193059255"></p><p>3、选择“Save jpeg as”选项将图片另存为jpeg格式并输入文件的名称为新的图像文件如123.jpg</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/12/ZsJfSWBc6DjxXRK.png" alt="image-20200612193157903"></p><p>4.之后便可以看到生成结果和相关信息，JPhide隐写生成过程就完成了</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/12/lgq4HpYXxynvw35.png" alt="image-20200612193225396"></p><p><strong>解法：</strong></p><p>当我们拿到一道JPG图片隐写的题时，可以先用Stegdetect检测是以哪种隐写方式加密的。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Stegdetect的主要选项如下：</span><br><span class="line"></span><br><span class="line">-q 仅显示可能包含隐藏内容的图像。 </span><br><span class="line"></span><br><span class="line">-n 启用检查JPEG文件头功能，以降低误报率。如果启用，所有带有批注区域的文件将被视为没有被嵌入信息。如果JPEG文件的JFIF标识符中的版本号不是1.1，则禁用OutGuess检测。 </span><br><span class="line"></span><br><span class="line">-s 修改检测算法的敏感度，该值的默认值为1。检测结果的匹配度与检测算法的敏感度成正比，算法敏感度的值越大，检测出的可疑文件包含敏感信息的可能性越大。</span><br><span class="line"></span><br><span class="line">-d 打印带行号的调试信息。 </span><br><span class="line"></span><br><span class="line">-t 设置要检测哪些隐写工具（默认检测jopi），可设置的选项如下： </span><br><span class="line">j 检测图像中的信息是否是用jsteg嵌入的。 </span><br><span class="line">o 检测图像中的信息是否是用outguess嵌入的。 </span><br><span class="line">p 检测图像中的信息是否是用jphide嵌入的。 </span><br><span class="line">i 检测图像中的信息是否是用invisible secrets嵌入的。 </span><br><span class="line">-V 显示软件版本号。</span><br></pre></td></tr></table></figure><p>1.将图片复制到stegdetect.exe所在目录下，右键PowerShell命令<code>stegdetect.exe -tjopi -s 10.0 hide.jpg</code>检测该图片用的是哪种加密方式</p><p>2.然而我们并不知道密码是啥，这时可以用stegdetect下的stegbreak字典破解，同样图片和stegbreak.exe在同一目录下，命令<code>stegbreak.exe -r rules.ini -f password.txt -r p hide.jpg</code>破解密码</p><p>3.使用jphide下的工具JPHS从hide.jpg图片提取出隐藏信息</p><p><strong>实验：</strong></p><p>首先，在cmd/powershell中运行<code>Stegdetect</code>，对目标图片进行检测</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200613125042445.png" alt="image-20200613125042445"></p><p>发现结果显示是jphide隐写的可能性很大。<br><strong>接着，我们使用工具JPHS提取信息</strong></p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/13/JeDPrQ3MKizxBN1.png" alt="image-20200613125242778"></p><p>然后打开保存的txt文件，即得flag</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/13/hC1VbJczpwg6T93.png" alt="image-20200613125410159"></p><p>得到flag</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/13/8kDlNi4aZ5WI7y3.png" alt="image-20200613125859949"></p><h5 id="B-JSteg隐写—jpg隐写"><a href="#B-JSteg隐写—jpg隐写" class="headerlink" title="B.JSteg隐写—jpg隐写"></a>B.JSteg隐写—jpg隐写</h5><p>隐写工具：jsteg</p><p>先用Stegdetect检测加密类型</p><p>再用jsteg解密</p><p>隐写写入：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jsteg-windows-amd64.exe hide 123.jpg flag.txt out.jpg</span><br></pre></td></tr></table></figure><p>解密隐写：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jsteg-windows-amd64.exe reveal out.jpg out.txt</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/13/bcx4o3Cw1yiFJzY.png" alt="image-20200613133121279"></p><h5 id="C-Outguess隐写—jpg隐写"><a href="#C-Outguess隐写—jpg隐写" class="headerlink" title="C.Outguess隐写—jpg隐写"></a>C.Outguess隐写—jpg隐写</h5><p>工具：Outguess工具</p><p><strong>解题步骤：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 双击打开图片，我们先确认一下图片内容并没有什么异常</span><br><span class="line">- 使用Stegdetect对图片的隐写方式进行检测</span><br><span class="line">- 从结果中得知是使用JPHide的隐写，使用JPHS工具对隐写信息进行提取</span><br><span class="line">- 最后打开保存的文件</span><br></pre></td></tr></table></figure><p><strong>第一步，在cmd中运行，Stegdetect，对目标图片进行检测</strong></p><p><strong>第二步，使用Outguess工具提取隐写信息</strong></p><p>点击Enter key功能，输入密码<br>点击Load image 加载目标图片<br>点击Extract file功能，将提取出来的信息保存成flag.txt文件。</p><p>打开flag.txt文件得到flag</p><p><strong>思考</strong></p><ol><li>尝试其他DCT域隐写，如F5</li><li>自己尝试使用JPHS的Hide功能，实现一个隐写。</li></ol><hr><h4 id="五、数字水印的隐写"><a href="#五、数字水印的隐写" class="headerlink" title="五、数字水印的隐写"></a>五、数字水印的隐写</h4><h5 id="背景知识-3"><a href="#背景知识-3" class="headerlink" title="背景知识"></a>背景知识</h5><p><strong>数字水印</strong><br>数字水印技术，是指在数字化的数据内容中嵌入不明显的记号。<br>特征是，被嵌入的记号通常是不可见或不可察的，但是可以通过计算操作检测或者提取。</p><p>盲水印，是指人感知不到的水印，包括看不到或听不见（没错，数字盲水印也能够用于音频）。其主要应用于音像作品、数字图书等，目的是，在不破坏原始作品的情况下，实现版权的防护与追踪。</p><p>添加数字盲水印的方法简单可分为<font color=red>空域方法</font>和<font color=red>频域方法</font>，这两种方法添加了冗余信息，但在编码和压缩情况不变的情况下，不会使原始图像大小产生变化（原来是10MB添加盲水印之后还是10MB）。</p><p>空域是指空间域，我们日常所见的图像就是空域。空域添加数字水印的方法是在空间域直接对图像操作（之所以说的这么绕，是因为不仅仅原图是空域，原图的差分等等也是空域），比如将水印直接叠加在图像上。</p><p>相对于空域方法，<font color=red>频域加盲水印</font>的方法隐匿性更强，抵抗攻击能力更强。这类算法解水印困难，你不知道水印加在那个频段，而且受到攻击往往会破坏图像原本内容</p><p>我们常说一个音有多高，这个音高是指频率；同样，图像灰度变化强烈的情况，也可以视为图像的频率。频域添加数字水印的方法，是指通过某种变换手段（傅里叶变换，离散余弦变换，小波变换等）将图像变换到频域（小波域），在频域对图像添加水印，再通过逆变换，将图像转换为空间域。相对于空域手段，频域手段隐匿性更强，抗攻击性更高。</p><p>所谓对水印的攻击，是指破坏水印，包括涂抹，剪切，放缩，旋转，压缩，加噪，滤波等。数字盲水印不仅仅要敏捷性高（不被人抓到），也要防御性强（抗打）。就像Dota的敏捷英雄往往是脆皮，数字盲水印的隐匿性和鲁棒性是互斥的。（鲁棒性是抗攻击性的学术名字）</p><h5 id="常用工具：-3"><a href="#常用工具：-3" class="headerlink" title="常用工具："></a>常用工具：</h5><p>BlindWaterMark</p><p>工具github地址：<a href="https://github.com/chishaxie/BlindWaterMark" target="_blank" rel="noopener">https://github.com/chishaxie/BlindWaterMark</a></p><p><strong>解法：</strong></p><p>盲水印一般会有两张图，一张图是原图，一张为添加了水印的</p><p>使用BlindWaterMark工具提取</p><p>合成盲水印图</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python bwm.py encode hui.png wm.png hui_with_wm.png</span><br></pre></td></tr></table></figure><p>提取图中的盲水印 (需要原图)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python bwm.py decode hui.png hui_with_wm.png wm_from_hui.png</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/13/8lSaKOjw4FDZpBY.png" alt="image-20200613151739239"></p><p>有想要深入了解的同学可以去看这篇文章：</p><p><a href="https://stgod.com/1482/" target="_blank" rel="noopener">https://stgod.com/1482/</a></p><p><strong>思考</strong></p><ol><li>请查阅关于空域盲水印的资料</li><li>试着对频域盲水印攻击，如截屏、倒转等操作，再进行提取水印，看看水印是否被破坏。</li></ol><hr><h4 id="六、图片容差的隐写"><a href="#六、图片容差的隐写" class="headerlink" title="六、图片容差的隐写"></a>六、图片容差的隐写</h4><h5 id="背景知识-4"><a href="#背景知识-4" class="headerlink" title="背景知识"></a>背景知识</h5><p><strong>容差</strong><br>容差，在选取颜色时所设置的选取范围，容差越大，选取的范围也越大，其数值是在0-255之间。</p><h5 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h5><p><strong>beyond compare</strong></p><p>beyond compare是一款很适合用来对图片进行比较的工具，就图片而言，它支持容差、范围、混合等模式。</p><p><strong>容差比较的隐写</strong></p><p>没有找到题所以就介绍一下解法</p><p><strong>解法：</strong></p><p>打开工具，选择图片比较，导入两张图片</p><p>选择容差大小，进行比较得到flag</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/13/mJTRLNEApdvIwYb.png" alt="image-20200613153005517"></p><p><strong>提示：</strong></p><p>如果在CTF赛场中，就隐写这一部分，出题人给于两张或者多张图片，一般都是需要对图片的内容进行比较的</p><hr><h3 id="多媒体文件隐写"><a href="#多媒体文件隐写" class="headerlink" title="多媒体文件隐写"></a>多媒体文件隐写</h3><p>音频、视频等多媒体也是我们生活经常看到的文件格式。我们上网听音乐，看视频，都离不开多媒体，一方面多媒体文件一般比单独的图片文件大，这是否也意味着能存储更多的信息，也可以隐藏更多的信息呢？</p><p>多媒体文件隐写分为：</p><ul><li>音频隐写</li><li>视频隐写</li></ul><hr><h4 id="一、音频隐写"><a href="#一、音频隐写" class="headerlink" title="一、音频隐写"></a>一、音频隐写</h4><p>音频隐写大致分为两大类：</p><ul><li>音轨插入摩尔斯电码</li><li>MP3stego隐写</li></ul><h4 id="常用工具：-4"><a href="#常用工具：-4" class="headerlink" title="常用工具："></a>常用工具：</h4><ul><li>Audacity</li><li>MP3stego</li></ul><h5 id="A-摩尔斯电码音频隐写"><a href="#A-摩尔斯电码音频隐写" class="headerlink" title="A.摩尔斯电码音频隐写"></a>A.摩尔斯电码音频隐写</h5><p><strong>背景知识</strong></p><p>摩尔斯电码（又译为摩斯密码，Morse code）是一种时通时断的信号代码，通过不同的排列顺序来表达不同的英文字母、数字和标点符号。在过去它以电报的形式来发送消息，如今当听到这样的电报你还能解出的他它的明文吗？</p><p><strong>摩尔斯电码对照表</strong></p><p><img src= "/img/loading.gif" data-src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/93/%E5%9B%BD%E9%99%85%E6%91%A9%E5%B0%94%E6%96%AF%E7%94%B5%E7%A0%81.svg/315px-%E5%9B%BD%E9%99%85%E6%91%A9%E5%B0%94%E6%96%AF%E7%94%B5%E7%A0%81.svg.png" alt="摩尔斯电码- 维基百科，自由的百科全书"></p><p><strong>实验：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 在实验机中找到隐写术目录，打多媒体隐写，进一步找到文件夹音频隐写的目录下找到莫尔斯电码.mp3 文件</span><br><span class="line">- 我们可以先双击点开，尝试听一下内容，我们会听到在影视中常常听见的电报的发文声</span><br><span class="line">- 由于，单靠听我们很难直接辨别出长短，毕竟我们不是专业的，我们可以尝试用Audacity打开文件</span><br><span class="line">- 短代表点，长代表横，对照电码表，翻译出flag</span><br><span class="line">- 翻译摩尔斯电码可以使用在线翻译网站</span><br></pre></td></tr></table></figure><p><strong>当我们确认是摩尔斯电报之后，我先用Audacity打开目标文件，并观察波形</strong></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200614093414910.png" alt="image-20200614093414910"></p><p><strong>以长的代表代表横线，短的代表点，大的间隔是空格，抄写下摩尔斯电码</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.. -.-. .... ..- -. --.- .. ..- -- --- .-. ... . - . ... -</span><br></pre></td></tr></table></figure><p>翻译得：</p><p>ICHUNQIUMORSETEST</p><p><strong>思考与实践</strong></p><ol><li>利用lakey这个软件给制作一个自己ID的摩尔斯电文吧。</li></ol><h5 id="B-MP3stego工具隐写"><a href="#B-MP3stego工具隐写" class="headerlink" title="B.MP3stego工具隐写"></a>B.MP3stego工具隐写</h5><p><strong>MP3stego介绍</strong></p><p>MP3stego是著名的音频数据隐写工具，支持常见的压缩音频文件格式如mp3的数据嵌入，它采用的是一种特殊的量化方法，并且将数据隐藏在MP3文件的奇偶校验块中。</p><p><strong>使用方法</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用MP3Stego进行加密解密：</span><br><span class="line">加密：encode -E 加密文本 -P 密码  wav文件 mp3文件</span><br><span class="line">解密：decode -X -P  密码  mp3文件</span><br></pre></td></tr></table></figure><p><strong>实验：</strong></p><p>小明想和小红告白，在一个首歌中藏了一个txt文件，可是小红却不知道怎么找到mp3文件中的隐藏信息，你能帮帮她吗？ hit： password： love</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 在实验机中找到隐写术目录，打多媒体隐写，进一步找到文件夹音频隐写的目录下找到love.mp3 文件</span><br><span class="line">- 我们可以先双击点开，尝试听一下内容，感觉是一个很正常的音乐</span><br><span class="line">- 因为有个提示，这里我们用到了密码加密，我们可以猜测是否是用mp3stego进行的隐写呢？</span><br><span class="line">- 在工具文件中找到mp3stego，将目标文件拷贝到工具的目录下</span><br><span class="line">- 尝试提取隐藏信息，最后的flag是flag&#123;I_love_you&#125;</span><br></pre></td></tr></table></figure><p><strong>首先先将目标文件复制到MP3stego这个工具的目录下</strong></p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/14/YcXyOzFIotKpkjU.png" alt="image-20200614100259368"></p><p><strong>在CMD下使用Decode.exe程序进行提取</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Decode.exe -X -P love love.mp3</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200614100932009.png" alt="image-20200614100932009"></p><p>最后打开目录下的love.mp3.txt文件就能看到隐写内容了</p><p><strong>思考与实践</strong></p><ol><li>最后小明表白成功了，你是否也可以尝试去做一个MP3隐写呢</li></ol><h5 id="C-频谱图音频隐写"><a href="#C-频谱图音频隐写" class="headerlink" title="C.频谱图音频隐写"></a>C.频谱图音频隐写</h5><p><strong>背景知识</strong></p><p>频谱是频率谱密度的简称，是频率的分布曲线。复杂振荡分解为振幅不同和频率不同的谐振荡，这些谐振荡的幅值按频率排列的图形叫做频谱。<br>在CTF中，我们可以单独只对一个声道中，隐写进信息</p><p><strong>实验</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 在实验机中找到隐写术目录，打多媒体隐写，进一步找到文件夹音频隐写的目录下找到这有点刺耳.wav的文件</span><br><span class="line">- 我们可以先双击点开，尝试听一下内容，感觉是一个很正常的音乐</span><br><span class="line">- 因为这次是针对频谱的，我们直接用Adobe Aud ton打开目标文件</span><br><span class="line">- 调整到频谱视图，调整大小，直到能清晰的看到隐写内容</span><br><span class="line">- 尝试提取隐藏信息，最后的flag是flag&#123;CTF_i5_rea1ly_funny!&#125;</span><br></pre></td></tr></table></figure><p><strong>直接进入正题吧</strong><br>使用AU打开目标文件</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200614103023624.png" alt="image-20200614103023624"></p><p>调整到频谱图，并调整频谱图大小，直到能看清flag</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200614104328986.png" alt="image-20200614104328986"></p><h5 id="D-波形音频隐写"><a href="#D-波形音频隐写" class="headerlink" title="D.波形音频隐写"></a>D.波形音频隐写</h5><p><strong>背景知识</strong></p><p>通常来说，波形方向的题，在观察到异常后，使用相关软件（Audacity, Adobe Audition 等）观察波形规律，将波形进一步转化为 01 字符串等，从而提取转化出最终的 flag。</p><p><strong>实验:</strong></p><p>ISCC-2017：杂项—-普通的DISCO我们普通的摇<del>~</del></p><p>（1）下载一个Disco.wav音频文件，不是以.mp3结尾。那么mp3stego这个工具是无法使用了。</p><p>（2）细心的童鞋会注意到，音频开头有一段杂音。然后用音频分析软件打开，这里我用audacity这款工具打开音频文件。如下图所示：</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/16/MFRdSpUiTo2cDBl.png" alt="image-20200616195625454"></p><p>这道题就是考个细心程度，当得到这个波形之后就很容易联想到二进制数据，这道题的话因为上下两个音轨是一样的，所以取上面这个，这里可以认为上面一小点是1，下面一小点是0，如下图：</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200616201440356.png" alt="image-20200616201440356"></p><p>就能得到：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">110011011011001100001110011111110111010111011000010101110101010110011011101011101110110111011110011111101</span><br></pre></td></tr></table></figure><p>然后得到之后首先观察数据，因为很短，所以推测不是文件，应该是处理字符编码得到flag。</p><p>首先这里一共是105位</p><p>不符合8位一个字符，符合7位，于是在每个7位之前加个0，得到</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">01100110,01101100,01100001,01100111,01111011,01010111,00110000</span><br><span class="line">01010111,00101010,01100110,01110101,01101110,01101110,01111001,</span><br><span class="line">01111101</span><br></pre></td></tr></table></figure><p>最后二进制转十进制，转ASCII得到：flag{W0W*funny}</p><p>好吧，这边编码的确恶心人。</p><h5 id="E-LSB音频隐写"><a href="#E-LSB音频隐写" class="headerlink" title="E.LSB音频隐写"></a>E.LSB音频隐写</h5><p><strong>背景知识</strong></p><p>类似于图片隐写中的 LSB 隐写，音频中也有对应的 LSB 隐写。主要可以使用Silenteye工具，其介绍如下：</p><p>SilentEye是一种跨平台应用程序设计，可轻松使用隐写术，在这种情况下，将消息隐藏为图片或声音。它提供了一个非常漂亮的界面，并通过使用插件系统轻松集成了新的密写算法和加密过程。</p><p><strong>实验：</strong></p><p>2015 广东省强网杯 - Little Apple</p><p>直接使用 <code>slienteye</code> 即可。</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200616203211716.png" alt="image-20200616203211716"></p><p>这道原题找不到了，但是这主要就是考的知识面，知道这个工具才能做出来</p><p><strong>思考与实践</strong></p><p>如何做一个音频隐写？</p><hr><h4 id="二、视频隐写"><a href="#二、视频隐写" class="headerlink" title="二、视频隐写"></a>二、视频隐写</h4><h5 id="A-基于文件结构的隐写"><a href="#A-基于文件结构的隐写" class="headerlink" title="A.基于文件结构的隐写"></a>A.基于文件结构的隐写</h5><p>目前在CTF赛事中较为常出现的视频隐写，一般都是将一场带有隐写信息的图片，嵌入视频中，我们所需要做的就是将这个图片从视频分离出来，然后在分析我们分离出来的文件是什么，之后的操作可能会涉及到密码编码，图片隐写等知识点。</p><p>另一方面，我们分离文件，如果单独对视频来说ffmpeg是一个很好的工具，这里我使用的是foremost ，一款linux下的命令行工具，当然我们也可以使用binwalk或者dd等工具，正如我们图片隐写中教大家分离图片所用的方法一样。<br>区别是，ffmpeg将视频分解成一张一张的图片，foremost是一个基于文件头和尾部信息以及文件的内建数据结构恢复文件的命令行工具。</p><p><strong>实验：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 在实验机中找到隐写术目录，打多媒体隐写，进一步找到文件夹视频隐写的目录下找到powpow.mp4的文件</span><br><span class="line">- 我们可以先双击点开，观看下这个视频文件</span><br><span class="line">- 分离图片，得到一张图片，对图片分析，由提示可知是steghide的图片隐写</span><br><span class="line">- 之后的操作我们就不复述了, 看一下操作。</span><br><span class="line">- flag&#123;We are fsociety, we are finally free, we are finally awake!&#125;</span><br></pre></td></tr></table></figure><p><strong>首先用foremost分离图片</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foremost powpow.mp4</span><br></pre></td></tr></table></figure><p><strong>在output目录下找到分离出来的图片</strong></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200614104703882.png" alt="image-20200614104703882"></p><p>使用命令 <code>steghide extract -sf thing.jpg -p password</code>提取图片隐写内容内容</p><p><strong>对提取出来的隐写内容进行解码</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat base64.txt</span><br><span class="line">python3</span><br><span class="line">&gt;&gt;&gt; import base64</span><br><span class="line">&gt;&gt;&gt; base64.b85decode(b&#39;W^7?+dsk&amp;3VRB_4W^-?2X&#x3D;QYIEFgDfAYpQ4AZBT9VQg%9AZBu9Wh@|fWgua4Wgup0ZeeU&#125;c_3kTVQXa&#125;eE&#39;)</span><br><span class="line">b&#39;flag&#123;We are fsociety, we are finally free, we are finally awake!&#125;&#39;</span><br></pre></td></tr></table></figure><p>最终的flag是<br>**完整操作命令flag{We are fsociety, we are finally free, we are finally awake!}</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foremost powpow.mp4</span><br><span class="line">stepic -i output&#x2F;png&#x2F;00001069.png -d &gt; thing</span><br><span class="line">steghide extract -sf thing.jpg -p password</span><br><span class="line">cat base64.txt</span><br><span class="line">python3</span><br><span class="line">&gt;&gt;&gt; import base64</span><br><span class="line">&gt;&gt;&gt; base64.b85decode(b&#39;W^7?+dsk&amp;3VRB_4W^-?2X&#x3D;QYIEFgDfAYpQ4AZBT9VQg%9AZBu9Wh@|fWgua4Wgup0ZeeU&#125;c_3kTVQXa&#125;eE&#39;)</span><br><span class="line">b&#39;flag&#123;We are fsociety, we are finally free, we are finally awake!&#125;&#39;</span><br></pre></td></tr></table></figure><h5 id="B-MSU-Stego隐写"><a href="#B-MSU-Stego隐写" class="headerlink" title="B.MSU Stego隐写"></a>B.MSU Stego隐写</h5><p>MSU StegoVideo 数据隐写</p><p>这个隐写也是考了知识面吧，题目较少</p><p><strong>解法：</strong></p><p>选中”Extract file from video”:</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/17/IN3oXFRn2YbCqLg.png" alt="image-20200617160830674"></p><p>选择带有隐藏信息的文件和一个空白的用于保存提取出来的信息的 .txt 文件：</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/17/cHfvkLS24CjPXr1.png" alt="image-20200617162437195"></p><p>输入密码：(这个密码是在生成的时候设置的，考题可能会在其他地方会有提示)</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/17/kOxgqWjHCso7r14.png" alt="image-20200617162556361"></p><p>正在进行信息提取操作：</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/17/vaMYhK3obJs62CU.png" alt="image-20200617162609599"></p><p>操作完成后，就会得到隐藏的信息。</p><p>隐藏的步骤可以自己去尝试</p><h5 id="C-TCStego隐写"><a href="#C-TCStego隐写" class="headerlink" title="C.TCStego隐写"></a>C.TCStego隐写</h5><p>和MSU Stego一样，主要是考了知识面</p><h3 id="电子文档隐写"><a href="#电子文档隐写" class="headerlink" title="电子文档隐写"></a>电子文档隐写</h3><p>电子文档，它主要包括电子文书、电子信件、电子报表、电子图纸、纸质文本文档的电子版本等等，是人们电脑办公中必不可少的文件。</p><h4 id="一、word隐写"><a href="#一、word隐写" class="headerlink" title="一、word隐写"></a>一、word隐写</h4><p>微软的Word一直是文字处理软件中的佼佼者。微软的Word、Excel、PowerPoint提供了许多在文档中隐藏数据的方法，包括批注、个人信息、水印、不可见内容、隐藏文字和定制的XML数据。最简单，也是最奇妙的，也就是这里将提到的隐藏文本功能。</p><h5 id="利用隐藏文本功能进行隐写"><a href="#利用隐藏文本功能进行隐写" class="headerlink" title="利用隐藏文本功能进行隐写"></a>利用隐藏文本功能进行隐写</h5><p><strong>实验：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 在实验机中找到隐写术目录，打开电子文档隐写，打开flag.doc</span><br><span class="line">- 在菜单栏中选择，并单击File（文件）-&gt;Tool（工具）-&gt;Option（选项） </span><br><span class="line">- 找到 隐藏文字 功能，选择这个功能，点击保存</span><br><span class="line">- 最终flag&#123;doc_stego_is_ez&#125;</span><br></pre></td></tr></table></figure><p><strong>首先打开，flag.doc</strong><br>打开flag.doc，能看到的文字内容只有<code>Flag in here。</code>,我们就可以猜测，flag是被隐藏起来了</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/14/JLdmzNC1kVhTW97.png" alt="image-20200614105634162"></p><p><strong>开启隐藏文字显示功能，查看flag是否被隐写</strong><br>在文件栏中，找到选项，打开显示，隐藏文字选项</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/14/YFlaW2tqB4vpiMK.png" alt="image-20200614105617350"></p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/14/wgpCzhIvT48irD2.png" alt="image-20200614105314028"></p><p><strong>思考</strong></p><ol><li>尝试将文本中的 Flag in here。 也隐藏掉。</li><li>尝试使用word自带的文档检查器检查是否又文字隐藏</li></ol><h5 id="word文档的xml转换"><a href="#word文档的xml转换" class="headerlink" title="word文档的xml转换"></a>word文档的xml转换</h5><p>我们可以将word文档转换成xml格式，当然反过来我们也可以将xml转换成word文档，这导致了我们如果重新打包为word文档的过程中，有可能被隐藏进其他数据。</p><p><strong>实验：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 在实验机中找到隐写术目录，打开电子文档隐写，打开file.docx</span><br><span class="line">- 看到的内容是 This is not the flag you&#39;re looking for.</span><br><span class="line">- 我们可以尝试分离word文档</span><br><span class="line">- 发现，其中包含了一个flag.txt的文件，我们可以直接用7Z，使用zip的方法重新打开file.doc</span><br><span class="line">- 打开flag.txt，最终flag&#123;this_would_be_the_flag_you_are_looking_for&#125;</span><br></pre></td></tr></table></figure><p><strong>首先，找到文件并打开文件查看</strong></p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/14/S8rMghJPwGN5LQX.png" alt="image-20200614105905294"></p><p><strong>尝试分离文件内容</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+bash-4.3$ file file.docx </span><br><span class="line">file.docx: Zip archive data, at least v2.0 to extract</span><br><span class="line">+bash-4.3$ 7z x file.docx -oout</span><br><span class="line"></span><br><span class="line">7-Zip [64] 9.20  Copyright (c) 1999-2010 Igor Pavlov  2010-11-18</span><br><span class="line">p7zip Version 9.20 (locale&#x3D;utf8,Utf16&#x3D;on,HugeFiles&#x3D;on,8 CPUs)</span><br><span class="line"></span><br><span class="line">Processing archive: file.docx</span><br><span class="line"></span><br><span class="line">Extracting  word&#x2F;numbering.xml</span><br><span class="line">Extracting  word&#x2F;settings.xml</span><br><span class="line">Extracting  word&#x2F;fontTable.xml</span><br><span class="line">Extracting  word&#x2F;styles.xml</span><br><span class="line">Extracting  word&#x2F;document.xml</span><br><span class="line">Extracting  word&#x2F;_rels&#x2F;document.xml.rels</span><br><span class="line">Extracting  _rels&#x2F;.rels</span><br><span class="line">Extracting  [Content_Types].xml</span><br><span class="line">Extracting  flag.txt</span><br><span class="line"></span><br><span class="line">Everything is Ok</span><br></pre></td></tr></table></figure><p>我们会发现又flag.txt的文件被打包在file.docx中，<br><strong>直接用7z等压缩包工具打开file.docx</strong></p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/14/Pabuoxc9ENVqSsR.png" alt="image-20200614110300105"></p><p><strong>思考</strong></p><ol><li>思考，如何制作这种隐写呢？</li><li>试试能否用binwalk 或者strings等工具查看隐写痕迹。</li></ol><h4 id="二、PDF文件中的信息隐藏"><a href="#二、PDF文件中的信息隐藏" class="headerlink" title="二、PDF文件中的信息隐藏"></a>二、PDF文件中的信息隐藏</h4><p>PDF隐写中，我们最常用，也是最熟知的工具就是wbStego4open,这是可以把文件隐藏到BMP，TXT,HTM和PDF文件中的工具，当然，这里我们只用他来最为以PDF为载体进行隐写的工具。</p><h5 id="工具："><a href="#工具：" class="headerlink" title="工具："></a>工具：</h5><ul><li>wbStego4open</li></ul><p><strong>实验：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 在实验机中找到隐写术目录，打开电子文档隐写，找到  stego.pdf文档</span><br><span class="line">- 在工具目录中找到 wbStego4open，使用工具载入文档，</span><br><span class="line">- 根据提示，一步一步完成隐藏信息的提取</span><br><span class="line">- 最终flag&#123;CTF_is_funny&#125;</span><br></pre></td></tr></table></figure><p><strong>首先找到目标文件</strong><br>在实验机中找到隐写术目录，打开电子文档隐写，找到 stego.pdf文档</p><p><strong>其次，找到工具wbStego4open</strong><br>在工具目录中找到 wbStego4open，使用工具载入文档，<br>Step 1 是文件介绍<br>Step 2 中，我们选择Decode，<br>Step 3 我们选择目标文件<br>Step 4 输入加密密码，如果是空密码，直接跳过<br>Step 5 为保存文件为 flag.txt</p><p>这道题没了大伙自己网上去找</p><p><strong>最后打开保存后的文件，flag.txt</strong><br>最后打开保存后的文件，flag.txt，就能得到flag了。</p><p><strong>思考</strong></p><ol><li>查阅其他资料，是否还要其他的PDF隐写方式，其原理又是什么？</li></ol><hr><h3 id="其他隐写"><a href="#其他隐写" class="headerlink" title="其他隐写"></a>其他隐写</h3><h4 id="一、数据包隐写术"><a href="#一、数据包隐写术" class="headerlink" title="一、数据包隐写术"></a>一、数据包隐写术</h4><p>数据包隐写术，就是将所要传达的信息和文件，以流量包的形式下发给参赛选手，参赛选手要从流量包中自行提取出所需要的文件或者相关内容进行解题。比较常用的工具是wireshark。关于此类部分的详细介绍，大家可以访问这个网址：<a href="https://ctf-wiki.github.io/ctf-wiki/misc/traffic/data/" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/misc/traffic/data/</a></p><h5 id="常用工具：-5"><a href="#常用工具：-5" class="headerlink" title="常用工具："></a>常用工具：</h5><ul><li>wireshark</li></ul><p>数据包隐写术目前两种考察行为：</p><p>①、flag或者关键信息直接隐藏在流量包中</p><p>②、flag相关文件隐藏在流量包中，需要分离文件</p><h4 id="二、细微的颜色差别"><a href="#二、细微的颜色差别" class="headerlink" title="二、细微的颜色差别"></a>二、细微的颜色差别</h4><p>就是看细心程度</p><p>藏在第一列的第四只皮卡丘的酒窝里</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/14/8nVd4DWyoTqmj5b.png" alt="image-20200614112236379"></p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/14/BLQ7jJZIa2kSOCs.png" alt="image-20200614112349386"></p><p>其他的题型随时补充</p><hr><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>一般的MISC题目都不是简简单单的一个隐写就能解决的，正常都包含了密码，编码，隐写甚至更多的计算机网络知识。</p><hr><p>本文大部分源于<a href="https://link.zhihu.com/?target=https%3A//xz.aliyun.com/">先知社区</a>中M1n3所作<a href="https://xz.aliyun.com/t/1833" target="_blank" rel="noopener">Misc 总结 —-隐写术之图片隐写</a>一文，对其进行了相应的补充并增加了自己的思考以作为自己的学习笔记，如有侵删。</p>]]></content:encoded>
      
      <comments>http://yoursite.com/undefined/Misc%E9%9A%90%E5%86%99%E6%9C%AF%E6%80%BB%E7%BB%93/#disqus_thread</comments>
    </item>
    
    <item>
      <title>内网渗透工具</title>
      <link>http://yoursite.com/undefined/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/</link>
      <guid>http://yoursite.com/undefined/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/</guid>
      <pubDate>Thu, 04 Jun 2020 13:56:06 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;内网渗透&quot;&gt;&lt;a href=&quot;#内网渗透&quot; class=&quot;headerlink&quot; title=&quot;内网渗透&quot;&gt;&lt;/a&gt;内网渗透&lt;/h1&gt;&lt;h2 id=&quot;TCP内网穿透&quot;&gt;&lt;a href=&quot;#TCP内网穿透&quot; class=&quot;headerlin
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>[TOC]</p><h1 id="内网渗透"><a href="#内网渗透" class="headerlink" title="内网渗透"></a>内网渗透</h1><h2 id="TCP内网穿透"><a href="#TCP内网穿透" class="headerlink" title="TCP内网穿透"></a>TCP内网穿透</h2><h3 id="常见内网穿透手段与工具介绍与使用"><a href="#常见内网穿透手段与工具介绍与使用" class="headerlink" title="常见内网穿透手段与工具介绍与使用"></a>常见内网穿透手段与工具介绍与使用</h3><p><strong>使用场景：</strong></p><p>攻击者从外网打开了入口，想入侵更多的内网机器</p><h4 id="常见工具"><a href="#常见工具" class="headerlink" title="常见工具"></a>常见工具</h4><p>lcx.exe   netsh   portmap   iptables</p><h5 id="LCX端口转发使用："><a href="#LCX端口转发使用：" class="headerlink" title="LCX端口转发使用："></a>LCX端口转发使用：</h5><p>lcx有两大功能：</p><ul><li>端口转发（listen和slave成对使用）</li><li>端口映射（tran）</li></ul><p><strong>端口转发：</strong></p><p>Lcx -Listen &lt;监听slave请求的端口(对应slave的第二个参数)&gt; &lt;等待连接的端口&gt;</p><p>Lcx -slave &lt;你的ip&gt; &lt;监听端口(对应listen的第一个参数)&gt; &lt;目标ip&gt; &lt;目标端口&gt;</p><p><strong>使用示例：</strong></p><p>使用环境：本机外网IP，它机内网IP</p><p>本机上运行：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lcx -<span class="section">listen</span> <span class="number">34</span> <span class="number">3434</span></span><br></pre></td></tr></table></figure><p>这句话的意思就是监听本机的34端口然后将数据转发到3434端口</p><p>它机上运行：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lcx -slave <span class="number">10.128</span><span class="number">.2</span><span class="number">.171</span> <span class="number">34</span> <span class="number">192.168</span><span class="number">.56</span><span class="number">.134</span> <span class="number">21</span></span><br></pre></td></tr></table></figure><p>假设本机IP为10.128.2.171 被控机为192.168.56.134</p><p>这句话的意思是内网被控机将21端口转发到本机IP—10.128.2.171的34端口上</p><p>然后本机就能通过连接本地的3434端口进行监听控制</p><h5 id="LCX端口映射使用："><a href="#LCX端口映射使用：" class="headerlink" title="LCX端口映射使用："></a>LCX端口映射使用：</h5><p>lcx有两大功能：</p><ul><li>端口转发（listen和slave成对使用）</li><li>端口映射（tran）</li></ul><p>Lcx -tran &lt;等待连接的端口&gt; &lt;目标ip&gt; &lt;目标端口&gt;</p><p>这句话的意思是将本机的等待映射的端口映射到目标ip 的目标端口</p><h5 id="Windows自带的转发工具netsh："><a href="#Windows自带的转发工具netsh：" class="headerlink" title="Windows自带的转发工具netsh："></a>Windows自带的转发工具netsh：</h5><p>配置方法<br>假定需要通过192.168.1.8的14941端口连接192.168.1.118的1494端口，则需要在192.168.1.8主机的命令行输入如下语句</p><p><strong>开启IPv6支持</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh<span class="built_in"> interface ipv6 </span>install</span><br></pre></td></tr></table></figure><p><strong>如果操作系统开启了主机防火墙，需要放行TCP 14941的入站连接，下面是配置端口转发的两条语句，区别不大，一条指定IP，一条默认本机IP</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh<span class="built_in"> interface </span>portproxy <span class="builtin-name">add</span> v4tov4 <span class="attribute">listenaddress</span>=192.168.1.8 <span class="attribute">listenport</span>=14941 <span class="attribute">connectaddress</span>=192.168.1.118 <span class="attribute">connectport</span>=1494</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh<span class="built_in"> interface </span>portproxy <span class="builtin-name">add</span> v4tov4 <span class="attribute">listenport</span>=14941 connectaddress =192.168.1.118 <span class="attribute">connectport</span>=1494</span><br></pre></td></tr></table></figure><p><strong>取消上面配置的端口转发，可以用如下语句：</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh<span class="built_in"> interface </span>portproxy delete v4tov4 listenaddress 192.168.1.8 listenport =33891</span><br></pre></td></tr></table></figure><p><strong>如果想查看已经配置了哪些端口转发，可以用如下语句：</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh<span class="built_in"> interface </span>portproxy show v4tov4</span><br></pre></td></tr></table></figure><h5 id="LINUX自带的转发工具iptables："><a href="#LINUX自带的转发工具iptables：" class="headerlink" title="LINUX自带的转发工具iptables："></a>LINUX自带的转发工具iptables：</h5><p><strong>首先开启内核转发：</strong></p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="number">1</span>&gt;<span class="meta-keyword">/proc/</span>sys<span class="meta-keyword">/net/</span>ipv4/ip_forward          <span class="comment">//当主机发现不是自己的流量就会进行转发</span></span><br><span class="line">sysctl -p                                     <span class="comment">//立即生效</span></span><br></pre></td></tr></table></figure><p><strong>配置iptables进行端口转发</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A PREROUTING -p tcp -m tcp --dport21521 -j DNET --to-destination <span class="number">192.168</span><span class="number">.0</span><span class="number">.211</span>:<span class="number">1521</span></span><br><span class="line"><span class="comment">//把目的端口为21521的端口的流量转发到192.168.0.211主机的1521端口，DNAT表示目的地址转换</span></span><br><span class="line">iptables -t nat -A POSTROUTING -s <span class="number">192.168</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">16</span> -d <span class="number">192.168</span><span class="number">.0</span><span class="number">.211</span> -p tcp -m tcp --dport <span class="number">1521</span> -j SNAT --to-source <span class="number">192.168</span><span class="number">.0</span><span class="number">.132</span></span><br><span class="line"><span class="comment">//指定192.168.0.0/16 ip段的请求进行来源地址转换</span></span><br></pre></td></tr></table></figure><h3 id="内网代理工具"><a href="#内网代理工具" class="headerlink" title="内网代理工具"></a>内网代理工具</h3><h4 id="regeorg内网代理工具"><a href="#regeorg内网代理工具" class="headerlink" title="regeorg内网代理工具"></a>regeorg内网代理工具</h4><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606132624260.png" alt="image-20200606132624260"></p><p>reGeorgSocksProxy.py是运行在本机上的，渗透一个网站之后，上传对应格式的tunnel文件到服务器</p><h5 id="step1："><a href="#step1：" class="headerlink" title="step1："></a>step1：</h5><p>首先通过webshell等方式上传对应的可使用的代理脚本</p><h5 id="step2："><a href="#step2：" class="headerlink" title="step2："></a>step2：</h5><p>然后攻击者在本地执行python脚本，利用网络上的脚本建立socks5代理隧道</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python reGeorgSocksProxy.py -u <span class="string">http:</span><span class="comment">//10.128.2.171/tunnel.nosocket.php</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606135145093.png" alt="image-20200606135145093"></p><p>此时用软件连接到socks5代理127.0.0.1:8888就处于该服务器的内网环境了</p><h4 id="配合使用的软件："><a href="#配合使用的软件：" class="headerlink" title="配合使用的软件："></a>配合使用的软件：</h4><p><strong>MAC下：</strong><br>proxychains（Proxifier/直接用burpsuite或浏览器连接到socks5代理<br><strong>Windows下：</strong><br>Proxifier.exe/直接用burpsuite或浏览器连接到socks5代理<br><strong>Linux下：</strong><br>proxychains</p><p><strong>proxychains配置</strong></p><p>首先修改配置文件</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606135511794.png" alt="image-20200606135511794"></p><p>在MAC或者linux_上，修改配置文件后，就可以直接在想执行的命令前加上proxychians命令，这样会自动让后面的命令通过代理执行</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606135625508.png" alt="image-20200606135625508"></p><h3 id="集代理和端口转发功能于一身的Earthworm（多平台）"><a href="#集代理和端口转发功能于一身的Earthworm（多平台）" class="headerlink" title="集代理和端口转发功能于一身的Earthworm（多平台）"></a>集代理和端口转发功能于一身的Earthworm（多平台）</h3><h4 id="直接当做socks5代理使用"><a href="#直接当做socks5代理使用" class="headerlink" title="直接当做socks5代理使用"></a>直接当做socks5代理使用</h4><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ew_wi<span class="symbol">n32</span>.exe -s ssocksd -h</span><br><span class="line"><span class="comment">//列出参数</span></span><br></pre></td></tr></table></figure><p>使用命令</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ew_win32.exe -s ssocksd -l <span class="number">8082</span></span><br><span class="line"><span class="comment">//监听8082端口</span></span><br></pre></td></tr></table></figure><h4 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h4><p>rssocks和rcsocks则是成对使用的选项，可以直接搭建lcx那样的端口转发隧道，只不过转发的端口直接就是earthworm提供的socks5代理</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606140307805.png" alt="image-20200606140307805"></p><p>内网victim主机执行的是将建立在本地的socks5代理转发到公网某端口<br>公网attacker的主机执行的是监听两个端口，一个用来接收attacker的链接，一个用来转发内网的代理</p><h5 id="step1"><a href="#step1" class="headerlink" title="step1"></a>step1</h5><p>首先在公网主机上监听好两个端口，等待内网主机链接</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606140721591.png" alt="image-20200606140721591"></p><h5 id="step2"><a href="#step2" class="headerlink" title="step2"></a>step2</h5><p>然后在victim的电脑上执行earthworm以开启socks5代理，并执行转发</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606140744284.png" alt="image-20200606140744284"></p><h5 id="step3"><a href="#step3" class="headerlink" title="step3"></a>step3</h5><p>浏览器设置好代理后就相当于已经处于该内网直接可以访问内网的资源</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606140856159.png" alt="image-20200606140856159"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606140910046.png" alt="image-20200606140910046"></p><p>或者也可以通过<br>proxychains/proxifier把代理用在其<br>他的一些工具上<br>nmap/sqlmap/rdesktop</p><h3 id="多级级联"><a href="#多级级联" class="headerlink" title="多级级联"></a>多级级联</h3><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606141238357.png" alt="image-20200606141238357"></p><p>数据流向：SOCKS v5-&gt; 1080-&gt; 8888-&gt; 9999-&gt; 7777-&gt; rssocks</p><h3 id="ICMP-UDP内网穿透"><a href="#ICMP-UDP内网穿透" class="headerlink" title="ICMP/UDP内网穿透"></a>ICMP/UDP内网穿透</h3><h4 id="icmptunnel内网穿透"><a href="#icmptunnel内网穿透" class="headerlink" title="icmptunnel内网穿透"></a>icmptunnel内网穿透</h4><p>icmptunnel借助icmp协议进行通信</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606141542429.png" alt="image-20200606141542429"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606141552013.png" alt="image-20200606141552013"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606141640116.png" alt="image-20200606141640116"></p><h4 id="服务端执行的脚本和启动命令"><a href="#服务端执行的脚本和启动命令" class="headerlink" title="服务端执行的脚本和启动命令"></a>服务端执行的脚本和启动命令</h4><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606141716894.png" alt="image-20200606141716894"></p><h4 id="客户端执行的脚本和启动的命令"><a href="#客户端执行的脚本和启动的命令" class="headerlink" title="客户端执行的脚本和启动的命令"></a>客户端执行的脚本和启动的命令</h4><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606141809132.png" alt="image-20200606141809132"></p><h3 id="DNS协议穿透内网"><a href="#DNS协议穿透内网" class="headerlink" title="DNS协议穿透内网"></a>DNS协议穿透内网</h3><h4 id="dns2tcp工具安装"><a href="#dns2tcp工具安装" class="headerlink" title="dns2tcp工具安装"></a>dns2tcp工具安装</h4><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606142043435.png" alt="image-20200606142043435"></p><h4 id="解析域名"><a href="#解析域名" class="headerlink" title="解析域名"></a>解析域名</h4><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606142111545.png" alt="image-20200606142111545"></p><p>一条A记录和一条Ns记录当查询到ssrf这个子域名的时候(xxxx.ssrf.nuptzj.cn)会去ns记录指向的blog子域名查询</p><h4 id="配置服务端"><a href="#配置服务端" class="headerlink" title="配置服务端"></a>配置服务端</h4><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606142433789.png" alt="image-20200606142433789"></p><p>启动服务器端</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dns2tcpd -f /etc/dns2tcpd.conf -d <span class="number">1</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606142523168.png" alt="image-20200606142523168"></p><p>启动客户端 </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">dns2tcpc</span> <span class="selector-tag">-r</span> <span class="selector-tag">ssh</span> <span class="selector-tag">-I</span> 7777 <span class="selector-tag">-z</span> <span class="selector-tag">ssrf</span><span class="selector-class">.nuptzj</span><span class="selector-class">.cn</span> <span class="selector-tag">blog</span><span class="selector-class">.nuptzj</span><span class="selector-class">.cn</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606143114174.png" alt="image-20200606143114174"></p><p>连接到ssh服务</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606143205496.png" alt="image-20200606143205496"></p><h3 id="端口复用技术"><a href="#端口复用技术" class="headerlink" title="端口复用技术"></a>端口复用技术</h3><p>参考链接 <a href="https://xz.aliyun.com/t/1661" target="_blank" rel="noopener">https://xz.aliyun.com/t/1661</a></p><h2 id="常见工具介绍与使用"><a href="#常见工具介绍与使用" class="headerlink" title="常见工具介绍与使用"></a>常见工具介绍与使用</h2><h3 id="Cobaltstrike使用介绍"><a href="#Cobaltstrike使用介绍" class="headerlink" title="Cobaltstrike使用介绍"></a>Cobaltstrike使用介绍</h3><h4 id="Cobaltstrike搭建与应用"><a href="#Cobaltstrike搭建与应用" class="headerlink" title="Cobaltstrike搭建与应用"></a>Cobaltstrike搭建与应用</h4><p>启动Cobaltstrike Team Server</p><p>配置完java环境以后直接运行teamserver文件就可以开启<br>./teamserver[服务器的IP] [你的连接密码]</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606144233886.png" alt="image-20200606144233886"></p><p>Cobalt Strike Client<br>运行cobaltstrike客户端文件连接到该服务器</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606144742574.png" alt="image-20200606144742574"></p><p>在面板中填入配置信息就可以点击connect连接到C&amp;C服务器，Cobaltstrike是一个适合团队协作的平台，可以多人连接到服务器，一起对客户机进行渗透操作，共享shell</p><h4 id="Listener设置"><a href="#Listener设置" class="headerlink" title="Listener设置"></a>Listener设置</h4><p>首次使用需要先设置一个默认的listener，就是指的程序默认监听回连靶机的方式（就是渗透的靶机回连的端口是vps的8088端口，然后客户端这边监听vps的8088）</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606144855822.png" alt="image-20200606144855822"></p><p>监听有很多种方式，dns，ttp，https选择https或者dns协议会让通信更加隐秘，不那么容易被侦测到流量<img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606145236715.png" alt="image-20200606145236715"></p><h4 id="Attacks模块"><a href="#Attacks模块" class="headerlink" title="Attacks模块"></a>Attacks模块</h4><p>设置完监听我们就可以来看看有哪些方式能用来攻击</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606145433934.png" alt="image-20200606145433934"></p><p>Cs提供的直接生成恶意文件的方式</p><p>Cs提供的包括站点克隆（钓鱼），添加文件到网页 链接利用WEB方式传输payload，应用识别等辅助攻击功能</p><h4 id="生成可执行文件后门"><a href="#生成可执行文件后门" class="headerlink" title="生成可执行文件后门"></a>生成可执行文件后门</h4><p>使用Attacks-&gt;Packages–&gt;Windows executable生成一个恶意文件</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606145830581.png" alt="image-20200606145830581"></p><p>listener表示当对方运行了这个.exe文件后，对方已怎样的方式回连到主控端</p><h4 id="执行效果"><a href="#执行效果" class="headerlink" title="执行效果"></a>执行效果</h4><p>通过各种手段让靶机执行以后，可以看到客户端上线啦~<br>CS的载荷不是时刻保持socket通信的，而是有–定的心跳时间，默认是每一分钟会向C&amp;C服务器拉取一-下最新的指令并执行，所以我们下达指令后，靶机会周期性的来获取命令然后执行并返回结果（可以通过Beacon中的sleep命令调整时间）</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606150051268.png" alt="image-20200606150051268"></p><h4 id="如何进入Beacon控制台"><a href="#如何进入Beacon控制台" class="headerlink" title="如何进入Beacon控制台"></a>如何进入Beacon控制台</h4><p>对着目标右键选择interact可以进入这个目标的控制台界面</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606150458393.png" alt="image-20200606150458393"></p><h3 id="Metasploit使用介绍"><a href="#Metasploit使用介绍" class="headerlink" title="Metasploit使用介绍"></a>Metasploit使用介绍</h3><h3 id="Empire使用介绍"><a href="#Empire使用介绍" class="headerlink" title="Empire使用介绍"></a>Empire使用介绍</h3><h4 id="Empire工具安装向导"><a href="#Empire工具安装向导" class="headerlink" title="Empire工具安装向导"></a>Empire工具安装向导</h4><p>项目地址：<br><a href="https://github.com/EmpireProject/Empire" target="_blank" rel="noopener">https://github.com/EmpireProject/Empire</a><br>安装方法：<br>使用ubuntu或者debian<br>git clone <a href="https://github.com/EmpireProject/Empire" target="_blank" rel="noopener">https://github.com/EmpireProject/Empire</a><br>cd setup&amp;&amp;sudo./install.sh<br>这个工具安装前要先配置好python和pip</p><h4 id="设置Listener"><a href="#设置Listener" class="headerlink" title="设置Listener"></a>设置Listener</h4><p>empire的监听方式</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606152723567.png" alt="image-20200606152723567"></p><p>包含的类型比较多：<br>●可以委派给其他监听器的比如msf的meterpreter<br>●基于利用微软onedrive作为c&amp;c服务器 的监听器onedrive直接是在本机监听http及 多种http相关协议的多个监听器</p><p>执行uselistener http以后直接按照默认配置执行execute会启动http80端口的监听当然也可以通过info命令显示选项，通过set命令调整设置以后再execute启动</p><h4 id="生成后门"><a href="#生成后门" class="headerlink" title="生成后门"></a>生成后门</h4><p>设置完监听模式以后生成payload<br>可以直接通过launcher powershel[python]http生成连接到对应的监听器的payload</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606152928138.png" alt="image-20200606152928138"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606153712491.png" alt="image-20200606153712491"><br><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606153724477.png" alt="image-20200606153724477"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606153758800.png" alt="image-20200606153758800"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606153817638.png" alt="image-20200606153817638"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606153853515.png" alt="image-20200606153853515"></p>]]></content:encoded>
      
      <comments>http://yoursite.com/undefined/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Lsb隐写总结</title>
      <link>http://yoursite.com/undefined/Lsb%E9%9A%90%E5%86%99/</link>
      <guid>http://yoursite.com/undefined/Lsb%E9%9A%90%E5%86%99/</guid>
      <pubDate>Tue, 02 Jun 2020 11:10:37 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;摘自：&lt;a href=&quot;https://segmentfault.com/a/1190000016223897&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://segmentfault.com/a/1190000016223897&lt;/a&gt;&lt;/
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>摘自：<a href="https://segmentfault.com/a/1190000016223897" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016223897</a></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">其实吧一开始我是想把一大堆算法理论和公式摆上来讲讲lsb隐写是什么，但是想想，这种做法是真的可恶啊，摆明不想让人看嘛。所以我想先从一道例题出发，原理什么的将在这个过程中，细细地讲来。</span><br><span class="line">先来看下面一张图，这道题来自实验吧（原题链接：http:<span class="regexp">//</span>www.shiyanbar.com<span class="regexp">/ctf/</span><span class="number">1897</span>），题目名字叫--最低位的轻吻。</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://segmentfault.com/img/bVbgeGu?w=485&h=650" alt="图片描述"></p><p>打开看是一张很著名的图片—–胜利之吻。图片是bmp格式。看到题目中有最低位几个字，如果是对隐写类的题目熟悉的话就能一下子想到是lsb隐写。因为lsb隐写就是利用的图像中的最低有效位。最低有效位这个词在前文中出现很多次了，但是到底是什么意思呢？<br>首先来讲png图片，png图片是一种无损压缩的位图片形格式，也只有在无损压缩或者无压缩的图片（BMP）上实现lsb隐写。如果图像是jpg图片的话，就没法使用lsb隐写了，原因是jpg图片对像数进行了有损压缩，我们修改的信息就可能会在压缩的过程中被破坏。而png图片虽然也有压缩，但却是无损压缩，这样我们修改的信息也就能得到正确的表达，不至于丢失。BMP的图片也是一样的，是没有经过压缩的。BMP图片一般是特别的大的，因为BMP把所有的像数都按原样储存，没有进行压缩。<br>png图片中的图像像数一般是由RGB三原色（红绿蓝）组成，每一种颜色占用8位，取值范围为0x00~0xFF，即有256种颜色，一共包含了256的3次方的颜色，即16777216种颜色。而人类的眼睛可以区分约1000万种不同的颜色，这就意味着人类的眼睛无法区分余下的颜色大约有6777216种。<br><img src= "/img/loading.gif" data-src="https://segmentfault.com/img/bVbgeGw?w=842&h=323" alt="图片描述"></p><p>LSB隐写就是修改RGB颜色分量的最低二进制位也就是最低有效位（LSB），而人类的眼睛不会注意到这前后的变化，每个像数可以携带3比特的信息。<br><img src= "/img/loading.gif" data-src="https://segmentfault.com/img/bVbgeGG?w=865&h=331" alt="图片描述"></p><p>上图我们可以看到，十进制的235表示的是绿色，我们修改了在二进制中的最低位，但是颜色看起来依旧没有变化。我们就可以修改最低位中的信息，实现信息的隐写。我修改最低有效位的信息的算法就叫做lsb加密算法，提取最低有效位信息的算法叫做lsb解密算法。<br>再放两张图加深下理解：<br><img src= "/img/loading.gif" data-src="https://segmentfault.com/img/bVbgeGI?w=675&h=227" alt="图片描述"></p><p><img src= "/img/loading.gif" data-src="https://segmentfault.com/img/bVbgeGK?w=624&h=332" alt="图片描述"></p><p>回到题目上来，这里我们使用一款功能很强大的lsb隐写分析工具—StegSolve图片通道查看器（下载地址：<a href="http://www.caesum.com/handbook/Stegsolve.jar" target="_blank" rel="noopener">http://www.caesum.com/handboo…</a>）。<br>使用过photoshop的朋友应该对图片通道有些概念，一幅完整的图像，红色绿色蓝色三个通道缺一不可。一幅图像，如果关闭了红色通道，那么图像就偏青色。如果关闭了绿色通道，那么图像就偏洋红色。如果关闭了蓝色通道，那么图像就偏黄色。当然还有个Alpha通道，是一个8位的灰度通道，也可以理解为透明度（粗糙的理解）。关于图像通道详细的讲解可以自行百度，这里不再详细说明。<br>使用stegsolve打开图片，按右方向键查看各通道显示的图像。一般有些题目会在某一个图像通道中直接显示出flag，但是显然这题不行，看来还需要绕些弯，要获取最低位的图片信息。<br>所以这道题的思路就是将图片转换成0,1 像素点（图像处理问题），这里可以直接使用MATLAB（MATLAB特别适合图像处理，而且语法特别特别简单）：<br>在命令行窗口输入以下命令：</p><blockquote><blockquote><p>filename=’01.bmp’;<br>imfinfo(filename);<br>A = imread(filename);<br>B = logical(bitget(A,1));<br>imshow(B);<br>指令详解：<br><img src= "/img/loading.gif" data-src="https://segmentfault.com/img/bVbgeG0?w=772&h=219" alt="图片描述"></p></blockquote></blockquote><p>运行得结果如下。扫描这个二维码，就能直接得到flag，有兴趣的朋友可以自己动手扫一下。<br><img src= "/img/loading.gif" data-src="https://segmentfault.com/img/bVbgeHp?w=865&h=479" alt="图片描述"></p><p>这里还可以使用其他的编程算法来解，原理都是一样的，但如果不会matlab语法，该怎么办呢。其实这题还有一种解法，因为只是简单的获取最后一位然后画图，但是为啥stegsolve获取不到呢。<br>我们先来看下图像信息：<br><img src= "/img/loading.gif" data-src="https://segmentfault.com/img/bVbgeHC?w=583&h=222" alt="图片描述"></p><p>发现是bmp的8位灰度图。猜测是StegSolve解析8位的BMP存在问题？</p><p>常见的8位通道RGB图像，3个通道共24位，即一张24位RGB图像里可表现大约1670万种颜色；而16位通道RGB图像，3个通道共48位，2的48次方是多少种颜色。32位深度CMYK（8位×4通道）。<br>这里的8位、16位、32位指颜色深度（Color Depth）用来度量图像中有多少颜色信息可用于显示或打印像素，其单位是“位（Bit）”，所以颜色深度有时也称为位深度。<br>常用的颜色深度是1位、8位、24位和32位。1位有两个可能的数值：0或1。较大的颜色深度（每像素信息的位数更多）意味着数字图像具有较多的可用颜色和较精确的颜色表示。</p><p>试试转换成png格式呢再看看呢？用画图另存为png格式（不能直接改后缀）。此时发现文件变大，图像信息如下图：<br><img src= "/img/loading.gif" data-src="https://segmentfault.com/img/bVbgeHZ?w=559&h=183" alt="图片描述"></p><p>用StegSolve打开后，在RGB的最后一位看到二维码。（原图在保存的时候显示的类型是256色位图，就是位深度为8，如果保存为24位位图的bmp格式，不转换为png格式，也能用StegSolve找到如上图的二维码。）<br><img src= "/img/loading.gif" data-src="https://segmentfault.com/img/bVbgeIm?w=519&h=803" alt="图片描述"></p><p><img src= "/img/loading.gif" data-src="https://segmentfault.com/img/bVbgeIm?w=519&h=803" alt="图片描述"></p><p>所以我们改变图片位深度，就能得到其中的二维码信息。</p><p><strong>Lsb隐写的变形题</strong></p><p>经过上面的例子，我们基本上了解了什么是lsb隐写。一般的lsb隐写我们都能使用工具或者编写程序提取到图片的最低有效位信息，从而得到其中的内容。但是出题人的脑洞不局限于此，lsb隐写还有各种扩展的使用方法。下面是网鼎杯第一场中的一道杂项题，也是一道lsb隐写题。不同的是，光提取最低有效位是不能进行解答的。<br>首先给我们的是一张花花的图是png格式。题目名字是minify，使变小的意思，那应该就是指lsb隐写。<br><img src= "/img/loading.gif" data-src="https://segmentfault.com/img/bVbgeIN?w=864&h=42" alt="图片描述"></p><p>光凭肉眼是真的什么也看不出，我们借助于工具StegSolve进行分析。<br>一路翻下去，除了花花的还是花花的，唯一值得怀疑的地方就在red plane 0 这里是纯黑，<br><img src= "/img/loading.gif" data-src="https://segmentfault.com/img/bVbgeIR?w=865&h=163" alt="图片描述"></p><p><img src= "/img/loading.gif" data-src="https://segmentfault.com/img/bVbgeIY?w=841&h=657" alt="图片描述"></p><p>说明这里什么也没有，正常的图片都不会是这样子的，其它通道也都显示正常。所以这个异常给我们什么启示呢？从这里可以真正确定是lsb隐写了。</p><p>那我们要从其他的通道比如：blue、alpha、green中找些到信息。整张图片看起来是毫无规则的像素点，那一定想把真正的信息隐藏起来，再用一些毫无规则的像素点干扰我们。我们如果想得到其中的信息，就要去掉这些干扰点。但是到底去掉哪些呢。经过前面的步骤我们知道了信息可能隐藏在plane 0中，所以我们要先把各个通道的plane 0提取出来。Red plane 0因为是空信息，可以不用提取了。我们提取出（File-&gt;Save as）Green plane 0、Alpha plane 0、Blue plane 0，把他们各另存为一张图。然后各个图进行比对（Analyse-&gt;image Combiner），最后发现Alpha plane 0 和Green plane 0 异或运算下的图出现了flag<br><img src= "/img/loading.gif" data-src="https://segmentfault.com/img/bVbgeI2?w=865&h=135" alt="图片描述"></p><p>异或对比常常是为了检查两张图片之间的差异，能发现我们肉眼看不到的及细微的差异。<br><img src= "/img/loading.gif" data-src="https://segmentfault.com/img/bVbgeI6?w=528&h=426" alt="图片描述"></p><p>上图是异或（XOR）对比出一张图片中的区别，所以用这个方法，也能把我们的信息隐藏在其中，但我觉得这并不是一种实用的方法。</p>]]></content:encoded>
      
      <comments>http://yoursite.com/undefined/Lsb%E9%9A%90%E5%86%99/#disqus_thread</comments>
    </item>
    
    <item>
      <title>现代对称加密算法原理</title>
      <link>http://yoursite.com/undefined/%E7%8E%B0%E4%BB%A3%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/</link>
      <guid>http://yoursite.com/undefined/%E7%8E%B0%E4%BB%A3%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/</guid>
      <pubDate>Wed, 20 May 2020 12:27:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h3&gt;&lt;p&gt;对称密码沿用替代置换等古典密码技术(混乱与扩散) , 被称为传统密码&lt;/p&gt;
&lt;h3 id=&quot;原理：&quot;&gt;&lt;a href=&quot;#原理：&quot;
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>对称密码沿用替代置换等古典密码技术(混乱与扩散) , 被称为传统密码</p><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><h4 id="加密算法："><a href="#加密算法：" class="headerlink" title="加密算法："></a>加密算法：</h4><p>一次性密码本+完美秘密+伪随机数生成+Diffie-Hellman密钥交换</p><h5 id="一次性码本原理："><a href="#一次性码本原理：" class="headerlink" title="一次性码本原理："></a>一次性码本原理：</h5><p>首先是需要加密的明文：“hello”; ——————————————5位字母</p><p>然后生成一串拥有与明文相同位数的随机位移：“2,3,1,2,1”———-5个位移</p><p>每个位移分别对应相同位的字母进行位移得到密文：</p><p><strong>这样加密的信息有两个强大的特性。</strong></p><p>第一：位移没有重复的规律</p><p>第二：加密的消息将有一个均匀的频率分布，将不会被频率分析破解</p><h5 id="完美密码原理："><a href="#完美密码原理：" class="headerlink" title="完美密码原理："></a>完美密码原理：</h5><p>假设A写信给B,长度为20个字母，下一步，A用一个和B共享的密钥，它由20个随机生成的位移组成， 每个位移在1到26之间，密钥空间就是所有可能结果的组合。所以，生成一个密钥相当于，从这20个字母的组合中随机选一个</p><p>例：</p><p>假设要将   “ALICE”   通过位移加密，首先随机生成5个位移，每个位移的值为0-26，对应26个英文字母。</p><p>当使用位移进行加密时，也就是说A经过位移有26种可能，然后L经过位移也有26种可能 ……… 一共就是:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">位移空间 = <span class="number">26</span>*<span class="number">26</span>*<span class="number">26</span>*<span class="number">26</span>*<span class="number">26</span></span><br></pre></td></tr></table></figure><p>然后因为是随机得到的5个位移，就能理解每一个位移都有26种可能，所以密钥空间为：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">密钥空间 = <span class="number">26</span>*<span class="number">26</span>*<span class="number">26</span>*<span class="number">26</span>*<span class="number">26</span></span><br></pre></td></tr></table></figure><p>当使用密钥空间中的 “一种密钥” 对位移空间的 “一种位移可能” 进行加密时，生成一种对应的密文信息；</p><p>所以密文信息空间的大小等于密钥空间；</p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">密文信息空间</span>=<span class="string">位移空间=密钥空间</span></span><br></pre></td></tr></table></figure><p>这对应了完美密码，当有人仅仅获得了加密文字的一页，他们所知道的唯一的事情是每个消息是同等可能的。所以无论有多大的计算能力，都不能帮助改进一个盲目的猜测。</p><p>现在要考虑的是在考虑一次性码本的时候，是我们需要事先分享这些长长的密钥，为了解决这个问题 ，我们需要放松对秘密的定义，这需要引入伪随机数的概念。</p><h5 id="伪随机数生成原理："><a href="#伪随机数生成原理：" class="headerlink" title="伪随机数生成原理："></a>伪随机数生成原理：</h5><p>首先选择一个数</p><p>例 “121” ，称之为 “种子”</p><p>然后将 “种子” 相乘获得乘积 “14641”  </p><p>再从乘积中取中间的与”种子“相同位数的一个数 “464”，</p><p>重复生成乘积，再取中间值，最后生成一串随机数</p><p>这个方法叫做 “中间平方”</p><p>生成的随机数序列的随机性依赖于最初种子的随机性，同样的种子，导致同样的序列，所以，随机生成的序列区别于伪随机生成的序列的实质是什么？</p><p>中间平方的生成会有一个周期，但是当“种子”的长度增加，就会加大这个周期</p><p>与之同时带来一个问题，如何分享这个随机数的种子</p><h5 id="Diffie-Hellman密钥交换原理："><a href="#Diffie-Hellman密钥交换原理：" class="headerlink" title="Diffie-Hellman密钥交换原理："></a>Diffie-Hellman密钥交换原理：</h5><p><img src= "/img/loading.gif" data-src="https://pic3.zhimg.com/80/5d668818881609c8543e6efa7c0d6af1_720w.jpg" alt=""></p><p>上图很经典<br>它的数学基础就是离散对数这个数学难题。用它进行密钥交换的过程简述如下： </p><p>选取两个大数p和g并公开，其中p是一个素数，g是p的一个<strong>模p本原单位根(primitive root module p)</strong>，所谓<strong>本原单位根</strong>就是指在<strong>模p乘法运算下</strong>，g的1次方，2次方……(p-1)次方这p-1个数互不相同，并且取遍1到p-1； </p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">对于Alice(其中的一个通信者)，随机产生一个整数<span class="keyword">a</span>，<span class="keyword">a</span>对外保密，计算Ka = g^<span class="keyword">a</span> <span class="keyword">mod</span> p，将Ka发送给Bob；</span><br><span class="line"></span><br><span class="line">对于Bob(另一个通信者)，随机产生一个整数b，b对外保密，计算Kb = g^b <span class="keyword">mod</span> p，将Kb发送给Alice； </span><br><span class="line"></span><br><span class="line">在Alice方面，收到Bob送来的Kb后，计算出密钥为：key = Kb^<span class="keyword">a</span> <span class="keyword">mod</span> p = g^(b*<span class="keyword">a</span>) <span class="keyword">mod</span> p <span class="keyword">mod</span> p； </span><br><span class="line"></span><br><span class="line">对于Bob，收到Alice送来的Ka后，计算出密钥为：key = Ka ^ b <span class="keyword">mod</span> p = g^(<span class="keyword">a</span>*b) <span class="keyword">mod</span> p <span class="keyword">mod</span> p。</span><br><span class="line"></span><br><span class="line">攻击者知道p和g，并且截获了Ka和Kb，但是当它们都是非常大的数的时候，依靠这四个数来计算<span class="keyword">a</span>和b非常困难，这就是离散对数数学难题。</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">（1）Alice与Bob确定两个大素数n和g，这两个数不用保密 </span><br><span class="line">（2）Alice选择另一个大随机数x，并计算A如下：<span class="attribute">A</span>=g^xmod n </span><br><span class="line">（3）Alice将A发给Bob </span><br><span class="line">（4）Bob  选择另一个大随机数y，并计算B如下：<span class="attribute">B</span>=g^ymod n </span><br><span class="line">（5）Bob将B发给Alice </span><br><span class="line">（6）计算秘密密钥K1如下：<span class="attribute">K1</span>=B^xmod n </span><br><span class="line">（7）计算秘密密钥K2如下：<span class="attribute">K2</span>=A^ymod n  <span class="attribute">K1</span>=K2，因此Alice和Bob可以用其进行加解密</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://yoursite.com/undefined/%E7%8E%B0%E4%BB%A3%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
